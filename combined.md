# Атрибутивные директивы: Применение динамических классов и стилей с `ngClass` и `ngStyle`.

### Неделя 1: Основы Angular

#### Атрибутивные директивы: Применение динамических классов и стилей с `ngClass` и `ngStyle`

В этой части нашего курса мы разберём два мощных инструмента Angular, которые позволяют делать веб-страницы более интерактивными и динамичными за счёт изменения стилей и классов элементов. Речь пойдёт об атрибутивных директивах `ngClass` и `ngStyle`. Они помогают легко и понятно изменять внешний вид наших компонентов в зависимости от определённых условий.

##### Зачем нужны `ngClass` и `ngStyle`?

Иногда в наших приложениях нужно изменить внешний вид элемента динамически. Например, подсветить кнопку, если на неё можно нажать, или изменить цвет фона в зависимости от температуры воздуха. Инструменты `ngClass` и `ngStyle` отлично подходят для таких задач.

#### `ngClass`: Управление классами

Директива `ngClass` позволяет добавлять или удалять CSS-классы в зависимости от условий. Это может быть полезно, когда необходимо динамически изменять внешний вид элементов.

**Пример:**

Допустим, у нас есть список задач, и мы хотим выделять те, которые уже выполнены:

HTML:

```html
<ul>
  <li *ngFor="let task of tasks"
      [ngClass]="{'completed': task.completed, 'pending': !task.completed}">
    {{ task.name }}
  </li>
</ul>
```

TypeScript:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-task-list',
  templateUrl: './task-list.component.html',
  styleUrls: ['./task-list.component.css']
})
export class TaskListComponent {
  tasks = [
    { name: 'Задача 1', completed: true },
    { name: 'Задача 2', completed: false },
    { name: 'Задача 3', completed: false }
  ];
}
```

CSS:

```css
.completed {
  text-decoration: line-through;
  color: green;
}

.pending {
  color: red;
}
```

**Что происходит:**

- Мы используем директиву `ngFor` для итерации по списку `tasks`.
- Директива `ngClass` добавляет класс `completed`, если задача выполнена, и класс `pending`, если нет.
- `completed` и `pending` — это CSS-классы, которые стилизуют элементы списка.

#### `ngStyle`: Управление инлайн-стилями

Директива `ngStyle` используется для динамического управления инлайн-стилями. Она позволяет изменять такие свойства, как цвет, размер шрифта, отступ и т. д.

**Пример:**

Предположим, мы хотим изменять размер текста в зависимости от важности сообщения:

HTML:

```html
<div *ngFor="let message of messages"
     [ngStyle]="{'font-size': messageSize(message.importance), 'color': message.color}">
  {{ message.text }}
</div>
```

TypeScript:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-message-list',
  templateUrl: './message-list.component.html',
  styleUrls: ['./message-list.component.css']
})
export class MessageListComponent {
  messages = [
    { text: 'Важное сообщение', importance: 'high', color: 'red' },
    { text: 'Обычное сообщение', importance: 'medium', color: 'black' },
    { text: 'Второстепенное сообщение', importance: 'low', color: 'gray' }
  ];

  messageSize(importance: string): string {
    switch (importance) {
      case 'high':
        return '20px';
      case 'medium':
        return '16px';
      case 'low':
        return '12px';
      default:
        return '14px';
    }
  }
}
```

**Что здесь происходит:**

- Мы используем `ngStyle` для установки динамического размера шрифта и цвета.
- Метод `messageSize` возвращает размер шрифта в зависимости от важности сообщения.

#### Совмещение `ngClass` и `ngStyle`

Эти директивы можно использовать вместе, чтобы осуществлять комплексное управление стилями.

**Пример:**

В этом примере будем менять как класс, так и стиль элемента:

HTML:

```html
<div *ngFor="let item of items"
     [ngClass]="{ 'active': item.active }"
     [ngStyle]="{'background-color': item.active ? 'lightblue' : 'lightgrey'}">
  {{ item.name }}
</div>
```

TypeScript:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-item-list',
  templateUrl: './item-list.component.html',
  styleUrls: ['./item-list.component.css']
})
export class ItemListComponent {
  items = [
    { name: 'Элемент 1', active: true },
    { name: 'Элемент 2', active: false },
    { name: 'Элемент 3', active: true }
  ];
}
```

**Объяснение:**

- Здесь каждый элемент с `item.active = true` получает класс `active` и цвет фона `lightblue`. В противном случае — `lightgrey`.
- Директивы `ngClass` и `ngStyle` не конфликтуют и могут использоваться одновременно.

#### Практическое задание

После изучения теоретической части, давайте применим знания на практике:

1. Создайте компонент, в котором отображается список товаров. Каждый товар можно сделать "в наличии" или "нет на складе".
2. Используйте `ngClass` для применения классов в зависимости от статуса товара.
3. Примените `ngStyle` для изменения цвета фона товара в зависимости от его скидки (например, если скидка больше 20%, фон становится светло-зелёным).

При выполнении практического задания вы научитесь применять атрибутивные директивы в реальных ситуациях, что позволит вам легко и просто управлять стилями и классами в Angular-приложениях.

---

# Создание собственных директив: Разработка простой кастомной атрибутивной директивы.

# Неделя 1: Основы Angular  
## Создание собственных директив: Разработка простой кастомной атрибутивной директивы

На этой неделе мы погрузимся в одну из мощных возможностей Angular — директивы. Чтобы понять, что такое директивы, представьте, что у вас есть способность "придать" HTML-элементу какие-то особые способности, например, заставить текст в элементе мигать или менять цвет фона при наведении мышки. Angular позволяет разработчикам создавать свои собственные аналогичные инструменты — директивы.

### Что такое директива?

Директивы в Angular — это классы, которые добавляют дополнительное поведение HTML-элементам. В Angular существует три вида директив:

1. **Компоненты.** Это специфический вид директив, которые имеют свой шаблон. На самом деле, компоненты — это самая распространенная форма директив.
2. **Атрибутивные директивы.** Эти директивы изменяют внешний вид или поведение элемента. Например, `ngClass` или `ngStyle`.
3. **Структурные директивы.** Эти директивы изменяют структуру DOM, например, `ngIf`, `ngFor`.

Сегодня мы сосредоточимся на создании простой атрибутивной директивы.

### Создание собственной атрибутивной директивы

Теперь давайте создадим собственную атрибутивную директиву, которая будет изменять цвет текста элемента при наведении курсора мыши.

#### Шаг 1: Инициализация директивы

Для начала, нам нужно создать файл для нашей новой директивы. В командной строке, находясь в директории вашего проекта, выполните команду:

```bash
ng generate directive highlight
```

Эта команда создаст файл `highlight.directive.ts`, который будет содержать основу нашей директивы.

#### Шаг 2: Реализация логики

Теперь откройте файл `highlight.directive.ts`. Вы увидите автоматически созданный класс с именем `HighlightDirective`. Он уже содержит часть необходимого кода, включая декоратор `@Directive` и пустой конструктор.

Мы добавим немного кода, чтобы заставить текст элемента сменять цвет.

```typescript
import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  constructor(private el: ElementRef, private renderer: Renderer2) { }

  @HostListener('mouseenter') onMouseEnter() {
    this.changeColor('yellow');
  }

  @HostListener('mouseleave') onMouseLeave() {
    this.changeColor(null);
  }

  private changeColor(color: string) {
    this.renderer.setStyle(this.el.nativeElement, 'color', color);
  }
}
```

#### Пояснение коду

- **Декоратор @Directive:** он сообщает Angular, что это класс директивы. Селектор `[appHighlight]` означает, что мы можем применять директиву к любому HTML-элементу, добавив атрибут `appHighlight`.

- **ElementRef и Renderer2:** `ElementRef` предоставляет доступ к элементу DOM, а `Renderer2` позволяет безопасно его изменять.

- **HostListener:** это декоратор, который позволяет "подслушивать" события DOM на элементе, к которому применена директива. В нашем случае мы мониторим события `mouseenter` и `mouseleave`.

- **Методы onMouseEnter и onMouseLeave:** вызываются при наведении курсора на элемент и уходе с него, соответственно, изменяя цвет текста на желтый или возвращая его обратно к исходному.

#### Шаг 3: Применение директивы

Теперь, когда наша директива готова, давайте применим её на практике. Откройте любой компонент вашего приложения, например, `app.component.html`, и добавьте следующий код:

```html
<h1 appHighlight>Наведи на меня, чтобы увидеть магию цвета!</h1>
<p appHighlight>Эта директива делает текст желтым, когда ты наведен на него.</p>
```

### Подводим итоги

Вот и всё! Мы создали простую, но эффективную атрибутивную директиву, которая делает текст жёлтым при наведении курсора. Это работает как полезное напоминание, что интеграция JavaScript-логики в Angular часто оказывается проще и ближе к "естественному" проектированию, чем кажется на первый взгляд. С новыми знаниями мы готовы применять директивы для улучшения вашего пользовательского интерфейса.

На следующем занятии мы изучим реактивные формы и освоим, как использовать их для создания интерактивных и отзывчивых интерфейсов.

---

# Встроенные пайпы: Использование пайпов для форматирования данных (date, number, currency).

# Неделя 1: Основы Angular

## Встроенные пайпы: Использование пайпов для форматирования данных (date, number, currency)

Одним из самых классных инструментов в Angular являются пайпы. Но что это такое? Представьте себе пайп как некий фильтр для данных. Он получает данные и изменяет их представление прямо на лету, чтобы показать пользователю в более удобной форме. Например, вы можете отобразить дату в читабельном формате, округлить число или добавить ему валютный символ.

Начнем с нескольких встроенных пайпов, которые чаще всего используются: `date`, `number` и `currency`.

### Пайп `date`

Этот пайп помогает форматировать даты. Например, если у вас есть сложное ISO-представление даты, и вы хотите показать её в красивом виде, то `date` пайп здесь — ваш лучший помощник.

```html
<!-- Пример использования пайпа date -->
<p>Сегодняшняя дата: {{ today | date }}</p>
<p>Форматирование с помощью шаблона: {{ today | date:'fullDate' }}</p>
<p>Кастомное форматирование: {{ today | date:'dd.MM.yyyy' }}</p>
```

**Объяснение:** 

- `{{ today | date }}`: Показывает стандартный, удобочитаемый формат даты.
- `{{ today | date:'fullDate' }}`: Использует предопределённый формат `fullDate`, который выводит дату с указанием дня недели.
- `{{ today | date:'dd.MM.yyyy' }}`: Кастомное форматирование, где вы сами задаёте, как именно должна выглядеть дата — в данном случае, день.месяц.год.

### Пайп `number`

Этот пайп позволяет форматировать числовые значения, добавляя разделители для тысяч и округляя числа, если это необходимо.

```html
<!-- Пример использования пайпа number -->
<p>Число с разделителями: {{ largeNumber | number }}</p>
<p>Округленное число: {{ largeNumber | number:'1.0-0' }}</p>
```

**Объяснение:**

- `{{ largeNumber | number }}`: Форматирует число с разделителями, чтобы его было проще читать.
- `{{ largeNumber | number:'1.0-0' }}`: Округляет число до целых. Здесь `'1.0-0'` задает минимальное и максимальное количество дробных цифр, что на практике означает округление до целого числа.

### Пайп `currency`

Этот пайп форматирует числа, добавляя символ валюты, что особенно удобно, когда вы показываете пользователю цены или другие финансовые данные.

```html
<!-- Пример использования пайпа currency -->
<p>Цена в долларах: {{ price | currency:'USD':true }}</p>
<p>Цена в евро: {{ price | currency:'EUR':'symbol':'1.2-2' }}</p>
```

**Объяснение:**

- `{{ price | currency:'USD':true }}`: Добавляет символ доллара перед суммой.
- `{{ price | currency:'EUR':'symbol':'1.2-2' }}`: Показывает цену в евро, с округлением числа до двух знаков после запятой.

### Практическое задание

Теперь, когда вы узнали о пайпах, давайте попробуем их в коде.

1. Создайте компонент `product-list`, где перечислите товары с датой добавления, числом штук на складе и ценой.
2. Используйте пайпы `date`, `number`, и `currency` для форматирования соответствующих значений.

```html
<!-- product-list.component.html -->
<div *ngFor="let product of products">
  <h2>{{ product.name }}</h2>
  <p>Добавлен: {{ product.addedDate | date:'fullDate' }}</p>
  <p>На складе: {{ product.stock | number }}</p>
  <p>Цена: {{ product.price | currency:'USD':true }}</p>
</div>
```

```typescript
// product-list.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-product-list',
  templateUrl: './product-list.component.html',
  styleUrls: ['./product-list.component.css']
})
export class ProductListComponent {
  products = [
    { name: 'Чайник', addedDate: new Date(), stock: 2345, price: 23.99 },
    { name: 'Тостер', addedDate: new Date(), stock: 128, price: 15.49 },
    { name: 'Миксер', addedDate: new Date(), stock: 563, price: 45.99 }
  ];
}
```

### Подводя итог

Пайпы в Angular — это шикарный инструмент для улучшения визуального представления данных в приложении, и их использование экономит время на написание кода вручную. Попробуйте поэкспериментировать с различными форматами в пайпах и обнаружите, насколько они могут улучшить оформление вашего приложения.

---

# Создание собственных пайпов: Реализация кастомного пайпа

# Неделя 1: Основы Angular

## Создание собственных пайпов: Реализация кастомного пайпа

На этой неделе мы продолжим изучение основ Angular, и сегодня погрузимся в увлекательный мир пайпов. Пайпы – это замечательный способ трансформировать данные прямо в шаблоне, упрощая их отображение. Уже знакомы с некоторыми встроенными пайпами, такими как `DatePipe` или `CurrencyPipe`. Но что делать, если нужна особая трансформация, которой нет по умолчанию? Конечно же, создать собственный кастомный пайп!

### Что такое пайпы?

Прежде чем перейти к созданию, давайте поговорим о том, чем вообще является пайп. Пайп в Angular – это, по сути, простая функция, которую можно использовать в шаблонах для изменения отображаемых данных. Они работают как фильтр в конвейере: получают некую исходную информацию, "обрабатывают" её и выдают в изменённом виде. Например, перевод строки в заглавные буквы или форматирование чисел.

### Как создать свой пайп?

1. **Создаём файл пайпа.** Angular CLI делает это легко! Используем команду:

   ```shell
   ng generate pipe названиеПайпа
   ```

   Например, создадим пайп, который будет конвертировать текст в ломаный (Leet Speak). Вводим:

   ```shell
   ng generate pipe leet
   ```

   Эта команда создаст два файла: `leet.pipe.ts` и `leet.pipe.spec.ts`. Первый содержит код нашего пайпа, второй пригодится для тестирования.

2. **Изменяем файл пайпа.** Вот базовый код, который Angular генерирует для нас:

   ```typescript
   import { Pipe, PipeTransform } from '@angular/core';

   @Pipe({
     name: 'leet'
   })
   export class LeetPipe implements PipeTransform {

     transform(value: string, ...args: any[]): string {
       // Здесь происходит магия
       return value;
     }

   }
   ```

   Мы видим, что пайп – это обыкновенный класс с методом `transform()`. Этот метод будет изменять данные.

3. **Реализация логики преобразования.**

   Давайте преобразуем строку в ломаный текст. Заменим буквы на их "л — аналоги":

   ```typescript
   export class LeetPipe implements PipeTransform {
     
     transform(value: string): string {
       let leetMapping: { [key: string]: string } = {
         'a': '4', 'e': '3', 'l': '1', 'o': '0', 't': '7'
       };

       return value
         .toLowerCase()
         .split('')
         .map(char => leetMapping[char] || char)
         .join('');
     }

   }
   ```

   **Что случилось в коде?** 
   - Создали объект `leetMapping`, где каждая буква соответствует своему "ломаному" символу.
   - Привели строку к нижнему регистру (это делается для единообразия).
   - Разбили строку на массив символов.
   - Заменили каждую букву, используя `leetMapping`, или оставили символ без изменений, если его нет в нашем "словарике".
   - Соединили всё обратно в строку.

4. **Использование пайпа в шаблоне.** Теперь, когда пайп готов, можем протестировать его в любом компоненте:

   ```html
   <p>Оригинальный текст: Angular Rocks!</p>
   <p>Ломаный текст: {{ 'Angular Rocks!' | leet }}</p>
   ```

   **Что он сделает?** Пайп `leet` преобразует строку "Angular Rocks!" в нечто вроде "4ngu14r R0ck5".

### Реальный пример использования

Представим, что работаем над проектом по ведению задач, и нужна возможность отображать приоритет задач в определённом визуальном формате. У нас есть список задач, и мы хотим отображать их приоритеты с использованием пайпа.

Предположим, что есть три уровня приоритета: низкий, средний и высокий, и мы хотим отображать их в виде цветных кружочков.

Создадим пайп `priority`, чтобы делать такую трансформацию:

```typescript
export class PriorityPipe implements PipeTransform {

  transform(value: string): string {
    const priorityMapping: { [key: string]: string } = {
      'low': '🟢', 'medium': '🟡', 'high': '🔴'
    };

    return priorityMapping[value.toLowerCase()] || value;
  }

}
```

Использование в компоненте может выглядеть так:

```html
<ul>
  <li *ngFor="let task of tasks">
    {{ task.name }} - Приоритет: {{ task.priority | priority }}
  </li>
</ul>
```

Где `tasks` – это массив объектов с именем и приоритетом каждой задачи. Теперь в вашем приложении приоритеты задач будут отображаться в виде цветных кружков: зелёный для низкого, жёлтый для среднего и красный для высокого.

### Итоги

Разработка кастомных пайпов – это действительно увлекательный процесс, который позволяет визуально изменить данные в вашем приложении без изменения бизнес-логики. Создавать пайпы можно для любых нужд: обработки строк, форматирования дат и многого другого. Они делают код чище и облегчают поддержку приложения.

На следующем занятии продолжим наше изучение Angular и углубим знания с помощью новых практических примеров!

---

# Чистые и нечистые пайпы: Оптимизация пайпов для производительности.

# Неделя 1: Основы Angular

## Чистые и нечистые пайпы: Оптимизация пайпов для производительности

### Введение в пайпы

Перед тем как углубиться в детали, давайте разберём, что же такое пайпы в Angular. Можно сказать, что пайпы - это своего рода "фильтры", которые позволяют изменять вид данных в шаблонах компонентов. Например, вы можете преобразовать дату в человеко-читаемый формат или округлить число до нужного количества знаков.

Пайпы делают наш код более чистым и читаемым. Представьте, что вместо сложной логики преобразования данных, вы просто используете небольшой оператор в шаблоне, например, `| date` или `| currency`.

### Чистые и нечистые пайпы: в чём разница?

Когда речь идёт о производительности пайпов, важно понимать разницу между чистыми и нечистыми пайпами.

#### Чистые пайпы

Чистые пайпы рассматриваются как функции, которые возвращают один и тот же результат, если их входные данные не изменились. Они оптимизированы для производительности и перерасчитываются Angular только тогда, когда изменяются входные данные. Чистые пайпы идеально подходят в ситуациях, когда нет необходимости в постоянной обработке данных без изменения.

### Пример чистого пайпа

```typescript
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'customUpperCase',
  pure: true // по умолчанию пайп чистый
})
export class CustomUpperCasePipe implements PipeTransform {
  transform(value: string): string {
    console.log('Чистый пайп выполняется');
    return value.toUpperCase();
  }
}
```

В этом примере `CustomUpperCasePipe` преобразует строку в верхний регистр. Поскольку этот пайп чистый, он будет вызываться только в том случае, если исходное значение изменится. Это значительно сокращает количество ненужных операций.

#### Нечистые пайпы

Нечистые пайпы не столь эффективны с точки зрения производительности, потому что они выполняются Angular при каждом цикле обнаружения изменений. Это может заметно снизить производительность приложения, если пайп используется внутри часто обновляемых компонентов.

### Пример нечистого пайпа

```typescript
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'impureSortedList',
  pure: false // делаем пайп нечистым
})
export class ImpureSortedListPipe implements PipeTransform {
  transform(value: number[]): number[] {
    console.log('Нечистый пайп выполняется');
    return value.sort((a, b) => a - b);
  }
}
```

В этом примере `ImpureSortedListPipe` сортирует массив чисел. Заметьте, что `pure: false` делает пайп нечистым, и он будет вызываться на каждом цикле обнаружения изменений. Это может быть полезно, если вы хотите, чтобы изменения происходили в реальном времени, но с осторожностью, так как может повлиять на производительность.

### Когда использовать чистые и нечистые пайпы

- **Используйте чистые пайпы**, когда вы можете гарантировать, что исходные данные не меняются часто и не требуют постоянных проверок.
  
- **Нечистые пайпы** полезны в ситуациях, когда данные изменяются динамически и результат должен быть актуальным для каждого изменения. Однако старайтесь избегать их использования в приложениях с высоким количеством обновлений данных.

### Заключение

Понимание чистых и нечистых пайпов поможет вам оптимизировать ваше приложение Angular. Используйте эту мощь с умом, чтобы создать быстродействующие, отзывчивые приложения. Специалист, который может объяснить разницу между этими пайпами и понять, когда они подходят, уже на шаг впереди в подготовке к собеседованию. Следующий шаг — интеграция этих знаний в реальные задачи. Удачи в практической работе с этими концепциями!

---

# Основы RxJS: Разница между Observable и Promise, примеры использования Subject и BehaviorSubject.

### Неделя 1: Основы Angular

#### Основы RxJS: Разница между Observable и Promise, примеры использования Subject и BehaviorSubject

На этой неделе мы окунемся в мир реактивного программирования на основе библиотеки RxJS, которая является одним из ключевых компонентов Angular. Сегодня мы сосредоточимся на двух основных понятиях: **Observable** и **Promise**, а также разберем, что такое **Subject** и **BehaviorSubject**.

#### Promise против Observable

Когда мы работаем с асинхронными данными в JavaScript, часто используем Promises. Представьте, что Promise — это как пригласительный билет на существующее событие. Вы либо получаете доступ к этому событию (успех), либо нет (ошибка).

```javascript
// Пример использования Promise
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Promise выполнен!');
  }, 1000);
});

promise.then(result => console.log(result)); // Вывод: 'Promise выполнен!'
```

***Особенности Promise:***
- Одноразовая операция. Как только Promise переходит в состояние "успешно" или "ошибка", его значение остаётся неизменным.
- Позволяют обрабатывать только одно значение или ошибку.

Теперь представьте себе **Observable** как поток событий или поток данных. Они могли бы быть чем-то вроде реки, где вы можете опустить ведро в воду и получить несколько значений.

```javascript
// Пример использования Observable
import { Observable } from 'rxjs';

const observable = new Observable(subscriber => {
  subscriber.next('Первое значение');
  subscriber.next('Второе значение');
  
  setTimeout(() => {
    subscriber.next('Третье значение');
    subscriber.complete();
  }, 1000);
});

observable.subscribe({
  next(x) { console.log('Получено значение: ' + x); },
  complete() { console.log('Поток завершен'); }
});

// Вывод:
// 'Получено значение: Первое значение'
// 'Получено значение: Второе значение'
// 'Получено значение: Третье значение'
// 'Поток завершен'
```

***Особенности Observable:***
- Могут выдавать несколько значений. Это поток данных со временем.
- Поток данных может быть брошен, когда подписчик больше не интересуется им.
- Можно отменить подписку, чтобы прекратить получение значений.

#### Использование Subject и BehaviorSubject

Теперь, когда мы немного разобрались в том, что такое Observable, давайте рассмотрим что-то более мощное — **Subject**. Он позволяет нам быть и наблюдателем, и поставщиком данных одновременно.

##### Subject

Subject — это особый тип Observable, который позволяет активным образом "излучать" данные. Это как радиостанция: она может вещать данные (добросовестно передавать сообщения), а когда вам интересно — вы включаете свой приемник и начинаете слушать.

```javascript
import { Subject } from 'rxjs';

const subject = new Subject();

subject.subscribe(data => console.log('Подписчик 1:', data));
subject.subscribe(data => console.log('Подписчик 2:', data));

subject.next('Эй, ты тут?');
// Вывод:
// 'Подписчик 1: Эй, ты тут?'
// 'Подписчик 2: Эй, ты тут?'
```

Как видите, когда мы отправляем данные, все подключенные подписчики получают их.

##### BehaviorSubject

BehaviorSubject запоминает своё последнее значение и отправляет его каждому новому подписчику. Представьте себе это как радио, которое продолжает воспроизводить последнюю песню до тех пор, пока не начнётся новая мелодия.

```javascript
import { BehaviorSubject } from 'rxjs';

const behaviorSubject = new BehaviorSubject('Начальное значение');

behaviorSubject.subscribe(data => console.log('Первый подписчик:', data));

behaviorSubject.next('Новое значение');

behaviorSubject.subscribe(data => console.log('Второй подписчик:', data));

behaviorSubject.next('Ещё одно новое значение');

// Вывод:
// 'Первый подписчик: Начальное значение'
// 'Первый подписчик: Новое значение'
// 'Второй подписчик: Новое значение'
// 'Первый подписчик: Ещё одно новое значение'
// 'Второй подписчик: Ещё одно новое значение'
```

Как вы могли заметить, второй подписчик при подключении получил не только "Ещё одно новое значение", но и последнее состояние до него: "Новое значение".

#### Когда использовать что?

- **Promise** — когда нужно управлять одной успешной или ошибочной операцией, и нам не важно, если смотрящий пропустит какие-то значения в истории.
- **Observable** — когда нам необходимо работать с потоком данных и мы хотим более гибко управлять временем жизни подписок.
- **Subject** — когда мы хотим излучать данные для множественных получателей.
- **BehaviorSubject** — когда актуально последнее состояние и мы хотим, чтобы новые подписчики сразу его получали.

С практикой, понимание различий и правильное использование этих инструментов научит вас эффективно работать с асинхронными операциями в Angular. В следующем уроке мы изучим, как это применять в более сложных сценариях и обсудим операторы RxJS для трансформации данных.

---

# Отписка через takeUntil/takeUntilDestroyed, startWith, from, of, debounceTime, distinctUntilChanged, share, shareReplay

### Неделя 1: Основы Angular

#### Отписка через takeUntil/takeUntilDestroyed, startWith, from, of, debounceTime, distinctUntilChanged, share, shareReplay

На прошлых занятиях мы познакомились с основами Angular, такими как компоненты, директивы и привязка данных. Теперь пришло время углубиться в работу с потоками данных в Angular с помощью библиотеки RxJS. Понимание этих концепций—важный шаг на пути к освоению Angular.

##### Сначала о subscribe() и отписках

Когда мы работаем с потоками данных в Angular, часто приходится использовать механизм подписки через метод `subscribe()`. Но стоит помнить, что неотписанные подписки могут приводить к утечкам памяти, особенно когда мы переходим на другие страницы или компоненты в нашем приложении. Чтобы предотвратить подобные ситуации, давайте рассмотрим, как мы можем грамотно управлять подписками с помощью takeUntil и takeUntilDestroyed.

##### Использование takeUntil и takeUntilDestroyed

`takeUntil` и `takeUntilDestroyed` используются для управляемого завершения подписок. С их помощью мы можем автоматически завершать подписки, избегая утечек памяти.

**Пример с takeUntil:**

```typescript
import { Component, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Component({
  selector: 'app-example',
  template: `<p>Посмотрите в консоль!</p>`
})
export class ExampleComponent implements OnDestroy {
  private destroy$ = new Subject<void>();

  constructor() {
    someObservable$
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => console.log(data));
  }

  ngOnDestroy() {
    this.destroy$.next(); // Отправляем сигнал завершения подписки
    this.destroy$.complete(); // Завершаем Subject
  }
}
```

**Объяснение:**

- `this.destroy$` — это специальный Subject, который мы используем как «сигнал» для завершения подписки.
- `takeUntil(this.destroy$)` — оператор, который завершает подписку, когда Subject посылает сигнал.

**Пример с takeUntilDestroyed:**

Этот оператор должен быть импортирован из вспомогательной библиотеки (например, @angular/core/rxjs-interop) и делает то же самое, что и описано выше, но без необходимости вручную управлять Subject.

```typescript
import { Component } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-example',
  template: `<p>Посмотрите в консоль!</p>`
})
export class ExampleComponent {
  constructor() {
    someObservable$
      .pipe(takeUntilDestroyed(this))
      .subscribe(data => console.log(data));
  }
}
```

##### Использование startWith

`startWith` позволяет определить начальное значение для потока данных, прежде чем он начнет эмитировать реальные данные.

**Пример:**

```typescript
import { of } from 'rxjs';
import { startWith } from 'rxjs/operators';

const numbers$ = of(2, 3, 4);
numbers$
  .pipe(startWith(1))
  .subscribe(value => console.log(value)); // Вывод: 1, 2, 3, 4
```

**Объяснение:**

- Здесь мы используем оператор `startWith` для добавления значения `1` в поток перед эмиссиями `2`, `3`, и `4`.

##### Использование from и of

`from` и `of` — это методы создания потоков данных. 

- `from` преобразует массив или объект с итератором в поток.
- `of` создает поток из перечисленных значений.

**Пример работы `from`:**

```typescript
import { from } from 'rxjs';

const array = [10, 20, 30];
const result$ = from(array);
result$.subscribe(value => console.log(value)); // Вывод: 10, 20, 30
```

**Пример работы `of`:**

```typescript
import { of } from 'rxjs';

const result$ = of('Angular', 'RxJS', 'Components');
result$.subscribe(value => console.log(value)); // Вывод: Angular, RxJS, Components
```

##### Использование debounceTime и distinctUntilChanged

Эти операторы часто используются в сценариях, связанных с обработкой ввода пользователем, чтобы оптимизировать частоту обновления данных.

- `debounceTime` — откладывает эмиссию значений.
- `distinctUntilChanged` — исключает последовательные повторяющиеся значения.

**Пример:**

```typescript
import { Component } from '@angular/core';
import { FormControl } from '@angular/forms';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

@Component({
  selector: 'app-search',
  template: `<input [formControl]="searchControl" placeholder="Введите текст" />`
})
export class SearchComponent {
  searchControl = new FormControl();

  constructor() {
    this.searchControl.valueChanges
      .pipe(
        debounceTime(300),
        distinctUntilChanged()
      )
      .subscribe(value => console.log(value));
  }
}
```

**Объяснение:**

- `debounceTime(300)` задерживает эмиссию значений на 300 миллисекунд после последнего введенного символа.
- `distinctUntilChanged()` предотвращает срабатывание подписки на одинаковые подряд идущие значения.

##### Использование share и shareReplay

Эти операторы полезны, когда необходимо разделить работу подписки между несколькими подписчиками.

- `share` — делится одной подпиской между несколькими подписчиками.
- `shareReplay` — кеширует значение и делится им с подпиской, включая новых подписчиков.

**Пример:**

```typescript
import { interval } from 'rxjs';
import { shareReplay, take, tap } from 'rxjs/operators';

const source$ = interval(1000).pipe(take(3), tap(console.log), shareReplay(1));

source$.subscribe(val => console.log(`Подписка 1: ${val}`));
setTimeout(() => {
  source$.subscribe(val => console.log(`Подписка 2: ${val}`));
}, 1500);
```

**Объяснение:**

- `shareReplay(1)` позволяет повторно использовать последние эмитированные значения для новых подписчиков.
- `tap(console.log)` демонстрирует, что только одна подписка используется для потока.

Со всеми этими инструментами и примерами вы отлично подготовлены к эффективной работе с потоками данных в Angular. Теперь, попрактиковавшись, сможете уверенно использовать их в своем коде.

---

# RxJS в компонентах: Интеграция Observable в компоненты через async pipe.

# Неделя 1: Основы Angular
## RxJS в компонентах: Интеграция Observable в компоненты через async pipe

В этой части курса мы узнаем, как использовать удивительную библиотеку RxJS вместе с Angular, чтобы сделать наши компоненты более "реактивными". Даже если вы никогда раньше не сталкивались с RxJS, не переживайте, я всё объясню на пальцах и с примером кода!

### Что такое Observable?

Observable — это что-то вроде "волшебного потока данных". Представьте себе, что у вас есть смарт-термометр, и вы хотите знать его показания каждую секунду. Вместо того, чтобы постоянно беспокоиться о том, как их получать, вы можете подписаться на "поток" данных от этого термометра, и всякий раз, когда температура изменится, вы будете об этом знать.

### Как работает async pipe?

В Angular есть специальный инструмент — async pipe, который упрощает работу с Observable. Если вы используете Observable в своем компоненте, вам не обязательно вручную подписываться и отписываться от него — async pipe сделает это за вас.

Теперь давайте окунемся в практику и посмотрим, как это всё реализовать в коде.

### Пример: поток данных о погоде

Представим, что мы разрабатываем простой Angular компонент, который показывает текущую погоду. Мы будем использовать Observable для имитации потока данных о погоде.

1. **Создадим Observable:**

В реальном мире это может быть HTTP-запрос к серверу, но мы для простоты создадим фейковый поток данных.

```typescript
import { Component } from '@angular/core';
import { Observable, interval } from 'rxjs';
import { map } from 'rxjs/operators';

@Component({
  selector: 'app-weather',
  template: `
    <div>
      <h2>Текущая температура:</h2>
      <p>{{ temperature$ | async }}°C</p>
    </div>
  `,
})
export class WeatherComponent {
  temperature$: Observable<number>;

  constructor() {
    // Генерируем новое значение температуры каждую секунду
    this.temperature$ = interval(1000).pipe(
      map(() => Math.floor(Math.random() * 30) + 1) // случайная температура от 1 до 30
    );
  }
}
```

2. **Объяснение кода:**

   - **interval(1000):** Эта функция создает поток, который выдает новое число каждую секунду.
   
   - **pipe и map:** Используя эти операторы, мы преобразуем выданные числа в случайные температуры (например, от 1°C до 30°C).

   - **temperature$:** Это переменная нашего компонента, содержащая Observable температуры. 

   - **template:** В шаблоне мы связываем значение Observable с элементом `<p>` через `{{ temperature$ | async }}`. async pipe автоматически подписывается на Observable и обновляет интерфейс при каждом изменении значения.

### Почему это круто?

Использование Observable и async pipe позволяет легко управлять данными, автоматически обновлять интерфейс, а также освобождает нас от необходимости вручную отписываться от потоков. Это очень полезно для предотвращения утечек памяти!

### Резюме

Наш компонент теперь может "слушать" непрерывный поток данных. Async pipe берет на себя всю грязную работу по управлению потоками, а нам остаётся только написать чистый и понятный код.

Итак, в этой теме мы изучили, как интегрировать Observable в Angular компоненты с помощью async pipe. В следующий раз мы продолжим углубляться в возможности Angular и RxJS и рассмотрим более сложные сценарии использования.

---

# Разница холодного и горячего потока, как из одного сделать другой и зачем

## Неделя 1: Основы Angular

### Разница между холодным и горячим потоком, как из одного сделать другой и зачем

В Angular, как и в других фреймворках, ассинхронная работа с данными и событиями является одной из самых важных и сложных задач. Для эффективной работы с потоками данных используются "холодные" и "горячие" потоки. Давайте подробно разберем, в чем их различие и каким образом вы можете их использовать в ваших приложениях.

#### Холодные потоки

**Определение:** Холодный поток — это поток данных, который начинает генерировать значения только тогда, когда на него подписывается наблюдатель. Каждый новый подписчик получает свои собственные данные, из этого следует, что каждый подписчик видит поток так, как будто он происходит с самого начала.

**Пример:** Представьте себе кран с водой. Пока вы его не откроете, вода не будет течь. Как только вы его откроете, вы получите свежую воду, и каждый раз вода будет для вас новой и отдельной.

**Код:**

```typescript
import { Observable } from 'rxjs';

// создаём холодный поток
const coldObservable = new Observable((observer) => {
  console.log('Observable создан');
  observer.next(Math.random()); // случайное число для каждого подписчика
});

coldObservable.subscribe((value) => console.log(`Подписчик 1: ${value}`));
coldObservable.subscribe((value) => console.log(`Подписчик 2: ${value}`));
```

**Объяснение:** Когда каждый подписчик подписывается на `coldObservable`, он выдает новое случайное число. Вы увидите в консоли два разных случайных числа для каждого подписчика.

#### Горячие потоки

**Определение:** Горячие потоки начинают генерировать данные независимо от наличия подписчиков. Все подписчики получают значения из одного и того же потока.

**Пример:** Представьте себе ток-шоу по телевидению. Шоу идет независимо от того, смотрите вы его или нет. Если вы подключитесь позже, вы не увидите все шоу с начала, вы просто войдете в него в тот момент, когда вы присоединились.

**Код:**

```typescript
import { Subject } from 'rxjs';

// создаём горячий поток используя Subject
const hotObservable = new Subject<number>();

hotObservable.subscribe((value) => console.log(`Подписчик 1: ${value}`));

hotObservable.next(Math.random()); // подписчик получит это значение

hotObservable.subscribe((value) => console.log(`Подписчик 2: ${value}`));

hotObservable.next(Math.random()); // оба подписчика получат это значение
```

**Объяснение:** `Subject` используется для создания горячего потока. Второй подписчик не получит первое значение, так как оно было отправлено до того, как он подписался. Оба подписчика получат второе значение потока.

### Как из холодного потока сделать горячий и зачем?

Иногда вам нужно преобразовать холодный поток в горячий, чтобы уменьшить расход ресурсов или обеспечить общее состояние данных для всех подписчиков. 

Чтобы сделать холодный поток горячим, мы можем использовать `share()` оператор или `publish()` и `connect()`. 

**Код:**

```typescript
import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';

const coldObservable = new Observable((observer) => {
  console.log('Запуск источника данных');
  observer.next(Math.random());
});

const hotObservableShared = coldObservable.pipe(share());

hotObservableShared.subscribe((value) => console.log(`Подписчик 1: ${value}`));
hotObservableShared.subscribe((value) => console.log(`Подписчик 2: ${value}`));
```

**Объяснение:** Оператор `share()` делает холодный поток горячим, распространяя одно и то же значение на всех подписчиков. Теперь, подписавшись на `hotObservableShared`, все подписчики получают одно и то же значение, и источник запускается только один раз.

### Заключение

Понимание различий между холодными и горячими потоками поможет вам использовать Angular более эффективно, создавая более производительные и предсказуемые приложения. С практическими примерами, как выше, становится проще понять, когда и где использовать каждый тип потока в реальных сценариях.

---

# Основные функциональности: NgIf, NgFor, NgSwitch, NgClass, NgStyle.

### Основные функциональности: NgIf, NgFor, NgSwitch, NgClass, NgStyle

На этой неделе мы познакомимся с очень важными инструментами в Angular, которые помогают менять внешний вид вашего приложения в зависимости от данных и условий. Мы рассмотрим директивы: NgIf, NgFor, NgSwitch, NgClass и NgStyle. Давайте разберем их подробнее и посмотрим на использование каждого из них.

#### NgIf: условное отображение

Директива `NgIf` позволяет вам показывать или скрывать элементы на странице в зависимости от какого-либо условия.

**Пример:**

```html
<div *ngIf="isLoggedIn">
  <p>Добро пожаловать, пользователь!</p>
</div>
<div *ngIf="!isLoggedIn">
  <p>Пожалуйста, войдите в систему.</p>
</div>
```

**Объяснение:**

В этом примере `isLoggedIn` — это переменная, которая определяет, выполнен ли вход. Если `isLoggedIn` истинно, то показываем приветственное сообщение. Если ложно — предлагаем войти в систему.

#### NgFor: циклический вывод

Директива `NgFor` используется для отображения элемента несколько раз по списку данных вроде массива.

**Пример:**

```html
<ul>
  <li *ngFor="let item of items">{{ item }}</li>
</ul>
```

**Объяснение:**

Здесь мы создаем список `<ul>`, который заполняется `<li>` элементами для каждого элемента в массиве `items`. Переменная `item` представляет текущий элемент массива в каждой итерации.

#### NgSwitch: выбор отображения

`NgSwitch` делает выбор между несколькими вариантами отображения в зависимости от значения.

**Пример:**

```html
<div [ngSwitch]="color">
  <div *ngSwitchCase="'red'">Вы выбрали красный!</div>
  <div *ngSwitchCase="'green'">Вы выбрали зеленый!</div>
  <div *ngSwitchCase="'blue'">Вы выбрали синий!</div>
  <div *ngSwitchDefault>Пожалуйста, выберите цвет.</div>
</div>
```

**Объяснение:**

Здесь `color` — это переменная, определяющая выбранный цвет. В зависимости от значения этой переменной, показывается соответствующий блок `*ngSwitchCase`. Если ни один из случаев не подходит, будет отображен блок с `*ngSwitchDefault`.

#### NgClass: динамические CSS классы

С помощью `NgClass` можно динамически добавлять или удалять CSS классы в зависимости от условий.

**Пример:**

```html
<div [ngClass]="{ 'active': isActive, 'disabled': !isActive }">
  Этот элемент может быть активным или неактивным.
</div>
```

**Объяснение:**

В этом примере мы используем объект для `ngClass`, который добавляет класс `active`, если `isActive` истинно, и `disabled`, если `isActive` ложно.

#### NgStyle: динамические стили

Директива `NgStyle` позволяет вам динамически изменять стили элементов.

**Пример:**

```html
<div [ngStyle]="{ 'background-color': isActive ? 'green' : 'gray' }">
  Стиль этого элемента меняется в зависимости от состояния!
</div>
```

**Объяснение:**

Здесь в зависимости от значения `isActive`, `NgStyle` динамически меняет цвет фона на зеленый, если элемент активен, или серый, если неактивен.

### Подведем итоги

На этой неделе вы познакомились с мощными инструментами Angular, которые делают ваше приложение гибким и динамичным. Теперь вам не нужно бояться изменений в данных — с Angular вы сможете легко управлять представлением вашего приложения, создавая интуитивно понятный и динамичный интерфейс для пользователей.

В практической части вы можете поэкспериментировать с разными условиями и данными, чтобы закрепить свои знания. Попробуйте создать небольшой проект, в котором вы бы реализовали реальное приложение с использованием всех этих директив. Практика поможет вам чувствовать себя уверенно с этими мощными инструментами!

---

# Создание и использование компонентов: Структура компонентов, модульность, naming conventions.

# Неделя 1: Основы Angular

## Тема: Создание и использование компонентов

### Структура компонентов, модульность, naming conventions

Компоненты — это строительные блоки в Angular. Мы можем думать о них как о миниатюрных частях нашего приложения, которые ведут себя как независимые кусочки интерфейса. Каждый компонент отвечает за свой кусочек логики и презентации.

#### Что такое компонент?

Представьте себе игру с лего: у вас есть разные блоки, которые вы можете комбинировать, чтобы построить что-то удивительное. В Angular компоненты — это те самые блоки. 

Каждый компонент в Angular состоит из трех основных частей:

1. **HTML-шаблон** – структура представления компонента.
2. **CSS-стили** – внешний вид компонента.
3. **TypeScript-код** – логика работы компонента.

#### Создание компонента

Angular великолепно упрощает создание компонентов. С помощью Angular CLI (инструмент командной строки) мы можем создать новый компонент. Для этого вам достаточно запустить команду:

```bash
ng generate component имя-компонента
```

Это автоматически создаст структуру, необходимую для компонента со всеми файлами:

- `имя-компонента.component.ts` – файл с логикой на TypeScript.
- `имя-компонента.component.html` – HTML-шаблон.
- `имя-компонента.component.css` – файл со стилями.
- `имя-компонента.component.spec.ts` – файл для тестирования (на данном этапе можем его игнорировать).

#### Структура компонента 

Давайте детально разберемся с этим на примере небольшого компонента, который мы назовем `приветствие`.

##### HTML шаблон

```html
<!-- приветствие.component.html -->
<h1>{{ приветствие }}</h1>
```

Здесь у нас простой текст, который будет отображаться на экране. Обратите внимание на `{{ приветствие }}`. Это называется *интерполяцией*, и она позволяет нам отображать данные компонента в HTML. Мы скорее поговорим об этом позже.

##### TypeScript файл

```typescript
// приветствие.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-приветствие',
  templateUrl: './приветствие.component.html',
  styleUrls: ['./приветствие.component.css']
})
export class ПриветствиеComponent {
  приветствие: string = 'Добро пожаловать в Angular!';
}
```

В этом файле мы видим декоратор `@Component`, который предоставляет Angular информацию о компоненте. Он говорит, какое имя у компонента (`selector`), какой шаблон использовать (`templateUrl`), и где лежат стили (`styleUrls`). 

Обратите внимание на `приветствие: string = 'Добро пожаловать в Angular!';` — это переменная, которую мы используем в нашем шаблоне для динамического отображения текста.

##### CSS стили

```css
/* приветствие.component.css */
h1 {
  color: blue;
}
```

Этот файл отвечает за стили вашего компонента. Здесь мы просто сделали заголовок синим.

#### Модульность

Каждый компонент в Angular находится внутри модуля. Обычно компоненты группируются в модули по назначению. Один модуль может содержать декларирование нескольких компонентов.

Angular предоставляет файл `app.module.ts`, где зарегистрированы модули и компоненты приложения.

```typescript
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { ПриветствиеComponent } from './приветствие/приветствие.component';

@NgModule({
  declarations: [
    ПриветствиеComponent  // наш компонент зарегистрирован в модуле
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [ПриветствиеComponent]
})
export class AppModule { }
```

Здесь мы добавляем наш `ПриветствиеComponent` в `declarations`, что позволяет Angular распознавать и использовать его.

#### Naming Conventions 

В Angular принято использовать определенные правила именования с целью унификации и легкости понимания кода:

1. **Имена файлов:** все файлы компонента пишутся в формате 'имя-компонента.часть_файла', например, `приветствие.component.ts`.
2. **Имена классов:** класс компонента обычно называется с использованием CamelCase, например, `ПриветствиеComponent`.
3. **Selector:** имя следует имени компании или проекта, например, `app-приветствие`.

#### Вывод компонента в приложении

Чтобы использовать компонент, просто добавьте его `selector` в HTML-шаблон корневого компонента:

```html
<!-- app.component.html -->
<app-приветствие></app-приветствие>
```

Этот простой код загрузит и отобразит наш компонент в браузере.

На этом наше небольшое введение в создание и использование компонентов в Angular заканчивается. Далее мы изучим, как компоненты могут обмениваться данными друг с другом, и продолжим строить более сложные элементы интерфейса. А сейчас, поэкспериментируйте с вашим первым компонентом!

---

# Практическое использование: Примеры использования встроенных директив и пайпов.

# Неделя 1: Основы Angular

## Практическое использование: Примеры использования встроенных директив и пайпов

На этой неделе мы с вами познакомляемся с несколькими чудесными инструментами, которые делают Angular таким мощным и удобным фреймворком. Это директивы и пайпы. Не пугайтесь этих незнакомых слов! Сегодня мы узнаем, как они помогают нам создавать более гибкие и интерактивные приложения, и все это через изучение практических примеров.

### Встроенные директивы

Директивы в Angular — это специальные инструкции, которые мы можем добавить к элементам HTML для изменения их поведения или внешнего вида. Рассмотрим несколько самых популярных встроенных директив и как они могут быть полезны в реальной работе.

#### `*ngIf`

Представьте, что у вас есть светильник с кнопкой включения и выключения. Вот это примерно то, что делает директива `*ngIf`. Она позволяет "включать" или "выключать" элементы HTML в зависимости от определенного условия.

Пример использования `*ngIf`:

```html
<div *ngIf="isLoggedIn">
  <p>Добро пожаловать, дорогой пользователь!</p>
</div>

<button (click)="toggleLogin()">Войти/Выйти</button>
```

И логика в компоненте:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  isLoggedIn = false;

  toggleLogin() {
    this.isLoggedIn = !this.isLoggedIn;
  }
}
```

В этом примере мы показываем приветственное сообщение пользователю только в том случае, если он вошел в систему (`isLoggedIn` равен `true`). Кнопка позволяет нам менять состояние входа, показывая или пряча текст.

#### `*ngFor`

Теперь, скажем, у нас есть набор красок, и мы хотим показать их на странице. Для этого нам нужно не копировать и вставлять один и тот же код снова и снова, а воспользоваться директивой `*ngFor`, которая повторяет элемент для каждого объекта в наборе данных.

Пример использования `*ngFor`:

```html
<ul>
  <li *ngFor="let color of colorsList">{{ color }}</li>
</ul>
```

И компонент:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-colors',
  templateUrl: './colors.component.html'
})
export class ColorsComponent {
  colorsList = ['Красный', 'Зеленый', 'Синий', 'Желтый'];
}
```

С `*ngFor` мы проходим по массиву `colorsList` и создаем `<li>` для каждого цвета. Это значительно упрощает работу с повторяющимися элементами!

### Встроенные пайпы

Пайпы — это инструменты для преобразования данных перед их отображением. Они как фильтры, изменяющие вид данных без их фактического редактирования.

#### Date Pipe

Давайте посмотрим, как можно красиво отобразить дату с помощью пайпа:

Пример использования Date Pipe:

```html
<p>Сегодняшняя дата: {{ today | date:'fullDate' }}</p>
<p>Текущее время: {{ today | date:'shortTime' }}</p>
```

И в компоненте:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-date',
  templateUrl: './date.component.html'
})
export class DateComponent {
  today: number = Date.now();
}
```

Здесь мы используем `date` пайп, чтобы преобразовать текущую дату и время в более понятный формат.

#### Currency Pipe

Еще пример — отображение чисел, как денежных единиц:

Пример использования Currency Pipe:

```html
<p>Цена товара: {{ price | currency:'RUB':'symbol':'1.2-2' }}</p>
```

И в компоненте:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-price',
  templateUrl: './price.component.html'
})
export class PriceComponent {
  price = 199.99;
}
```

Здесь `currency` пайп преобразует число 199.99 в формат валюты, добавляя знак рубля и нужное количество десятичных знаков.

### Практическое задание

Попробуйте у себя добавить несколько элементов в список и переключать их видимость с помощью `*ngIf`. Затем форматируйте их с пайпами, чтобы создать список покупок с ценами, которые автоматически отображаются в формате валюты!

На следующей неделе мы углубимся в Angular компоненты и модули. Удачной практики, и до встречи во второй неделе!

---

# Шаблонные формы: Построение простых форм с использованием FormsModule, валидация.

## Неделя 1: Основы Angular

### Шаблонные формы: Построение простых форм с использованием FormsModule, валидация

Angular — это фреймворк для создания веб-приложений, и одна из его наиболее ценных возможностей — это работа с формами. В данной теме мы изучим "шаблонные формы". Это такой подход, который позволяет легко и быстро создавать формы, используя HTML и Angular-директивы. Звучит сложно? Давайте разберёмся!

#### FormsModule — наше волшебное зелье

Первым делом, нам нужно "сказать" нашему приложению, что мы хотим использовать Angular-директивы для работы с формами. Это делается с помощью **FormsModule**.

1. **Подключение FormsModule:**

   Если вы создаёте Angular-приложение, скорее всего, ваш модуль `AppModule` выглядит как-то так:

   ```typescript
   import { NgModule } from '@angular/core';
   import { BrowserModule } from '@angular/platform-browser';
   import { FormsModule } from '@angular/forms'; // Импортируем FormsModule

   import { AppComponent } from './app.component';

   @NgModule({
     declarations: [
       AppComponent
     ],
     imports: [
       BrowserModule,
       FormsModule // Добавляем его сюда
     ],
     providers: [],
     bootstrap: [AppComponent]
   })
   export class AppModule { }
   ```

   Добавив FormsModule в раздел `imports`, мы можем начинать использовать Angular-директивы в наших HTML-формах.

2. **Создание простой формы:**

   Допустим, мы хотим, чтобы пользователь ввёл свое имя и email. Вот как можно это сделать с помощью шаблонной формы:

   ```html
   <form #userForm="ngForm">
     <label for="name">Имя:</label>
     <input type="text" id="name" name="name" ngModel>
     
     <label for="email">Email:</label>
     <input type="email" id="email" name="email" ngModel>
     
     <button type="submit" [disabled]="!userForm.valid">Отправить</button>
   </form>
   ```

   **Что здесь происходит?**

   - **ngModel**: Эта директива связывает наш input с формой Angular. Она следит за изменениями и поддерживает валидацию.
   - **#userForm="ngForm"**: Мы даём нашей форме переменную `userForm`, чтобы Angular мог управлять её состоянием (например, валидна ли форма).
   - **[disabled]="!userForm.valid"**: Если форма не валидна, кнопка "Отправить" будет отключена. Это простой пример того, как Angular облегчает жизнь, заботясь о валидации наших форм.

3. **Добавление валидации:**

   Angular поддерживает HTML-атрибуты валидации. Давайте их добавим:

   ```html
   <form #userForm="ngForm">
     <div>
       <label for="name">Имя:</label>
       <input type="text" id="name" name="name" ngModel required minlength="3">
       <div *ngIf="userForm.submitted && !userForm.controls['name']?.valid">
         Имя должно содержать минимум 3 символа!
       </div>
     </div>

     <div>
       <label for="email">Email:</label>
       <input type="email" id="email" name="email" ngModel required>
       <div *ngIf="userForm.submitted && !userForm.controls['email']?.valid">
         Пожалуйста, введите корректный email!
       </div>
     </div>

     <button type="submit" [disabled]="!userForm.valid">Отправить</button>
   </form>
   ```

   **Пояснения:**

   - **required**: Этот атрибут делает поле обязательным. Без него форма не будет считаться валидной.
   - **minlength="3"**: Минимальное количество символов для имени — 3.
   - **ngIf**: Это директива, которая позволяет показывать сообщения об ошибках только тогда, когда форма была отправлена, но не прошла валидацию.

4. **Обработка отправки формы:**

   Чтобы сделать форму полезной, нужно уметь обрабатывать её отправку:

   ```html
   <form #userForm="ngForm" (ngSubmit)="onSubmit(userForm)">
     <!-- поля формы (как в предыдущем примере) -->
   </form>
   ```

   ```typescript
   import { Component } from '@angular/core';

   @Component({
     selector: 'app-root',
     templateUrl: './app.component.html'
   })
   export class AppComponent {
     onSubmit(form: any): void {
       console.log('Форма была отправлена', form);
       console.log('Имя:', form.value.name);
       console.log('Email:', form.value.email);
     }
   }
   ```

   Теперь, когда форма будет отправлена, Angular вызовет метод `onSubmit`. Мы просто выводим данные формы в консоль, но вы можете делать с ними что угодно.

#### Заключение и полезные заметки

Работа с формами в Angular позволяет значительно упростить процесс их создания и валидации. Мы рассмотрели базовые принципы, но на самом деле, возможности Angular форм идут намного дальше! В следующих уроках мы будем углубляться в другие аспекты Angular, а пока — практикуйтесь с созданием шаблонных форм и попробуйте добавить свои собственные поля и правила валидации.

---

# Реактивные формы: Построение форм через FormBuilder, работа с FormGroup, FormControl.

### Неделя 1: Основы Angular

#### Реактивные формы: Построение форм через FormBuilder, работа с FormGroup, FormControl

Добро пожаловать в мир реактивных форм Angular! Сегодня мы разберемся, как можно легко и удобно создавать и управлять формами в этом фреймворке, используя такие мощные инструменты, как FormBuilder, FormGroup и FormControl. Начнем наше приключение и создадим нашу первую форму!

**Что такое реактивные формы?**

Реактивные формы (Reactive Forms) — это подход к созданию форм в Angular, который дает нам возможность управлять состоянием формы из TypeScript-кода. Преимущество реактивных форм в том, что они полностью "реактивны" — мы создаем модель формы в коде и Angular следит за изменениями, так что мы можем легко проверять, валидировать и реагировать на изменения данных.

### Первый пример: создание простой формы

Начнем с создания формы, которая будет собирать имя пользователя и его email.

1. **Установка ReactiveFormsModule**

   Для начала работы нужно убедиться, что `ReactiveFormsModule` подключен в нашем Angular приложении. Это делается в файле `app.module.ts`:

   ```typescript
   import { NgModule } from '@angular/core';
   import { BrowserModule } from '@angular/platform-browser';
   import { ReactiveFormsModule } from '@angular/forms';

   import { AppComponent } from './app.component';

   @NgModule({
     declarations: [AppComponent],
     imports: [BrowserModule, ReactiveFormsModule], // Добавляем ReactiveFormsModule
     providers: [],
     bootstrap: [AppComponent],
   })
   export class AppModule { }
   ```

2. **Создание компонента**

   Пусть наш компонент будет называться `UserFormComponent`. Создадим в нем форму.

   ```typescript
   import { Component } from '@angular/core';
   import { FormBuilder, FormGroup } from '@angular/forms';

   @Component({
     selector: 'app-user-form',
     template: `
       <form [formGroup]="userForm" (ngSubmit)="onSubmit()">
         <label for="name">Имя:</label>
         <input id="name" formControlName="name">
         
         <label for="email">Email:</label>
         <input id="email" formControlName="email">

         <button type="submit">Отправить</button>
       </form>
     `
   })
   export class UserFormComponent {
     userForm: FormGroup;

     constructor(private fb: FormBuilder) {
       this.userForm = this.fb.group({
         name: [''],  // Задаем начальное значение для имени
         email: ['']  // Задаем начальное значение для email
       });
     }

     onSubmit() {
       if (this.userForm.valid) {
         console.log('Форма отправлена - данные:', this.userForm.value);
       }
     }
   }
   ```

   #### Разбор кода:

   - **FormBuilder**: это сервис Angular, который упрощает создание форм. Используя `FormBuilder`, мы можем легко создавать группы форм и контролировать элементы формы без необходимости писать много кода.

   - **FormGroup**: это группа, которую мы формируем из отдельных элементов, называемых FormControl. В нашем примере `userForm` является FormGroup, содержащей два FormControl — `name` и `email`.

   - **FormControlName**: атрибут директивы, который связывает элемент в HTML с конкретным FormControl в FormGroup.

3. **Валидация формы**

   Теперь давайте добавим немного валидации. Для начала убедимся, что поля формы не могут быть пустыми.

   ```typescript
   import { Validators } from '@angular/forms'; // Импортируем Validators

   this.userForm = this.fb.group({
     name: ['', Validators.required],  // Добавляем валидацию для имени
     email: ['', [Validators.required, Validators.email]]  // Добавляем валидацию для email
   });
   ```

   - **Validators.required**: проверяет, что поле не пусто.
   - **Validators.email**: простой валидатор для проверки формата email.

4. **Отображение ошибок валидации**

   Попробуем отобразить ошибки на экране, если они существуют:

   ```html
   <form [formGroup]="userForm" (ngSubmit)="onSubmit()">
     <label for="name">Имя:</label>
     <input id="name" formControlName="name">
     <div *ngIf="userForm.get('name')?.invalid && userForm.get('name')?.touched">
       Пожалуйста, введите ваше имя.
     </div>

     <label for="email">Email:</label>
     <input id="email" formControlName="email">
     <div *ngIf="userForm.get('email')?.invalid && userForm.get('email')?.touched">
       Пожалуйста, введите корректный email адрес.
     </div>

     <button type="submit">Отправить</button>
   </form>
   ```

### Расширение наших возможностей

Теперь, когда у вас есть базовое представление о том, как работать с реактивными формами в Angular, давайте добавим больше фишек, чтобы сделать нашу форму еще более функциональной!

#### Управление состоянием

Кроме валидации, часто требуется управлять состоянием элементов формы. Например, вы можете захотеть отключить кнопку отправки формы, пока она не будет валидной:

```html
<button type="submit" [disabled]="userForm.invalid">Отправить</button>
```

#### Динамическое добавление полей

Иногда необходимо динамически добавлять элементы в форму. Например, пользователь может захотеть добавить дополнительные поля для ввода телефонных номеров. Для этого можно использовать `FormArray`, но это уже следующий шаг для исследования.

Создание форм может быть увлекательным путешествием, которое открывает перед вами множество возможностей для взаимодействия с пользователями, и реактивные формы Angular дают нам мощные инструменты для управления процессом. На следующем уроке мы продолжим изучение Angular, дополняя наши знания интересными и полезными фишками. 

Продолжаем наше изучение!

---

# Основные методы форм

# Неделя 1: Основы Angular
## Основные методы форм

Angular — это мощный инструмент для создания веб-приложений. Одной из ключевых частей любого приложения являются формы. Это те части вашего приложения, где пользователи вводят информацию, например, для регистрации на сайте или для входа в систему. Сегодня мы узнаем, как Angular может помочь нам с формами.

### Формы в Angular: что они из себя представляют?

В Angular есть два способа работы с формами: шаблонные формы (template-driven forms) и реактивные формы (reactive forms). Давайте разберемся, как использовать каждую из них.

### Шаблонные формы
Шаблонные формы проще в понимании, поскольку они полагаются больше на сам HTML. Они отлично подходят для простых случаев использования.

**Пример шаблонной формы:**

```html
<form #myForm="ngForm">
  <label for="name">Имя:</label>
  <input type="text" id="name" name="name" ngModel>
  
  <button type="submit" [disabled]="!myForm.valid">Отправить</button>
</form>
```

### Разбор примера:

1. **`<form #myForm="ngForm">`**: Этот элемент HTML является контейнером формы. Мы используем `#myForm` как локальную переменную, чтобы получить доступ к состоянию формы. `ngForm` — это директива, которая помогает Angular отслеживать форму.

2. **`ngModel`**: Эта директива используется на отдельных полях формы (например, input) для двустороннего связывания данных. Это значит, что если вы введете что-то в поле формы, переменная Angular автоматически обновится.

3. **`[disabled]="!myForm.valid"`**: Эта конструкция используется на кнопке отправки. Она станет активной только если вся форма валидна.

### Практическое задание:

Попробуйте создать форму, чтобы пользователь мог вводить не только имя, но и email-адрес. Используйте директиву `ngModel` для каждого поля, чтобы получить доступ к значению в компоненте.

### Реактивные формы
Реактивные формы дают больше контроля и отлично подходят для сложных проверок и динамичного взаимодействия.

**Пример реактивной формы:**

```typescript
// app.component.ts
import { Component } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  myReactiveForm = new FormGroup({
    name: new FormControl('', Validators.required),
    email: new FormControl('', [Validators.required, Validators.email])
  });

  onSubmit() {
    console.log(this.myReactiveForm.value);
  }
}
```

**HTML:**

```html
<form [formGroup]="myReactiveForm" (ngSubmit)="onSubmit()">
  <label for="name">Имя:</label>
  <input type="text" id="name" formControlName="name">

  <label for="email">Email:</label>
  <input type="email" id="email" formControlName="email">

  <button type="submit" [disabled]="myReactiveForm.invalid">Отправить</button>
</form>
```

### Разбор примера:

1. **FormGroup**: Это основа реактивной формы. Он сгруппирует несколько элементов управления, например, `FormControl`.

2. **FormControl**: Каждое поле формы управляется этим элементом. Мы можем передать ему значение по умолчанию и валидаторы.

3. **Validators**: Это встроенные функции проверки, которые убеждаются, что пользователь введет правильные данные.

### Практическое задание:

На основе приведенных примеров создайте собственную форму регистрации с полями `username`, `password` и `confirm password`. Добавьте валидаторы, чтобы пароли должны были совпадать.

### Заключение

Angular предоставляет множество удобных инструментов для работы с формами. Важно понимать разницу между шаблонными и реактивными подходами и уметь выбирать подходящий метод для вашей задачи. Теперь, когда вы познакомились с основами, вы можете приступать к более сложным сценариям и глубже изучать возможности Angular!

---

# CVA

# Неделя 1: Основы Angular

## CVA (Control Value Accessor)

Angular — это не просто инструмент для создания веб-приложений, это магический набор, который позволяет тебе создавать невероятно мощные и гибкие интерфейсы. Одним из таких инструментов является CVA или Control Value Accessor. Сегодня мы познакомимся с этой концепцией ближе и на практическом примере разберёмся, как она работает.

### Что такое CVA?

Представьте, что вы строите форму. Вы, как архитектор, решаете, какие поля в ней будут и как они будут взаимодействовать. Но что если одно из полей более сложное или кастомное, чем просто текстовое поле или переключатель? Здесь на сцену выходит CVA, который позволяет интегрировать в вашу форму пользовательские компоненты таким образом, что они выглядят и работают как родные.

### Зачем необходим CVA?

Angular предоставляет нам мощные инструменты для работы с формами, такие как `FormControl`, `FormGroup` и `FormArray`. Но когда дело доходит до пользовательских компонентов, которые должны работать с этими структурами форм, необходимо их интегрировать так, чтобы Angular мог управлять их состоянием и значениями. CVA — это тот самый интерфейс, который мы можем использовать для связывания наших кастомных компонент с Angular формами.

### Как это работает?

Давайте рассмотрим пример кастомного компонента ввода — цветного текстового поля, где пользователь может выбрать текст и подложку по цвету.

#### Шаг 1: Создание кастомного компонента

Начнём с создания простого компонента.

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-color-input',
  template: `
    <label>
      Text:
      <input [(ngModel)]="currentText" />
    </label>
    <label>
      Color:
      <input type="color" [(ngModel)]="currentColor" />
    </label>
    <div [style.backgroundColor]="currentColor">{{ currentText }}</div>
  `
})
export class ColorInputComponent {
  currentText = '';
  currentColor = '#ffffff';
}
```

#### Шаг 2: Реализация CVA в компоненте

Теперь, чтобы интегрировать наш компонент с формой Angular, необходимо реализовать `ControlValueAccessor`.

```typescript
import { Component, forwardRef } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Component({
  selector: 'app-color-input',
  template: `
    <label>
      Text:
      <input [(ngModel)]="currentText" (ngModelChange)="onInputChange()" />
    </label>
    <label>
      Color:
      <input type="color" [(ngModel)]="currentColor" (ngModelChange)="onInputChange()" />
    </label>
    <div [style.backgroundColor]="currentColor">{{ currentText }}</div>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => ColorInputComponent),
      multi: true
    }
  ]
})
export class ColorInputComponent implements ControlValueAccessor {
  currentText = '';
  currentColor = '#ffffff';

  private onChange: (value: any) => void = () => {};
  private onTouched: () => void = () => {};

  writeValue(value: any): void {
    this.currentText = value.text || '';
    this.currentColor = value.color || '#ffffff';
  }

  registerOnChange(fn: (value: any) => void): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    // Логика для обработки состояния "отключено"
  }

  onInputChange(): void {
    this.onChange({ text: this.currentText, color: this.currentColor });
  }
}
```

#### Объяснение кода

1. **writeValue**: Этот метод вызывается Angular, чтобы обновить состояние компонента, когда изменяется значение модели.

2. **registerOnChange**: Здесь мы регистрируем функцию, которая будет вызвана всякий раз, когда пользователь изменяет значение.

3. **registerOnTouched**: Позволяет Angular узнать, когда компонент был затронут пользователем.

4. **setDisabledState**: Позволяет Angular отключить наш компонент, когда это необходимо.

Мы используем `[(ngModel)]` для отслеживания изменений в наших полях, и вызываем метод `onInputChange`, чтобы обновить родительскую форму с использованием зарегистрированной функции `onChange`.

#### Шаг 3: Использование компонента в форме Angular

Теперь, когда мы реализовали CVA в нашем компоненте, давайте воспользуемся им в форме.

```typescript
import { Component } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';

@Component({
  selector: 'app-root',
  template: `
    <form [formGroup]="form" (ngSubmit)="onSubmit()">
      <app-color-input formControlName="colorText"></app-color-input>
      <button type="submit">Submit</button>
    </form>
  `
})
export class AppComponent {
  form: FormGroup;

  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      colorText: { text: '', color: '#ffffff' }
    });
  }

  onSubmit(): void {
    console.log(this.form.value);
  }
}
```

Вот и всё! Мы создали кастомный компонент с использованием CVA и интегрировали его в форму. Теперь он полностью взаимодействует с Angular формами, а его значение будет корректно считываться и отправляться, когда форма будет отправлена.

---

# Пользовательские валидаторы: Создание синхронных и асинхронных валидаторов.

# Неделя 1: Основы Angular
## Пользовательские валидаторы: Создание синхронных и асинхронных валидаторов

На данном этапе нашего курса мы уже познакомились с основами Angular, и самое время углубиться в одну из мощных возможностей фреймворка - создание пользовательских валидаторов. Валидаторы помогают нам убедиться, что пользователи вводят данные правильно. Например, когда вы заполняете форму в интернете и вводите адрес электронной почты, валидатор может проверить, чтобы вы не забыли поставить "@". 

### Синхронные валидаторы

**Что такое синхронный валидатор?**

Синхронный валидатор проверяет данные мгновенно, как только они вводятся в форму. Представьте себе эту проверку как область вокруг текстового поля, которая сразу же становится красной, если вы ввели что-то неверно.

#### Пример кода: Создание синхронного валидатора

Давайте создадим простой синхронный валидатор, который будет проверять, что имя пользователя содержит только буквы. Начнем с создания функции валидатора:

```typescript
import { AbstractControl, ValidationErrors } from '@angular/forms';

// Синхронный валидатор для проверки, что текст содержит только буквы
export function onlyLettersValidator(control: AbstractControl): ValidationErrors | null {
  const valid = /^[a-zA-Z]+$/.test(control.value);
  return valid ? null : { onlyLetters: true };
}
```
В этом коде мы используем регулярное выражение `/^[a-zA-Z]+$/`, которое проверяет, что в поле введены только буквы. Если введены другие символы, функция возвращает ошибку `{ onlyLetters: true }`, в противном случае — `null`.

Теперь давайте применим наш валидатор к полю ввода в форме:

```typescript
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { onlyLettersValidator } from './validators/only-letters.validator';

@Component({
  selector: 'app-root',
  template: `
    <form [formGroup]="form">
      <label for="username">Имя пользователя:</label>
      <input id="username" formControlName="username">
      <div *ngIf="form.get('username')?.hasError('onlyLetters')">
        Имя пользователя должно содержать только буквы!
      </div>
    </form>
  `
})
export class AppComponent {
  form: FormGroup;

  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      username: ['', [onlyLettersValidator]]
    });
  }
}
```

С помощью `FormBuilder` мы создаем `FormGroup`. При создании поля 'username' мы используем наш `onlyLettersValidator` как один из валидаторов.

### Асинхронные валидаторы

**Что такое асинхронный валидатор?**

Асинхронный валидатор используется для проверки, которая может занять время, например, при запросе к серверу. Давайте представим себе магазин, в котором ваша задача — убедиться, что товар станет доступным к покупке в будущем. 

#### Пример кода: Создание асинхронного валидатора

Давайте создадим асинхронный валидатор, который проверяет доступность имени пользователя, отправляя запрос на сервер. Поскольку у нас настоящего сервера нет, мы будем использовать `setTimeout`, чтобы симулировать задержку.

```typescript
import { AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { delay } from 'rxjs/operators';

// Асинхронный валидатор для проверки уникальности имени пользователя
export function uniqueUsernameValidator(control: AbstractControl): Observable<ValidationErrors | null> {
  // Симуляция запроса на сервер с задержкой
  const usernames = ['admin', 'user', 'test']; // Существующие имена пользователя
  return of(usernames.includes(control.value) ? { nonUniqueUsername: true } : null).pipe(
    delay(1000) // Задержка 1 секунда
  );
}
```

Мы создаем функцию, которая возвращает `Observable`. Она имитирует запрос к серверу, проверяя, не используется ли имя. Если имя занято, возвращается ошибка `{ nonUniqueUsername: true }`, в противном случае — `null`.

Теперь, давайте добавим этот валидатор в нашу форму:

```typescript
import { Component } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { onlyLettersValidator } from './validators/only-letters.validator';
import { uniqueUsernameValidator } from './validators/unique-username.validator';

@Component({
  selector: 'app-root',
  template: `
    <form [formGroup]="form">
      <label for="username">Имя пользователя:</label>
      <input id="username" formControlName="username">
      <div *ngIf="form.get('username')?.hasError('onlyLetters')">
        Имя пользователя должно содержать только буквы!
      </div>
      <div *ngIf="form.get('username')?.pending">
        Проверка доступности имени...
      </div>
      <div *ngIf="form.get('username')?.hasError('nonUniqueUsername')">
        Это имя пользователя уже занято!
      </div>
    </form>
  `
})
export class AppComponent {
  form: FormGroup;

  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      username: ['', [onlyLettersValidator], [uniqueUsernameValidator]]
    });
  }
}
```

В этом коде мы добавили `uniqueUsernameValidator` в список асинхронных валидаторов для поля 'username'. Мы также добавляем `*ngIf="form.get('username')?.pending"`, чтобы уведомить пользователя, что в данный момент происходит проверка.

### Заключение

Сегодня мы рассмотрели создание пользовательских валидаторов в Angular. Вы узнали, как создавать свои собственные валидаторы, как синхронные, так и асинхронные, и как применять их к формам. Теперь у вас есть инструменты, чтобы делать свои формы более интерактивными и надежными! На следующей неделе мы будем строить на этих знаниях, исследуя более сложные темы.

---

# Настройка маршрутов: Создание основных маршрутов, работа с параметрами.

### Неделя 1: Основы Angular

#### Настройка маршрутов: Создание основных маршрутов, работа с параметрами

Маршрутизация в Angular — это как GPS для вашего приложения. Она помогает направлять пользователей туда, где они должны находиться, только в нашем случае это не города и улицы, а страницы и компоненты вашего приложения.

Когда ваше приложение становится сложнее, вам нужно будет не просто показывать пользователю одну страницу. Мы хотим, чтобы пользователи могли перемещаться между разными частями вашего приложения, например, от домашней страницы к странице профиля и обратно. Для этого нам нужно настраивать маршруты. В Angular за это отвечает модуль `RouterModule`.

### Шаг 1: Подключаем маршрутизацию

Начнем с того, что убедимся — у нас есть все необходимые зависимости. Обычно, если вы создавали проект через Angular CLI, все необходимые модули уже подключены. Но для настроек маршрутизации ваш `app.module.ts` должен содержать следующее:

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { RouterModule, Routes } from '@angular/router';

import { AppComponent } from './app.component';
import { HomeComponent } from './home/home.component';
import { ProfileComponent } from './profile/profile.component';

const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'profile', component: ProfileComponent }
];

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    ProfileComponent
  ],
  imports: [
    BrowserModule,
    RouterModule.forRoot(routes)
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

Здесь мы делаем следующее:
- Импортируем `RouterModule` и `Routes` из пакета `@angular/router`.
- Создаем массив `routes`, в котором определяем, какой компонент должен быть загружен при посещении каждого пути (например, корневой путь `''` загружает `HomeComponent`).
- Применяем маршруты с помощью `RouterModule.forRoot(routes)`.

### Шаг 2: Добавляем маршруты в шаблон

Теперь, когда маршруты определены, мы должны научиться переключаться между ними. Для этого мы будем использовать директиву `<router-outlet>` в нашем основном шаблоне, чтобы показывать нужный компонент по данному маршруту.

```html
<!-- app.component.html -->
<nav>
  <a routerLink="/">Домой</a>
  <a routerLink="/profile">Профиль</a>
</nav>

<router-outlet></router-outlet>
```

В этом шаблоне мы делаем следующее:
- Используем `<a routerLink="/">Домой</a>` для переключения на домашнюю страницу.
- Используем `<a routerLink="/profile">Профиль</a>` для переключения на страницу профиля.

### Работа с параметрами в маршрутах

Порой маршрут требует параметров, например, `'/profile/:id'`, где `:id` — это переменная часть маршрута. Давайте разберем, как мы можем использовать параметры.

1. Изменим наш маршрут с `/profile` на `/profile/:id`:

```typescript
const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'profile/:id', component: ProfileComponent }
];
```

2. Получим параметр в компоненте `ProfileComponent`.

```typescript
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-profile',
  template: `<h2>Профиль</h2>
             <p>ID пользователя: {{ userId }}</p>`
})
export class ProfileComponent implements OnInit {
  userId: string;

  constructor(private route: ActivatedRoute) { }

  ngOnInit(): void {
    this.userId = this.route.snapshot.paramMap.get('id');
  }
}
```

Мы используем `ActivatedRoute` для получения параметров маршрута. В данном случае, мы извлекаем параметр `:id` и сохраняем его в свойстве `userId`, чтобы затем показать его в шаблоне.

3. Изменим ссылки, чтобы они учитывали ID:

```html
<nav>
  <a routerLink="/">Домой</a>
  <a [routerLink]="['/profile', 1]">Профиль пользователя 1</a>
  <a [routerLink]="['/profile', 2]">Профиль пользователя 2</a>
</nav>
```

### Подводим итоги

Теперь у нас есть два маршрута: один для домашней страницы и один динамический маршрут для профиля пользователя с учетом ID. Мы научились настраивать базовые маршруты, работать с `<router-outlet>`, динамически переключаться между страницами и использовать параметры в маршрутах.

Сложности здесь было немного, правда? Дальше мы сможем создавать более сложные маршруты, например, приложение с вложенными маршрутизациями, защитой маршрутов (чтобы ограничить доступ к определенным страницам), и многое другое. Но шаг за шагом.

Итак, вперед — экспериментируйте с кодом, добавляйте свои компоненты, и пусть ваше приложение обретает форму!

---

# Lazy loading модулей: Загрузка модулей по требованию для улучшения производительности.

# Неделя 1: Основы Angular

## Lazy Loading модулей: Загрузка модулей по требованию для улучшения производительности

**Lazy Loading** — это подход, позволяющий загружать части приложения только по мере необходимости, то есть на те страницы, которые пользуются спросом, фокусируя ресурсы там, где они действительно нужны. Это особенно важно для больших приложений, где загрузка всех модулей одновременно может занять много времени и ресурсов.

### Почему Lazy Loading?

Представьте себе приложение как книгу. Если у вас есть тонкая книга, вы можете быстро ее открыть и начать читать. Но когда книга толстая, открытие и поиск нужной страницы может занять больше времени. Вот здесь и помогает Lazy Loading: оно позволяет "раскрывать страницы" только тогда, когда они вам истинно нужны.

Преимущества Lazy Loading включают:

1. **Скорость:** Быстрая начальная загрузка приложения, сокращение времени до первой активности пользователя.
2. **Эффективность:** Оптимизация использования ресурсов, так как только необходимые элементы загружаются в память.
3. **Поддержка:** Простота в управлении и разделении кода на логические, легко поддерживаемые части.

### Как это работает в Angular?

Angular позволяет легко реализовать Lazy Loading модулей с помощью загрузчиков маршрутов, что мы могли бы тестировать на небольших примерах.

#### Пример

Допустим, у нас есть приложение электронной коммерции с такими секциями, как Главная, О продуктах, О нас и Контакты. Главная страница должна быть загружена сразу, остальные — по требованию.

1. **Создание модулей:**

   Первым шагом будет создание отдельных модулей для каждой секции приложения.

   ```bash
   ng generate module products --route products --module app.module
   ng generate module about --route about --module app.module
   ng generate module contact --route contact --module app.module
   ```

   Эти команды сгенерируют модули с соответствующими маршрутами, готовые для ленивой загрузки.

2. **Настройка маршрутов в `app-routing.module.ts`:**

   Теперь нужно зарегистрировать маршруты в основном маршрутизаторе приложения для ленивой загрузки созданных модулей.

   ```typescript
   import { NgModule } from '@angular/core';
   import { Routes, RouterModule } from '@angular/router';

   const routes: Routes = [
     { path: '', redirectTo: '/home', pathMatch: 'full' },
     // Лениво загружаемый модуль
     { path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) },
     { path: 'about', loadChildren: () => import('./about/about.module').then(m => m.AboutModule) },
     { path: 'contact', loadChildren: () => import('./contact/contact.module').then(m => m.ContactModule) },
   ];

   @NgModule({
     imports: [RouterModule.forRoot(routes)],
     exports: [RouterModule]
   })
   export class AppRoutingModule { }
   ```

   Здесь у нас три лениво загружаемых модуля: `ProductsModule`, `AboutModule` и `ContactModule`. Каждый из них будет загружаться только тогда, когда пользователь переходит к соответствующему пути.

3. **Конфигурация дочерних маршрутов в каждом модуле:**

   Например, для модуля `products` в маршрутизаторе модуля `products-routing.module.ts`:

   ```typescript
   import { NgModule } from '@angular/core';
   import { Routes, RouterModule } from '@angular/router';
   import { ProductsComponent } from './products.component';

   const routes: Routes = [
     { path: '', component: ProductsComponent }
   ];

   @NgModule({
     imports: [RouterModule.forChild(routes)],
     exports: [RouterModule]
   })
   export class ProductsRoutingModule { }
   ```

   Эта конфигурация переопределяет поведение маршрутизации для лениво загружаемого модуля, вручая управление конкретному компоненту, например, `ProductsComponent`.

### Практические Заметки

- **Организация кода:** Разделяйте на части большие приложения, чтобы поддерживать ясную и чистую архитектуру.
- **Оптимизация:** Всегда оценивайте, какие части вашего приложения редко используются и могут потребовать ленивой загрузки для экономии времени и ресурсов.
- **Обратная связь:** Контролируйте пользовательский опыт, ведь пользователи ценят плавный и непрерывный интерфейс.

Использование Lazy Loading в вашем Angular приложении может значительно улучшить производительность, предоставляя пользователям быстрый и непосредственный доступ к необходимым компонентам и экрану. Продолжаем наращивать нашу практическую базу и создаем приложения, которые поражают своей эффективностью, продвигая нас к успеху на собеседованиях и в проектах!

---

# Guards: Реализация CanActivate, CanDeactivate для защиты маршрутов.

### Неделя 1: Основы Angular

#### Guards: Реализация CanActivate, CanDeactivate для защиты маршрутов

Когда мы создаем приложение с помощью Angular, часто требуется контролировать доступ пользователей к различным страницам или маршрутам. Это можно сделать с помощью так называемых "Guard" — специальных механизмов, которые помогают управлять навигацией. Сегодня мы рассмотрим два типа Guard в Angular: `CanActivate` и `CanDeactivate`.

**CanActivate Guard:**  
Этот Guard предотвращает вход пользователя на определенный маршрут, если не выполняются определенные условия. Например, если пользователь не авторизован, его можно перенаправить на страницу входа.

**Пример использования CanActivate:**

Представим, что у нас есть страница профиля пользователя. Мы хотим, чтобы только авторизованные пользователи могли просматривать эту страницу.

**Шаг 1:** Создаем сервис для Guard.
```typescript
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AuthService } from './auth.service'; // Предположим, у нас есть AuthService для проверки авторизации

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor(private authService: AuthService, private router: Router) {}

  canActivate(): boolean {
    if (this.authService.isLoggedIn()) {
      return true;
    } else {
      this.router.navigate(['login']);
      return false;
    }
  }
}
```
**Объяснение:**  
Мы создали класс `AuthGuard`, который реализует интерфейс `CanActivate`. В его методе `canActivate` мы проверяем, залогинен ли пользователь. Если да — возвращаем `true`, и пользователь может перейти на запрашиваемую страницу. Если нет — перенаправляем на страницу входа и возвращаем `false`.

**Шаг 2:** Использование Guard в модулях роутинга.
```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { ProfileComponent } from './profile/profile.component';
import { AuthGuard } from './auth.guard';

const routes: Routes = [
  { path: 'profile', component: ProfileComponent, canActivate: [AuthGuard] },
  // другие маршруты
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```
**Объяснение:**  
Здесь мы применяем наш `AuthGuard` к маршруту `/profile`. Теперь каждый раз, когда пользователь пытается перейти на этот маршрут, срабатывает `AuthGuard`.

**CanDeactivate Guard:**  
Этот Guard определяет, можно ли покинуть страницу. Он полезен, когда на странице есть незавершенные действия, такие как заполнение формы.

**Пример использования CanDeactivate:**

Пусть у нас есть страница с формой, и мы хотим предупредить пользователя, если он пытается уйти, не сохранив изменения.

**Шаг 1:** Создаем интерфейс и сервис для Guard.
```typescript
export interface CanComponentDeactivate {
  canDeactivate: () => boolean;
}

import { Injectable } from '@angular/core';
import { CanDeactivate } from '@angular/router';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {

  canDeactivate(
    component: CanComponentDeactivate
  ): boolean | Observable<boolean> {
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}
```
**Объяснение:**  
Здесь мы создали интерфейс `CanComponentDeactivate`, который имеет метод `canDeactivate`. Этот метод будет определять компонент, чтобы реализовать логику, позволяющую оставлять страницу. `CanDeactivateGuard` получает компонент и вызывает его метод `canDeactivate`.

**Шаг 2:** Реализация в компоненте.
```typescript
import { Component } from '@angular/core';
import { CanComponentDeactivate } from './can-deactivate.guard';

@Component({
  selector: 'app-form',
  template: `
    <form>
      <!-- форма с полями -->
      <button (click)="save()">Сохранить</button>
    </form>
  `
})
export class FormComponent implements CanComponentDeactivate {

  private changeSaved: boolean = false;

  save() {
    // Сохранение данных
    this.changeSaved = true;
  }

  canDeactivate(): boolean {
    if (!this.changeSaved) {
      return confirm('Вы уверены, что хотите покинуть страницу? Изменения не сохранены.');
    }
    return true;
  }
}
```
**Объяснение:**  
В `FormComponent` мы реализовали метод `canDeactivate`, который проверяет, сохранил ли пользователь изменения. Если нет, появляется окно подтверждения.

**Шаг 3:** Применение Guard в модулях роутинга.
```typescript
const routes: Routes = [
  { path: 'form', component: FormComponent, canDeactivate: [CanDeactivateGuard] },
  // другие маршруты
];
```
**Объяснение:**  
Здесь мы подключаем `CanDeactivateGuard` к маршруту `/form`. Таким образом, всякий раз, когда пользователь пытается покинуть этот маршрут, будет вызвана функция `canDeactivate`.

Используя Guards в Angular, мы можем гибко управлять логикой переходов между страницами и защищать маршруты в наших приложениях. Это крайне полезно для создания безопасного и дружественного интерфейса для пользователей. Попробуйте сами реализовать Guards в своих проектах, это отличный способ улучшить навыки работы с Angular!

---

# Операторы RxJS: Основные операторы `map`, `filter`, `tap`, практическое применение.

# Неделя 1: Основы Angular

## Операторы RxJS: Основные операторы `map`, `filter`, `tap`, практическое применение

Angular — это популярный JavaScript-фреймворк, который позволяет создавать мощные SPA (Single Page Applications) с богатым пользовательским интерфейсом. Одним из его ключевых компонентов является библиотека для работы с асинхронными потоками данных, называемая RxJS (Reactive Extensions for JavaScript). На этой неделе мы разберёмся с основами RxJS и сосредоточимся на трёх важных операторах: `map`, `filter` и `tap`.

### Что такое RxJS и почему это важно?

RxJS позволяет работать с асинхронными операциями так, как будто это последовательности данных, чем-то похожие на массивы, с которыми вы, возможно, уже знакомы. Но разница в том, что данные (элементы) в этих последовательностях могут приходить во времени, например, события кликов пользователя на кнопки или получение ответа от сервера.

### Оператор `map`

Начнем с `map`, который работает очень похоже на одноимённый метод у массивов. Представьте, что у нас есть данные — течёт поток чисел, и нам нужно увеличить каждое число на 1. Вот как это можно сделать с оператором `map` в RxJS:

```javascript
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

// Наш поток данных — это просто цифры 1, 2, 3
const numbers$ = of(1, 2, 3);

// Используем оператор map, чтобы добавить 1 к каждому числу
const incrementedNumbers$ = numbers$.pipe(
  map(num => num + 1)
);

// Подписываемся и выводим каждое преобразованное число
incrementedNumbers$.subscribe({
  next: num => console.log(num)   // Вывод: 2, 3, 4
});
```

**Объяснение кода:**
1. Мы использовали оператор `of` для создания небольшого потока чисел.
2. Далее применили оператор `map`, чтобы преобразовать каждое число, добавив к нему 1.
3. С помощью `subscribe` мы подписались на поток и напечатали результаты в консоль.

### Оператор `filter`

Теперь давайте посмотрим на `filter`. Этот оператор пропускает данные через условие и только те элементы, которые удовлетворяют этому условию, проходят дальше. Например, мы хотим пропустить только чётные числа:

```javascript
import { of } from 'rxjs';
import { filter } from 'rxjs/operators';

// Наш поток данных — 1, 2, 3, 4, 5
const numbers$ = of(1, 2, 3, 4, 5);

// Используем оператор filter, чтобы пропустить только чётные числа
const evenNumbers$ = numbers$.pipe(
  filter(num => num % 2 === 0)
);

// Подписываемся и выводим только те числа, которые прошли фильтр
evenNumbers$.subscribe({
  next: num => console.log(num)   // Вывод: 2, 4
});
```

**Объяснение кода:**
1. Создали поток чисел от 1 до 5.
2. Применили `filter` для отбора только тех чисел, которые чётные (`num % 2 === 0`).
3. Отобразили результат, подписавшись на поток.

### Оператор `tap`

`tap` — это оператор, который позволяет делать какие-то побочные действия в потоке данных, не изменяя их. Он полезен для отладки или выполнения каких-то побочных операций. Например, мы можем выводить в консоль каждое значение на промежуточных этапах:

```javascript
import { of } from 'rxjs';
import { map, tap } from 'rxjs/operators';

// Создаем поток чисел 1, 2, 3
const numbers$ = of(1, 2, 3);

// Применяем tap для вывода каждого элемента в консоль
const processedNumbers$ = numbers$.pipe(
  tap(num => console.log('До увеличения:', num)),
  map(num => num + 1),
  tap(num => console.log('После увеличения:', num))
);

// Подписываемся, никаких дополнительных действий не требуется
processedNumbers$.subscribe();
```

**Объяснение кода:**
1. Изначально создаём поток с числами.
2. Используем `tap`, чтобы сначала вывести в консоль значение числа до преобразования.
3. Применяем `map` для увеличения числа.
4. С помощью второго `tap` выводим преобразованное значение.

### Практическое применение

Теперь давайте подумаем, как это всё может быть полезно в реальных приложениях. Представьте, что у вас есть форма на сайте, и вы хотите валидировать вводимые пользователем данные в реальном времени. Например, есть поле для почтового адреса, и вы хотите показать подсказку, как только пользователь начинает вводить текст:

```javascript
import { fromEvent } from 'rxjs';
import { map, filter, tap } from 'rxjs/operators';

// Получаем элемент текстового поля ввода
const inputElement = document.querySelector('#emails');

// Создаем поток событий 'input' на этом текстовом поле
const email$ = fromEvent(inputElement, 'input').pipe(
  // Из события 'input' получаем актуальное значение текста
  map(event => event.target.value),
  // Фильтруем, только если длина текста больше 3 символов
  filter(value => value.length > 3),
  // Используем tap, чтобы вывести значение для отладки
  tap(value => console.log('Введенный текст:', value))
);

// Подписка инициирует поток, и мы можем обработать дальнейшие действия
email$.subscribe(value => {
  // Здесь можно обновить пользовательский интерфейс в зависимости от введенного текста
  console.log('Подсказка: ' + value);
});
```

**Объяснение кода:**
1. Мы создаём поток с событий `input`, когда пользователь вводит текст в поле.
2. Программируем `map` так, чтобы извлечь текст из событий.
3. Применяем `filter`, ограничив поток значениями, которые имеют длину больше 3 символов.
4. Выводим в консоль введённый текст с помощью `tap`.
5. Наконец, подписка на `email$` позволяет вам управлять подсказками или делать другие действия в зависимости от текущего текста.

На практике такие подходы позволяют удобно и эффективно строить интерактивные и отзывчивые интерфейсы в Angular-приложениях. Может быть, это и кажется сложным на первый взгляд, но с помощью `map`, `filter` и `tap`, особенно если использовать их вместе, можно создавать сложные преобразования и манипуляции над потоками данных очень лаконично и выразительно.

---

# Жизненный цикл компонентов: ngOnInit, ngOnChanges, ngOnDestroy, ngDoCheck, AfterViewInit, AfterViewChecked, AfterContentInit, AfterContentChecked и их использование.

## Жизненный цикл компонентов: ngOnInit, ngOnChanges, ngOnDestroy, ngDoCheck, AfterViewInit, AfterViewChecked, AfterContentInit, AfterContentChecked и их использование

В этой части курса мы погрузимся в захватывающую тему жизненного цикла компонентов Angular. Представьте себе компонент как живое существо, у которого есть определенные этапы жизни: от рождения до смерти. Angular предоставляет специальные хуки, которые можно использовать, чтобы выполнять код на каждом из этих этапов. Давайте разберём каждый из них и поймём, как их можно использовать.

### ngOnInit

Начнём с `ngOnInit` — это один из самых популярных хуков и часто используется в Angular приложениях. Представьте `ngOnInit` как метод, который вызывается, когда ваш компонент полностью инициализирован. Это отличное место для загрузки данных или выполнения других установочных задач. 

```typescript
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-welcome',
  template: `<h1>Добро пожаловать в приложение!</h1>`
})
export class WelcomeComponent implements OnInit {
  ngOnInit() {
    console.log('Компонент Welcome инициализирован');
    // Здесь можно выполнить загрузку данных
  }
}
```

### ngOnChanges

`ngOnChanges` срабатывает, когда изменяются входные параметры (`@Input`) компонента. Это полезно, когда взаимодействие с компонентом требует выполнения определённых действий при изменении каких-либо данных.

```typescript
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `<p>Имя пользователя: {{name}}</p>`
})
export class UserProfileComponent implements OnChanges {
  @Input() name: string;

  ngOnChanges(changes: SimpleChanges) {
    console.log('Изменения:', changes);
    // Действия при обновлении входных данных
  }
}
```

### ngOnDestroy

`ngOnDestroy` — это своеобразный "прощальный" хук, который вызывается перед удалением компонента. Используйте его, чтобы освободить ресурсы или отменить подписки.

```typescript
import { Component, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-timer',
  template: `<p>Таймер работает!</p>`
})
export class TimerComponent implements OnDestroy {
  intervalId: any;

  ngOnInit() {
    this.intervalId = setInterval(() => {
      console.log('Тик так');
    }, 1000);
  }

  ngOnDestroy() {
    clearInterval(this.intervalId);
    console.log('Компонент Timer уничтожен');
  }
}
```

### ngDoCheck

`ngDoCheck` позволяет реализовать собственную логику слежения за изменениями. Этот хук вызывается при каждом цикле обнаружения изменений, так что используйте его с осторожностью, чтобы не вызвать сбои в производительности.

```typescript
import { Component, DoCheck } from '@angular/core';

@Component({
  selector: 'app-check',
  template: `<p>Проверка изменений</p>`
})
export class CheckComponent implements DoCheck {
  ngDoCheck() {
    console.log('Проверка изменений произошла');
    // Своя логика слежения за изменениями
  }
}
```

### AfterViewInit и AfterViewChecked

`AfterViewInit` срабатывает один раз, когда Angular полностью инициализирует представление компонента и его дочерние представления. Это место, где удобно выполнять действия, требующие доступа к DOM элементам.

`AfterViewChecked` срабатывает после каждого цикла обнаружения изменений (после `AfterViewInit`). Используйте его, если нужно реагировать на изменения, произошедшие после инициализации, но будьте осторожны с его частым использованием.

```typescript
import { Component, AfterViewInit, AfterViewChecked } from '@angular/core';

@Component({
  selector: 'app-view',
  template: `<p>Работа с представлением</p>`
})
export class ViewComponent implements AfterViewInit, AfterViewChecked {
  ngAfterViewInit() {
    console.log('После инициализации представления');
    // Доступ к элементам DOM
  }

  ngAfterViewChecked() {
    console.log('После проверки представления');
    // Действия после проверок
  }
}
```

### AfterContentInit и AfterContentChecked

Эти хуки связаны с содержимым, которое передаётся внутрь компонента через `<ng-content>`. 

`AfterContentInit` вызывается после инициализации внешнего контента компонента.

`AfterContentChecked` вызывается после проверки содержимого.

```typescript
import { Component, AfterContentInit, AfterContentChecked } from '@angular/core';

@Component({
  selector: 'app-content',
  template: `<ng-content></ng-content>`
})
export class ContentComponent implements AfterContentInit, AfterContentChecked {
  ngAfterContentInit() {
    console.log('После инициализации содержимого');
    // Действия после инициализации содержимого
  }

  ngAfterContentChecked() {
    console.log('После проверки содержимого');
    // Действия после проверок содержимого
  }
}
```

Эти хуки жизненного цикла Angular компонентов открывают широкий спектр возможностей для управления состоянием и поведением компонентов на разных стадиях их существования. Используйте эти механизмы с умом, чтобы создавать гибкие и производительные Angular приложения. В следующей главе мы рассмотрим, как на практике начнём строить сложные структуры, используя эти хуки.

---

# ActivatedRoute

**Неделя 1: Основы Angular**

### Тема: ActivatedRoute

Когда мы начинаем изучать Angular, одной из первых вещей, которые необходимо понять, являются маршрутизация и работа с URL-адресами. Эта тема может показаться сложной, но давайте упростим её, чтобы каждый мог легко усвоить материал.

#### Что такое ActivatedRoute?

В приложении Angular мы часто работаем с динамическими данными, которые могут приходить из различных источников, включая URL. Например, когда вы открываете интернет-магазин и видите информацию о каком-то конкретном товаре, URL может выглядеть как `www.mystore.com/products/42`, где `42` — это ID товара. В Angular для извлечения этой информации из URL мы используем `ActivatedRoute`.

`ActivatedRoute` — это сервис, который позволяет нам получить доступ к информации о текущем маршруте. Представьте, что это как волшебный помощник, который знает все о том, где вы находитесь в приложении, и может рассказать вам об этом.

#### Как использовать ActivatedRoute на практике

Рассмотрим простой пример, где мы извлекаем параметр из URL и используем его в нашем компоненте.

1. **Настройка маршрута:**

   Предположим, у нас есть компонент `ProductComponent`, который должен показывать информацию о товаре. Мы настроим маршруты так, чтобы URL вида `/products/:id` открывал наш компонент:

   ```typescript
   import { NgModule } from '@angular/core';
   import { RouterModule, Routes } from '@angular/router';
   import { ProductComponent } from './product/product.component';

   const routes: Routes = [
     { path: 'products/:id', component: ProductComponent }
   ];

   @NgModule({
     imports: [RouterModule.forRoot(routes)],
     exports: [RouterModule]
   })
   export class AppRoutingModule {}
   ```

   Здесь `:id` — это динамическая часть маршрута. Angular автоматически так настроен, что он распознает это как параметр.

2. **Получение параметра в компоненте:**

   В `ProductComponent` мы можем воспользоваться `ActivatedRoute`, чтобы получить значение ID товара из URL.

   ```typescript
   import { Component, OnInit } from '@angular/core';
   import { ActivatedRoute } from '@angular/router';

   @Component({
     selector: 'app-product',
     template: `
       <h1>Product Details</h1>
       <p>Product ID: {{ productId }}</p>
     `
   })
   export class ProductComponent implements OnInit {
     productId: string | null = null;

     constructor(private route: ActivatedRoute) {}

     ngOnInit(): void {
       this.route.paramMap.subscribe(params => {
         this.productId = params.get('id');
       });
     }
   }
   ```

   Давайте детально разберём, что здесь происходит:

   - **`ActivatedRoute`:** Сначала мы внедряем `ActivatedRoute` в наш компонент через конструктор. Это как подключение к интернету, которое позволяет нам «поймать» нужные данные.

   - **`paramMap`:** `paramMap` — это специальная структура данных, представляющая параметры URL. Мы подписываемся на её обновления, потому что URL может изменяться (например, при переходе на другой товар на той же странице).

   - **`subscribe`:** Мы используем `subscribe`, чтобы следить за изменениями параметров. Когда параметр `id` изменяется, наш компонент сразу об этом узнает и обновляет `productId`.

   Теперь, когда пользователь переходит по адресу `/products/42`, наш компонент узнает, что ID товара — это `42`, и отображает его.

#### Другие возможности ActivatedRoute

- **queryParams:** Кроме параметров маршрута, бывают и параметры запроса (например, `?sort=asc`). `ActivatedRoute` также по умолчанию предоставляет доступ к ним:

  ```typescript
  this.route.queryParamMap.subscribe(queryParams => {
    const sortOrder = queryParams.get('sort');
  });
  ```

- **snapshot:** Если вам не нужно отслеживать изменения, а требуется узнать параметры только один раз при загрузке, можно использовать `snapshot`:

  ```typescript
  this.productId = this.route.snapshot.paramMap.get('id');
  ```

Использование `ActivatedRoute` может показаться на первых порах немного запутанным, но по сути — это простой и удобный инструмент для работы с динамическими данными, связанными с URL. Благодаря ему, ваши приложения можно легко модифицировать и улучшать их взаимодействие с пользователем. На практике это будет часто используемый и полезный помощник для создания мощных и гибких приложений.

---

# Операторы переключения потоков (switchMap, concatMap, mergeMap, exhaustMap)

# Неделя 1: Основы Angular  
## Операторы переключения потоков (switchMap, concatMap, mergeMap, exhaustMap)

Когда ты начинаешь углубляться в Angular и работать с асинхронными данными, тебе нужно понять, как управлять потоками данных. В основе этого понимания лежит работа с RxJS — библиотекой для реактивного программирования с использованием Observables. Сегодня мы поговорим о некоторых мощных операторах переключения потоков в RxJS, которые могут значительно упростить твою работу с асинхронными данными: `switchMap`, `concatMap`, `mergeMap` и `exhaustMap`.

### Что такое оператор переключения потока?

Оператор переключения потока позволяет нам реагировать на новый поток данных (например, запрос к серверу или пользовательское событие). Главная идея заключается в том, что когда приходит новый поток данных (например, второй API-запрос), нам нужно решить, как мы будем обрабатывать этот новый поток по отношению к существующему (например, завершить текущий, переключиться на новый или дождаться окончания).

### Давайте познакомимся с каждым из операторов более подробно:

#### 1. switchMap

**Когда использовать:** Если тебе нужно отменить предыдущий запрос, как только приходит новый.

**Пример:**

Представь, что у тебя есть поле поиска, и каждый раз, когда пользователь вводит текст, нужно обращаться к API. `switchMap` полезен здесь, потому что, если пользователь вводит текст быстро, ты можешь отменить предыдущие запросы, чтобы обращаться к API только с последним актуальным запросом.

```typescript
import { fromEvent } from 'rxjs';
import { map, debounceTime, switchMap } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';

const searchInput = document.getElementById('search');

const search$ = fromEvent(searchInput, 'input').pipe(
  map(event => event.target.value),
  debounceTime(300), // Ждем, пока пользователь закончит ввод
  switchMap(searchTerm => ajax.getJSON(`https://api.example.com/search?q=${searchTerm}`))
);

search$.subscribe(response => {
  console.log(response);
  // Отобразим результаты поиска...
});
```

**Объяснение:** В этом примере, каждый раз, когда пользователь вводит что-то в поле, старый запрос к API автоматически отменяется, и начинается новый.

#### 2. mergeMap

**Когда использовать:** Если тебе нужно обрабатывать все исходящие потоки одновременно.

**Пример:**

Представь, что у тебя есть процесс, который порождает несколько асинхронных задач, но порядок их завершения не важен.

```typescript
import { from } from 'rxjs';
import { mergeMap } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';

const taskIds = [1, 2, 3, 4];

from(taskIds).pipe(
  mergeMap(id => ajax.getJSON(`https://api.example.com/task/${id}`))
).subscribe(response => {
  console.log(response);
  // Работаем с результатом каждой задачи...
});
```

**Объяснение:** Здесь каждый запрос обрабатывается независимо и параллельно — в том порядке, в котором завершится загрузка.

#### 3. concatMap

**Когда использовать:** Если тебе нужно обрабатывать задачи последовательно, каждая следующая должна ждать окончания предыдущей.

**Пример:**

Иногда у нас может быть несколько задач, которые должны выполняться в строгом порядке. Например, нужно сначала загрузить данные пользователя, а затем, используя эти данные, загрузить что-то еще.

```typescript
import { from } from 'rxjs';
import { concatMap } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';

const userIds = [1, 2, 3, 4];

from(userIds).pipe(
  concatMap(id => ajax.getJSON(`https://api.example.com/user/${id}`))
).subscribe(response => {
  console.log(response);
  // Данные загружаются поочередно...
});
```

**Объяснение:** В этом коде задачи выполняются строго по очереди — сначала полностью загружаются данные первого пользователя, затем второго и так далее.

#### 4. exhaustMap

**Когда использовать:** Если ты хочешь игнорировать новые входящие потоки, пока текущий поток не завершится.

**Пример:**

Этот подход полезен, если ты хочешь избежать перегрузки системы запросами, например, когда пользователь случайно несколько раз нажал на кнопку, которая запускает запросы к серверу.

```typescript
import { fromEvent } from 'rxjs';
import { exhaustMap } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';

const button = document.getElementById('saveButton');

const saveRequest$ = fromEvent(button, 'click').pipe(
  exhaustMap(() => ajax.post('https://api.example.com/save', { data: 'sample' }))
);

saveRequest$.subscribe(response => {
  console.log('Данные сохранены!', response);
});
```

**Объяснение:** При нескольких кликах по кнопке будет обработан только первый запрос, последующие клики будут игнорироваться, пока текущий запрос не завершится.

### Заключение

Итак, у нас есть четыре оператора переключения потока, каждый из которых решает разную задачу с асинхронными потоками данных. В зависимости от конкретной ситуации ты сможешь выбрать подходящий оператор, чтобы оптимально управлять своими потоками данных. Попробуй использовать разные операторы в своих проектах и увидеть, как они помогают уменьшить код и улучшить производительность.

---

# Комбинирования потоков (forkJoin, combineLatest, zip, merge, concat, race)

# Неделя 1: Основы Angular

## Комбинирование потоков (forkJoin, combineLatest, zip, merge, concat, race)

В первом модуле нашего Angular курса мы говорим о потоках данных и том, как в Angular можно эффективно управлять ими. У нас есть несколько стратегий для объединения потоков данных, которые помогут создать более интерактивные и динамичные приложения. Давайте погрузимся в несколько основных методов, включая `forkJoin`, `combineLatest`, `zip`, `merge`, `concat` и `race`.

### forkJoin

`forkJoin`– это метод из библиотеки RxJS, используемой в Angular для работы с потоками данных (Observable). Главное в `forkJoin` — все потоки должны окончиться, прежде чем `forkJoin` выдаст результат. Это похоже на сбор всех овощей перед приготовлением супа — пока хотя бы один овощ «в пути», мы не можем начать готовить!

```typescript
import { forkJoin, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const apple = of('Яблоко').pipe(delay(1000));
const banana = of('Банан').pipe(delay(2000));
const orange = of('Апельсин').pipe(delay(3000));

forkJoin([apple, banana, orange]).subscribe(fruits => {
  console.log(fruits); // Выведет: ['Яблоко', 'Банан', 'Апельсин'] после 3 секунд
});
```

В этом примере мы создаем три потока, представляющие разные фрукты. Каждый фрукт "достигает" нас с задержкой. `forkJoin` собирает все плоды и выдает их разом, когда все отдают результат, через самое длинное время (3 секунды в данном случае).

### combineLatest

`combineLatest` выдает результат каждый раз, когда один из потоков выдает новое значение. Он комбинирует последние известные значения каждого потока. Это похоже на приготовление салата: как только появляется новый ингредиент, мы обновляем его в салате.

```typescript
import { combineLatest, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const firstName = of('Иван').pipe(delay(1000));
const lastName = of('Петров').pipe(delay(2000));

combineLatest([firstName, lastName]).subscribe(fullName => {
  console.log(fullName.join(' ')); // Сначала: ['Иван', 'Петров']
});
```

Здесь мы имеем два потока — `firstName` и `lastName`. `combineLatest` будет выдавать новое сочетание имен каждый раз, когда одно из них изменяется (в нашем случае после 2 секунд).

### zip

`zip` похож на застежку молнии: соединяет потоки, идущие вместе, выдавая результат, когда все совпадения найдены.

```typescript
import { zip, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const numSequence = of(1, 2, 3).pipe(delay(1000));
const letterSequence = of('A', 'B', 'C').pipe(delay(2000));

zip(numSequence, letterSequence).subscribe(val => {
  console.log(val); // Выведет: [1, 'A'], [2, 'B'], [3, 'C']
});
```

В примере `zip` ожидает соответствующие пары достижений значений из двух потоков и выдает их в паре.

### merge

`merge` — объединяет несколько потоков, выдавая значения каждого потока, как только они будут выдаваться. Это как если бы несколько ручьев сливались в одну реку — каждое прибавляется по мере поступления.

```typescript
import { merge, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const fastStream = of('быстрый поток').pipe(delay(1000));
const slowStream = of('медленный поток').pipe(delay(3000));

merge(fastStream, slowStream).subscribe(console.log);
// Выдаст: 'быстрый поток' через 1 секунду, 'медленный поток' через 3 секунды
```

В `merge` каждый поток действует независимо, и выдает значения, как только они становятся доступными.

### concat

`concat` запускает каждый поток по очереди — следующий поток начнется только после завершения предыдущего. Это как заказывать два кофе в кафе: вы получите второй только после того, как приготовят первый.

```typescript
import { concat, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const coffee = of('Кофе готов').pipe(delay(1000));
const tea = of('Чай готов').pipe(delay(2000));

concat(coffee, tea).subscribe(console.log);
// Сначала: 'Кофе готов', затем: 'Чай готов' (через 3 секунды)
```

Сначала мы получаем значение из первого потока (`coffee`), а только потом из второго (`tea`).

### race

`race` выбирает только тот поток, который дальше всего продвинется в момент выдачи первого значения. Подобно гонке, только самый быстрый побеждает!

```typescript
import { race, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const turtle = of('Черепаха').pipe(delay(3000));
const rabbit = of('Кролик').pipe(delay(1000));

race(turtle, rabbit).subscribe(console.log); // 'Кролик' через 1 секунду
```

Здесь мы начинаем гонку между `turtle` и `rabbit`. В силу своей скорости, `rabbit` завершается раньше и побеждает.

---

Эти методы комбинирования потоков - основные инструменты, которые мы будем использовать для реализации сложных сценариев взаимодействия данных в Angular. Каждое из них имеет свои уникальные особенности и подходит для разных ситуаций. На практике, понимание того, какие данные и когда должны быть получены и обработаны, поможет вам выбрать подходящий инструмент для каждой задачи.

---

# Мини-проекты: Создание простого todo-приложения, регистрационной формы с управлением состоянием.

## Неделя 1: Основы Angular

### Мини-проекты: Создание простого todo-приложения, регистрационной формы с управлением состоянием

Добро пожаловать в первую неделю нашего курса по изучению Angular! В этой части мы сосредоточимся на изучении основных концепций Angular через два практических мини-проекта. Эти проекты помогут вам закрепить знания на практике и подготовят к решению более серьезных задач.

#### Проект 1: Простое todo-приложение

Наше первое задание — разработать простое todo-приложение, которое позволит добавлять и удалять задачи из списка. Начнем с создания нового Angular-проекта:

1. **Создание проекта**:
   Мы будем использовать Angular CLI, чтобы создать наш проект. Откройте командную строку и выполните команду:

   ```bash
   ng new todoApp
   ```

   Она создаст новый проект под названием `todoApp`. Следуйте инструкциям и выберите параметры по умолчанию.

2. **Создание компонента**:
   Теперь создадим компонент для работы с задачами. Введем команду:

   ```bash
   ng generate component todo
   ```

   Это создаст файлы, необходимые для нового компонента.

3. **Шаблон компонента**:
   Отредактируем HTML шаблон в файле `todo.component.html`, чтобы создать интерфейс для взаимодействия с задачами.

   ```html
   <div>
     <h2>Todo List</h2>
     <input placeholder="What needs to be done?" [(ngModel)]="newTask" />
     <button (click)="addTask()">Add</button>
     <ul>
       <li *ngFor="let task of tasks; let i = index">
         {{ task }}
         <button (click)="removeTask(i)">Remove</button>
       </li>
     </ul>
   </div>
   ```

   Здесь мы используем двухстороннее связывание данных (`[(ngModel)]`) для ввода нового задания и список с циклом `*ngFor` для отображения всех задач.

4. **Логика компонента**:
   Добавим функциональность для добавления и удаления задач в `todo.component.ts`.

   ```typescript
   import { Component } from '@angular/core';

   @Component({
     selector: 'app-todo',
     templateUrl: './todo.component.html',
     styleUrls: ['./todo.component.css']
   })
   export class TodoComponent {
     newTask: string = '';
     tasks: string[] = [];

     addTask() {
       if (this.newTask.trim()) {
         this.tasks.push(this.newTask);
         this.newTask = '';
       }
     }

     removeTask(index: number) {
       this.tasks.splice(index, 1);
     }
   }
   ```

   В этом файле мы описали наш компонент: массив `tasks` для хранения заданий, строку `newTask` для нового задания и два метода `addTask` и `removeTask` для управления списком.

5. **Добавление в основной шаблон**:
   Теперь встроим наш компонент в основной шаблон приложения `app.component.html`:

   ```html
   <app-todo></app-todo>
   ```

   Поздравляю, вы сделали свое первое todo-приложение! Попробуйте добавить задачи, удалить их и поиграться с вашим приложением.

#### Проект 2: Регистрационная форма с управлением состоянием

Теперь мы создадим регистрационную форму, которая будет собирать данные пользователя и управлять состоянием ввода.

1. **Создание компонента**:
   Запустите команду:

   ```bash
   ng generate component registration
   ```

2. **HTML форма**:
   Решим, какие данные нам нужны от пользователя: имя, email и пароль. Откроем `registration.component.html` и добавим следующие элементы:

   ```html
   <form (ngSubmit)="onSubmit()" #formRef="ngForm">
     <div>
       <label for="name">Name:</label>
       <input id="name" name="name" [(ngModel)]="user.name" required />
     </div>
     <div>
       <label for="email">Email:</label>
       <input id="email" name="email" [(ngModel)]="user.email" required email />
     </div>
     <div>
       <label for="password">Password:</label>
       <input id="password" name="password" [(ngModel)]="user.password" required minlength="6" type="password" />
     </div>
     <button type="submit" [disabled]="formRef.invalid">Register</button>
   </form>
   ```

   Здесь форма управляется с помощью Angular и `ngModel`, связывающего данные формы с объектом `user`.

3. **Логика компонента**:
   Переходим к `registration.component.ts`:

   ```typescript
   import { Component } from '@angular/core';

   interface User {
     name: string;
     email: string;
     password: string;
   }

   @Component({
     selector: 'app-registration',
     templateUrl: './registration.component.html',
     styleUrls: ['./registration.component.css']
   })
   export class RegistrationComponent {
     user: User = {
       name: '',
       email: '',
       password: ''
     };

     onSubmit() {
       if (this.user.name && this.user.email && this.user.password) {
         console.log('User registered:', this.user);
         // Здесь можно добавить логику отправки данных на сервер
         this.user = { name: '', email: '', password: '' };
       }
     }
   }
   ```

   Мы создали интерфейс `User` и объект `user`, который заполняется через форму. Метод `onSubmit()` выводит данные в консоль и очищает форму после успешного ввода.

4. **Интеграция с приложением**:
   Теперь добавим компонент в `app.component.html`:

   ```html
   <app-registration></app-registration>
   ```

Вот и всё! У вас теперь есть регистрационная форма, которая управляет своими данными и проверяет ввод. Благодаря этим проектам вы уже освоили основные концепции Angular: компоненты, шаблоны, связывание данных и управление состоянием.

Двигаемся дальше!

---

# Работа с шаблонным синтаксисом: Интерполяция, связывание свойств и событий, создание двусторонней привязки через [(ngModel)\], разница в использовании атрибутов без квадратных скобок и с ними (\[style\] и style \[class\] и class)

### Неделя 1: Основы Angular

#### Работа с шаблонным синтаксисом: Интерполяция, связывание свойств и событий, создание двусторонней привязки через `[(ngModel)]`, разница в использовании атрибутов без квадратных скобок и с ними (`[style]` и `style`, `[class]` и `class`)

Начнем нашу увлекательную поездку по Angular с изучения базового синтаксиса работы с шаблонами. Это позволит вам создавать интерактивные и динамичные веб-приложения. Отложим в сторону сложные термины и разберемся с каждым аспектом на простых примерах.

### Интерполяция

**Интерполяция** — это способ, с помощью которого Angular позволяет вставлять значения переменных прямо в ваш HTML-код.

**Пример:**

```html
<div>
  <p>Привет, {{ userName }}!</p>
</div>
```

В этом примере `{{ userName }}` — это директива интерполяции. Она берет значение переменной `userName` и подставляет его в текст между тегами `<p></p>`. Пусть переменная `userName` равна "Аня", тогда браузер увидит следующий HTML:

```html
<p>Привет, Аня!</p>
```

### Связывание свойств

**Связывание свойств** — это способ изменить свойства HTML-элементов динамически.

**Пример:**

```html
<img [src]="profileImage" alt="Profile Image">
```

Тут `[src]` — это связывание свойства. Оно позволяет динамически назначить адрес изображения, который находится в переменной `profileImage`. Это полезно, если изображение меняется в зависимости от данных пользователя.

### Связывание событий

**Связывание событий** используется для реагирования на действия пользователя, такие как щелчки мыши.

**Пример:**

```html
<button (click)="sayHello()">Сказать привет</button>
```

В этом примере `(click)` отвечает за связывание события. Когда пользователь нажимает кнопку, вызывается метод `sayHello()`, который выполняет определенную логическую задачу. 

```typescript
sayHello() {
  alert('Привет!');
}
```

### Двусторонняя привязка через `[(ngModel)]`

Двусторонняя привязка позволяет вашему приложению "слушать" изменения данных и автоматически обновлять пользовательский интерфейс.

**Пример:**

```html
<input [(ngModel)]="userName" placeholder="Введите ваше имя">
<p>Ваше имя: {{ userName }}</p>
```

Когда пользователь что-то вводит в текстовое поле, переменная `userName` автоматически обновляется, и изменения сразу же отображаются в `<p>{{ userName }}</p>`.

### Разница в использовании атрибутов без квадратных скобок и с ними

#### `[style]` и `style`

- **`[style]`** — связывание свойства. Оно позволяет динамически управлять стилем элемента.

  **Пример:**

  ```html
  <div [style.color]="isHighlighted ? 'red' : 'black'">
    Это текст подсвечен?
  </div>
  ```

  Если `isHighlighted` равен `true`, текст будет красным, иначе — черным.

- **`style`** — базовое HTML-использование. Это статическое указание стиля.

  **Пример:**

  ```html
  <div style="color: red;">
    Это статический красный текст.
  </div>
  ```

#### `[class]` и `class`

- **`[class]`** — связывание класса. Очень похоже на связывание стиля — позволяет динамически задавать классы.

  **Пример:**

  ```html
  <div [class.active]="isActive">
    Этот текст активен?
  </div>
  ```

  Если переменная `isActive` равна `true`, к элементу будет добавлен класс `active`.

- **`class`** — обычное указание классов, как в стандартном HTML.

  **Пример:**

  ```html
  <div class="active">
    Этот текст всегда активен.
  </div>
  ```

Использование `[style]` и `[class]` полезно, когда вам нужно изменить вид элемента в зависимости от изменения данных.

На этой неделе вы познакомились с главным инструментарием Angular для работы с шаблонами. Это была насыщенная информация, но с практикой вы сможете свободно работать с динамическим контентом в Angular. Вы можете поиграть с этими примерами в своем редакторе или в песочнице Angular, такие как StackBlitz или CodeSandbox, чтобы увидеть, как это работает на практике.

---

# Шаблонные переменные: Использование `#templateRef` и доступ к элементам DOM через них.

# Неделя 1: Основы Angular

## Шаблонные переменные: Использование `#templateRef` и доступ к элементам DOM через них

В мире Angular одним из первых и самых важных шагов в изучении фреймворка является понимание работы с шаблонами и динамическими данными. Сегодня мы поговорим о шаблонных переменных, которые позволяют нам взаимодействовать с элементами DOM прямо в шаблоне.

### Что такое шаблонная переменная?

Шаблонная переменная — это своего рода "ярлык" или "ссылка", которую можно прикрепить к разным элементам в вашем HTML-шаблоне. Она позволяет вам взаимодействовать с этими элементами прямо из вашей Angular-компоненты.

Шаблонные переменные начинаются с символа `#` и задаются в HTML-коде рядом с элементами, которым вы хотите назначить переменную.

### Простой пример

Давайте начнем с базового примера:

```html
<input #myInput type="text" placeholder="Введите что-то...">
<button (click)="logValue(myInput.value)">Логировать значение</button>
```

**Что здесь происходит?**

1. У нас есть текстовое поле `<input>` с назначенной ему шаблонной переменной `myInput`.
2. Мы добавляем кнопку, которая по клику вызывает метод `logValue()`, передавая ему значение из текстового поля.

Вот как может выглядеть реализация метода `logValue()` в компоненте TypeScript:

```typescript
export class AppComponent {
  logValue(value: string): void {
    console.log('Введенное значение:', value);
  }
}
```

Когда пользователь вводит текст и нажимает на кнопку, метод `logValue()` выводит в консоль введенное значение.

### Глубже: доступ к DOM-элементам

Шаблонные переменные могут быть чрезвычайно полезными, когда нужно получить больше, чем просто значение. Например, вы можете манипулировать самим элементом DOM.

Давайте расширим наш пример:

```html
<input #myInput type="text" placeholder="Введите что-то...">
<button (click)="focusInput()">Фокусироваться на поле ввода</button>
```

Теперь представим, что мы хотим, чтобы фокус на текстовое поле устанавливался при нажатии на кнопку. Мы можем сделать это, обратившись к нативному элементу через шаблонную переменную.

Наш метод `focusInput()` может выглядеть так:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  focusInput(myInput: HTMLInputElement): void {
    myInput.focus();
  }
}
```

Теперь нужно немного изменить кнопку в HTML-шаблоне, чтобы передать сам элемент DOM:

```html
<button (click)="focusInput(myInput)">Фокусироваться на поле ввода</button>
```

### Рассмотрим еще один пример: работа с таблицей

Шаблонные переменные особенно полезны, когда у вас есть элементы, которые нужно контролировать без использования больших объёмов кода TypeScript. Возьмем, к примеру, таблицу:

```html
<table>
  <tr>
    <th>Имя</th>
    <th>Возраст</th>
  </tr>
  <tr #row *ngFor="let person of people">
    <td>{{ person.name }}</td>
    <td>{{ person.age }}</td>
  </tr>
</table>
<button (click)="highlightFirstRow(row)">Выделить первую строку</button>
```

В этом примере у нас есть переменная `row`, назначенная каждой строке таблицы, и кнопка, которая выделяет первую строку. Метод `highlightFirstRow()` будет выглядеть так:

```typescript
highlightFirstRow(row: HTMLElement): void {
  row.style.backgroundColor = '#FFD700'; // Цвет золотой
}
```

Теперь, когда вы нажмете кнопку, первая строка таблицы будет выделена.

### Заключение

Шаблонные переменные Angular — это мощный инструмент для работы с элементами DOM. Они позволяют легко и эффективно получать и управлять информацией о пользовательском интерфейсе и управлять им. Изучение их использования поможет вам лучше контролировать ваши приложения и сделать их более интерактивными и отзывчивыми.

---

# :host, ::ng-deep

# Неделя 1: Основы Angular
## :host, ::ng-deep

Теперь, когда мы уже немного познакомились с основами Angular, пора углубиться в удивительный мир манипуляции стилями. Сегодня мы изучим два мощных инструмента, которые помогут нам навести красоту в наших компонентах: `:host` и `::ng-deep`.

### 1. Что такое :host?

Когда мы разрабатываем компоненты Angular, каждый компонент представляет собой отдельный, независимый кусочек нашего приложения. Будто каждая часть — это мини-приложение в вашем большом приложении. Но часто возникают ситуации, когда вам нужно добавить стиль непосредственно к корневому элементу вашего компонента. Вот тут-то и наш помощник — псевдокласс `:host`. Давайте разберемся в этом концепте на примере.

#### Пример 1: Использование :host

У вас есть компонент `my-button`, и вот его шаблон:

```html
<button>Кликни меня</button>
```

Теперь вы хотите, чтобы кнопка была по центру и с красивым фоном. Это можно сделать с помощью `:host`.

В ваших стилях компонента (`my-button.component.css`) добавьте:

```css
:host {
  display: block;
  text-align: center;
  background-color: lightblue;
  padding: 10px;
  border-radius: 5px;
}
```

Что это делает? Это применяет стили к элементу `<my-button>`, который оборачивает ваш шаблон. Так мы задаем фоновый цвет и центровку для всего компонента!

**Пояснение:**
- `display: block` делает компонент блочным элементом, чтобы можно было применять другие стили.
- `text-align: center` ставит текст внутри (то есть кнопку) по центру.
- Эти стили применяются не к отдельному элементу (например, `<button>` внутри компонента), а к самому компоненту.

### 2. Что такое ::ng-deep?

Представьте, что вам нужно изменить стиль внутри другого компонента — например, вы хотите изменить стиль элемента, находящегося внутри вашего компонента-потомка. Это бывает необходимо, но стандартно стили, которые вы задаёте в CSS-файле компонента, изолированы только в его собственных рамках.

Вот где нам на помощь приходит `::ng-deep`. Но важно отметить: вы должны использовать его с осторожностью!

#### Пример 2: Использование ::ng-deep

Допустим, у вас есть другой компонент, который вы включили в ваш основной компонент. Например, компонент `child-component` имеет следующее HTML:

```html
<p>Это текст внутри дочернего компонента!</p>
```

И вам нужно изменить стиль этого параграфа, который находится внутри дочернего компонента из вашего основного компонента. В ваших стилях основного компонента вы можете написать:

```css
::ng-deep child-component p {
  color: red;
  font-size: 18px;
}
```

**Пояснение:**
- `::ng-deep` говорит Angular, что вы хотите применить стиль внутри других DOM-объектов, которые вложены в компонент.
- Здесь мы ставим все `p` внутри `child-component` красными с определенным размером шрифта.

### Важные моменты

- **Изолированность стилей:** Angular по умолчанию изолирует стили, чтобы изменения в одном компоненте не влияли на другие, но иногда нам приходится выходить за эти рамки.
- **Устаревание ::ng-deep:** Следует упомянуть, что `::ng-deep` считается устаревшим и в будущем может быть удален из Angular. Но в текущих версиях он еще полезен, когда нужно пробить эту изоляцию стилей.
  
### Итог

Сегодня мы узнали, как управлять стилями, непосредственно изменяя корневой элемент компонента с помощью `:host`, и как мы можем применить стили, проникая внутрь дочерних компонентов через `::ng-deep`. Используйте эти инструменты умело и только когда это по-настоящему необходимо. На практике это поможет вам делать интерфейсы более гибкими и адаптивными.

---

# Создание сервисов: Angular CLI генерация сервисов, аннотация @Injectable().

# Неделя 1: Основы Angular

## Создание сервисов: Angular CLI генерация сервисов, аннотация @Injectable()

Привет, коллеги-разработчики! Сегодня мы познакомимся с одной из самых важных концепций в Angular — сервисами. Сервисы помогают делиться логикой и данными между компонентами, освобождая их от лишних обязанностей. Это как если бы у вас была целая команда специальных помощников, которая всегда наготове и готова предоставить нужную информацию или выполнить задачу. Давайте начнем с основ — создания сервиса.

### Что такое сервисы?

Сервис в Angular — это класс, который предоставляет данные или функциональность вашему приложению. Сервисы пригодятся, когда нужно делиться данными между разными компонентами или когда необходимо вынести какую-то сложную логику за пределы компонента для упрощения кода и повышения его тестируемости.

### Angular CLI и создание сервиса

Angular CLI, как волшебная палочка, может генерировать для нас структуры разного рода, в том числе и сервисы, чтобы мы могли сосредоточиться на создании функциональности. Генерация сервиса с помощью Angular CLI проста и быстра.

```bash
ng generate service my-awesome
```

Когда вы выполните эту команду, Angular CLI создаст два файла:

1. `my-awesome.service.ts`: тут будет наш класс сервиса.
2. `my-awesome.service.spec.ts`: файл для тестирования сервиса, на случай, если вы захотите испытать его стабильность.

### Взгляд на аннотацию @Injectable()

Теперь давайте откроем `my-awesome.service.ts`. Вот что вы увидите:

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class MyAwesomeService {

  constructor() { }

}
```

Аннотация `@Injectable()` говорит Angular о том, что этот класс можно использовать в качестве зависимости, и Angular может "вкалывать" (инжектировать) его в другие классы. Инжектирование позволяет Angular автоматически создавать экземпляры классов и предоставлять их нужному компоненту или другому сервису, когда это необходимо.

### Сервис на практике

Давайте создадим простой сервис, который будет предоставлять нам список задач. Мы добавим метод, который вернет массив строк, представляющих наши задачи.

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class TaskService {

  private tasks: string[] = ["Buy groceries", "Go for a run", "Read a book"];

  constructor() {}

  getTasks(): string[] {
    return this.tasks;
  }
}
```

В данном примере сервис `TaskService` содержит массив `tasks` и метод `getTasks()`, который возвращает эти задачи.

### Использование сервиса в компоненте

Чтобы использовать наш сервис в компоненте, мы должны "инжектировать" его в конструктор компонента. Давайте предположим, что у нас есть компонент TaskListComponent:

```typescript
import { Component, OnInit } from '@angular/core';
import { TaskService } from './task.service';

@Component({
  selector: 'app-task-list',
  template: `
    <h2>My Tasks</h2>
    <ul>
      <li *ngFor="let task of tasks">{{ task }}</li>
    </ul>
  `
})
export class TaskListComponent implements OnInit {

  tasks: string[] = [];

  constructor(private taskService: TaskService) {}

  ngOnInit(): void {
    this.tasks = this.taskService.getTasks();
  }
}
```

Давайте разберем, что мы здесь сделали:

1. **Импорт TaskService**: Сначала мы импортировали наш сервис `TaskService`.

2. **Инжектирование в конструктор**: Далее, внутри конструктора компонента, мы указываем Angular инжектировать наш `TaskService`. Теперь у этого компонента есть доступ к методам сервиса.

3. **Использование метода getTasks()**: В методе `ngOnInit()` — это специальный метод, который автоматически вызывается при инициализации компонента — мы получаем задачи из нашего сервиса и сохраняем их в переменной `tasks` компонента.

4. **Вывод задач на экран**: Мы используем Angular директиву `*ngFor`, чтобы перебрать и отобразить список задач в нашем шаблоне компонента.

### Заключение

Мы подробно рассмотрели, как создать и использовать сервисы в Angular, применив их для организации и предоставления данных. Сервисы позволяют создавать модули кода, которые легко тестировать и использовать повторно. В дальнейшем вы узнаете, как сервисы могут взаимодействовать с внешними API и как они играют ключевую роль во взаимодействии компонентов вашего приложения. А пока поэкспериментируйте с созданием своих сервисов и различными способами их использования!

---

# Внедрение зависимостей (DI): Введение в Dependency Injection, providedIn

# Неделя 1: Основы Angular
## Внедрение зависимостей (DI): Введение в Dependency Injection, providedIn

Добро пожаловать в увлекательный мир Angular! Сегодня мы познакомимся с понятием "внедрение зависимостей" (Dependency Injection, DI) и той частью Angular, которая делает внедрение зависимостей таким мощным инструментом для разработки — это `providedIn`.

### Что такое Dependency Injection?

Представьте, что разрабатываете завод, производящий автомобили. Каждый автомобиль нуждается в двигателе. Вместо того чтобы самому создавать или заказывать двигатель каждый раз, когда требуется новый автомобиль (что может быть очень утомительным и неэффективным), у вас есть склад двигателей вместе с командой, которая обеспечивает каждый автомобиль необходимым двигателем.

В программировании мы называем это "внедрением зависимостей". Angular управляет "складом" компонентов и услуг, предоставляя нужный компонент в нужный момент.

### Зачем нужно внедрение зависимостей?

1. **Управляемость**: DI позволяет вам управлять кодом так, чтобы избегать дублирования и сильно связывающих зависимостей. Это облегчает поддержку и тестирование приложения.

2. **Тестирование**: Вы можете легко заменять реальные реализации тестовыми заглушками во время тестирования.

3. **Повторное использование и модульность**: Одни и те же зависимости могут использоваться в разных частях приложения.

### Как это работает в Angular?

В Angular DI реализуется с помощью механизмов сервисов и провайдеров. Перед тем как мы углубимся, давайте разберем основные концепты и как они проявляются в коде.

#### Основы сервисов и провайдеров

Сервис в Angular — это класс, который снабжает данные или логику приложения. Провайдер, с другой стороны, говорит Angular, как создавать экземпляр этого сервиса.

**Пример простого сервиса**

Сначала создадим сервис, который будет предоставлять нам данные о пользователях:

```typescript
// user.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',  // делает сервис доступным для всего приложения
})
export class UserService {
  private users = ['Alice', 'Bob', 'Charlie'];

  getUsers() {
    return this.users;
  }
}
```

**Объяснение:**

- `@Injectable`: Декоратор, который указывает, что класс может быть использован системой DI.
- `providedIn: 'root'`: Указывает на глобальный уровень внедрения через корневой инжектор, что делает сервис доступным в любом месте приложения без дополнительной настройки.

#### Использование сервиса в компоненте

Теперь давайте используем наш `UserService` в компоненте.

```typescript
// app.component.ts
import { Component } from '@angular/core';
import { UserService } from './user.service';

@Component({
  selector: 'app-root',
  template: `<ul>
               <li *ngFor="let user of users">{{ user }}</li>
             </ul>`
})
export class AppComponent {
  users: string[];

  constructor(private userService: UserService) {
    this.users = userService.getUsers();
  }
}
```

**Объяснение:**

- В `constructor()` компонента `AppComponent` мы просим DI-инструмент Angular предоставить экземпляр `UserService`.
- `private userService: UserService` сообщает Angular о зависимости компонента от `UserService`.
- Метод `constructor` затем использует сервис, чтобы получить список пользователей и сохранить их в массив `users`, который используется в шаблоне.

### Почему именно providedIn?

`providedIn: 'root'` делает наш сервис доступным на протяжении всего жизненного цикла приложения. Но что, если вы хотите ограничить область видимости сервиса? `providedIn` также может указывать на модуль, что ограничивает доступ к сервису только тем компонентам, которые расположены внутри этого модуля.

**Пример**

```typescript
@Injectable({
  providedIn: SomeModule  // ограничивает использование сервиса внутри SomeModule
})
export class SomeService {
  // Логика сервиса
}
```

#### Подводим итоги

- **DI (Dependency Injection)** — это подход, который делает архитектуру вашего приложения более гибкой и управляемой.
- **Сервисы** содержат логику или данные и часто используются для взаимодействия с внешними системами.
- **providedIn** в сервисе позволяет легко управлять уровнем видимости и жизненным циклом сервиса в приложении.
  
Сегодня вы познакомились с одной из ключевых особенностей Angular — системой внедрения зависимостей, которая значительно облегчает разработку больших и сложных приложений. В последующих темах мы разберем, как управлять состоянием в приложении, работать с формами и делать другие чудеса с Angular!

---

# Практика использования сервисов: Передача данных между компонентами через сервисы, использование Subject для передачи событий.

## Практика использования сервисов: Передача данных между компонентами через сервисы, использование Subject для передачи событий

Теперь, когда у нас в руках есть базовые навыки работы с Angular, пришло время разобрать интереснейшую функциональность — передачу данных между компонентами. Часто в приложении требуется, чтобы данные могли "путешествовать" среди разных его частей. Основное средство, с помощью которого Angular помогает решать эту задачу, — это **сервисы**. А инструмент, который делает эти пути более гибкими, — **Subject** из библиотеки RxJS. Давайте погрузимся в практику.

### Как создаются и используются сервисы

Сначала давайте создадим простой сервис. Angular CLI предоставит нам всю необходимую магию. Вы можете создать новый сервис, выполнив команду:

```bash
ng generate service data
```

Это создаст файлы `data.service.ts` и `data.service.spec.ts` в вашем проекте. Мы будем работать с `data.service.ts`.

Вот пример базового содержимого файла сервиса:

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private message: string = "Hello from the service!";

  getMessage() {
    return this.message;
  }

  setMessage(newMessage: string) {
    this.message = newMessage;
  }
}
```

### Разбираемся в написанном

1. **`@Injectable()` Декоратор**: Говорит Angular, что этот класс можно инжектировать в другие компоненты или сервисы.
   
2. **Хранение данных**: У нас есть приватное свойство `message`, которое мы можем читать и изменять через геттер и сеттер. Это — миниатюрное хранилище данных.

### Кто и как получает доступ к сервису?

Теперь, когда у нас есть сервис, давайте используем его в компонентах. Для начала создадим два компонента, назовем их `SenderComponent` и `ReceiverComponent`.

1. **SenderComponent** будет изменять данные.
2. **ReceiverComponent** будет отображать данные.

Предположим, что эти компоненты уже созданы:  
```bash
ng generate component sender
ng generate component receiver
```

### Подключаем сервис к компонентам

**SenderComponent:**

```typescript
import { Component } from '@angular/core';
import { DataService } from '../data.service';  // Импортируем созданный сервис

@Component({
  selector: 'app-sender',
  template: `
    <button (click)="changeMessage()">Change Message</button>
  `
})
export class SenderComponent {
  constructor(private dataService: DataService) {}

  changeMessage() {
    this.dataService.setMessage("Hello from Sender Component!");
  }
}
```

**ReceiverComponent:**

```typescript
import { Component, OnInit } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-receiver',
  template: `
    <p>{{ message }}</p>
  `
})
export class ReceiverComponent implements OnInit {
  message: string;

  constructor(private dataService: DataService) {}

  ngOnInit() {
    this.message = this.dataService.getMessage();
  }
}
```

### Аннотации и пояснения

- **Внедрение зависимости**: Заметьте, как мы передаем сервис через конструктор компонента. Angular автоматически "инжектирует" экземпляр нашего сервиса в компонент.
  
- **Обработка данных**: В `SenderComponent` мы изменяем сообщение, в `ReceiverComponent` мы читаем его через сервис.

### Оживляем это с помощью Subject!

Для более динамического взаимодействия, будем использовать `Subject` из RxJS. Это позволяет подписывать компоненты на изменения данных.

Начнем с изменения `DataService`:

```typescript
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private messageSource = new Subject<string>();
  currentMessage = this.messageSource.asObservable();

  changeMessage(message: string) {
    this.messageSource.next(message);
  }
}
```

Теперь Subject служит источником данных, на которые компоненты могут подписываться.

**SenderComponent:**

```typescript
import { Component } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-sender',
  template: `
    <button (click)="changeMessage()">Change Message</button>
  `
})
export class SenderComponent {
  constructor(private dataService: DataService) {}

  changeMessage() {
    this.dataService.changeMessage("Hello from Sender Component with Subject!");
  }
}
```

**ReceiverComponent:**

```typescript
import { Component, OnInit } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-receiver',
  template: `
    <p>{{ message }}</p>
  `
})
export class ReceiverComponent implements OnInit {
  message: string;

  constructor(private dataService: DataService) {}

  ngOnInit() {
    this.dataService.currentMessage.subscribe(message => this.message = message);
  }
}
```

### Объяснение по Step-by-Step

1. **Subject и Observable**: `Subject<string>` позволяет нам передавать строки и подписываться на изменения с помощью `asObservable`.
   
2. **Подписка в компоненте**: В `ReceiverComponent`, мы подписываемся на `currentMessage`, чтобы получать обновления в реальном времени.

3. **Изменение данных**: В `SenderComponent`, мы уведомляем всех слушателей, вызывая `next()` у Subject, что вызывает изменение состояния `currentMessage`.

И вот так, через простые команды и несколько строк кода, мы добавили возможность передачи данных и событий между компонентами. Теперь данные могут "говорить", и компоненты могут "слушать" их изменения. Это приближает нас к созданию более динамичных и сложных приложений с Angular!

---

# Структурные директивы: Практическое использование `*ngIf`, `*ngFor`, `*ngSwitch`.

# Неделя 1: Основы Angular

## Структурные директивы: Практическое использование `*ngIf`, `*ngFor`, `*ngSwitch`

Angular предоставляет нам мощные инструменты для управления отображением элементов на странице — это структурные директивы. Они позволяют изменять структуру DOM, добавлять или удалять элементы в зависимости от определённых условий или данных. Давайте погрузимся в три ключевых директивы: `*ngIf`, `*ngFor` и `*ngSwitch`.

### `*ngIf` — условный рендеринг

Директива `*ngIf` служит для условного отображения элементов в шаблоне на основе булева условия.

Представьте, что у нас есть элемент кнопки «Войти», и мы хотим отображать его только если пользователь не авторизован. 

```html
<!-- app.component.html -->
<button *ngIf="!isLoggedIn">Войти</button>
```

```typescript
// app.component.ts
export class AppComponent {
  isLoggedIn = false;
}
```

В этом примере кнопка будет видна только тогда, когда `isLoggedIn` равно `false`. Когда пользователь авторизуется, `isLoggedIn` станет `true`, и кнопка исчезнет.

### `*ngFor` — итерация по массиву

Директива `*ngFor` позволяет отображать элемент для каждого элемента в массиве. Представьте, что у нас есть список задач, и мы хотим отобразить каждую из них.

```html
<!-- app.component.html -->
<ul>
  <li *ngFor="let task of tasks">
    {{ task }}
  </li>
</ul>
```

```typescript
// app.component.ts
export class AppComponent {
  tasks = ['Завершить проект', 'Прочитать книгу', 'Купить продукты'];
}
```

Здесь для каждого элемента массива `tasks` будет создан новый элемент списка `<li>`, и в него будет вставлено значение каждой задачи. Это отличный способ создать динамические списки, основанные на данных.

### `*ngSwitch` — выборочное отображение

Директива `*ngSwitch` используется для отображения блоков кода в зависимости от выражения. Давайте создадим пример, где в зависимости от дня недели будет отображаться различное приветствие.

```html
<!-- app.component.html -->
<div [ngSwitch]="day">
  <div *ngSwitchCase="'Monday'">Начало новой недели! Продуктивности!</div>
  <div *ngSwitchCase="'Friday'">Ура! Почти выходные!</div>
  <div *ngSwitchDefault>Сегодня обычный день.</div>
</div>
```

```typescript
// app.component.ts
export class AppComponent {
  day = 'Monday';
}
```

В этом коде мы используем `ngSwitch` для управления тем, какой блок `<div>` будет отображаться, в зависимости от значения переменной `day`.

### Практическое задание

Попробуйте самостоятельно реализовать следующий функционал:

1. Создайте массив пользователей, где каждый пользователь имеет свойства `name` и `isActive`.
2. Используйте `*ngFor` для отображения списка имен пользователей.
3. С помощью `*ngIf` рядом с именем пользователя добавьте текст "(Активен)", если `isActive` равно `true`.

Пример реализации:

```typescript
// app.component.ts
export class AppComponent {
  users = [
    { name: 'Анна', isActive: true },
    { name: 'Иван', isActive: false },
    { name: 'Елена', isActive: true }
  ];
}
```

```html
<!-- app.component.html -->
<ul>
  <li *ngFor="let user of users">
    {{ user.name }} <span *ngIf="user.isActive">(Активен)</span>
  </li>
</ul>
```

В этом задании мы используем сразу две директивы, чтобы составить динамический список, который отображает текущий статус пользователей.

## Заключение

Структурные директивы Angular позволяют с лёгкостью манипулировать содержимым страниц на основе условий или данных. Применяя их, вы можете создавать адаптивные и интерактивные приложения, которые меняются в зависимости от условий или пользовательского ввода. Играйтесь с тем, что мы изучили, и не забывайте практиковаться, ведь это лучший способ усвоить материал!

---

# Lazy Loading: Оптимизация приложения с использованием lazy loading для модулей.

# Неделя 2: Углубление в Angular

## Lazy Loading: Оптимизация приложения с использованием lazy loading для модулей

Сегодня мы рассмотрим одну из самых интересных и полезных возможностей Angular — lazy loading, или "ленивая загрузка". Представьте, что вы собираетесь вселиться в огромный дом, но сначала хотите обжить только одну комнату, а потом по мере необходимости добавлять остальные. Lazy loading позволяет применять тот же принцип к вашему приложению!

### Что такое Lazy Loading?

Когда речь идет об Angular-приложениях, "ленивая загрузка" означает подгрузку только тех модулей, которые нужны пользователю прямо сейчас. Это помогает существенно сэкономить трафик и ускорить начальную загрузку приложения. Вместо того чтобы загружать все модули сразу, можно загружать по частям, когда они понадобятся.

### Почему это важно?

1. **Скорость загрузки:** Быстрая загрузка приложения улучшает пользовательский опыт.
   
2. **Скорость работы:** Приложение реагирует быстрее благодаря меньшему объёму сразу загружаемого кода.
   
3. **Экономия трафика:** Это важно для пользователей с ограниченным интернет-соединением.

### Перейдём к практике

#### Структура проекта

Давайте начнем с того, какую структуру проекта может иметь приложение с lazy loading. Предположим, у нас есть приложение, в котором существует несколько крупных функциональных частей: `Home`, `Product`, и `Checkout`.

Здесь мы общими чертами определяем нашу структуру:

```
src
|-- app
    |-- app.module.ts
    |-- app-routing.module.ts
    |-- home
    |   |-- home.module.ts
    |   |-- home.component.ts
    |-- product
    |   |-- product.module.ts
    |   |-- product.component.ts
    |-- checkout
    |   |-- checkout.module.ts
    |   |-- checkout.component.ts
```

#### Настройка Lazy Loading

**1. Создайте модуль для ленивой загрузки**

Допустим, у нас уже есть модули `Home`, `Product` и `Checkout`. Изучим, как настроить lazy loading на примере `ProductModule`.

```typescript
// product.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProductComponent } from './product.component';

@NgModule({
  declarations: [ProductComponent],
  imports: [
    CommonModule
  ]
})
export class ProductModule { }
```

**2. Настройте маршрутизацию для ProductModule**

Создайте модуль с собственными маршрутами — `product-routing.module.ts`.

```typescript
// product-routing.module.ts

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { ProductComponent } from './product.component';

const routes: Routes = [
  { path: '', component: ProductComponent }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class ProductRoutingModule { }
```

Добавьте маршрутизацию в `ProductModule`.

```typescript
// product.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProductComponent } from './product.component';
import { ProductRoutingModule } from './product-routing.module';

@NgModule({
  declarations: [ProductComponent],
  imports: [
    CommonModule,
    ProductRoutingModule // Добавили маршрутизацию
  ]
})
export class ProductModule { }
```

**3. Настройте маршрутизацию приложения с использованием Lazy Loading**

Теперь мы должны обновить маршрутизацию в `AppRoutingModule` для использования lazy loading.

```typescript
// app-routing.module.ts

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: 'home', loadChildren: () => import('./home/home.module').then(m => m.HomeModule) },
  { path: 'product', loadChildren: () => import('./product/product.module').then(m => m.ProductModule) },
  { path: 'checkout', loadChildren: () => import('./checkout/checkout.module').then(m => m.CheckoutModule) },
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: '**', redirectTo: '/home' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

Весело, правда? В этом коде, замечая `loadChildren`, браузер понимает, что нужно подгрузить модуль только по мере необходимости.

### Подводя итог

Теперь, когда вы открываете свое приложение и переходите на `/product`, только тогда подгружается `ProductModule`. До этого он даже не загружался в браузер. Вы таким образом уменьшаете нагрузку на сеть и даёте пользователю гораздо более быстрое взаимодействие с приложением.

Попробуйте также организовать lazy loading для других модулей. Практика — ваш лучший друг в изучении Angular, поэтому экспериментируйте и смотрите, как это повлияет на производительность вашего приложения!

---

# Guards: Использование CanActivate, CanLoad для защиты маршрутов и загрузки модулей.

# Неделя 2: Углубление в Angular

## Guards: Использование CanActivate, CanLoad для защиты маршрутов и загрузки модулей

На второй неделе нашего курса мы будем изучать Guards в Angular. Представьте себе шкаф с книгами, где на некоторых полках стоят самые ценные экземпляры, и доступ к ним имеют только проверенные люди. Guards в Angular работают по тому же принципу: они определяют, можно ли предоставлять доступ к определённым маршрутам или загружать определённые части приложения.

Как эта защита работает в Angular? Мы сейчас это выясним!

### Что такое Guards?

Guards — это специальные функции, которые помогают защищать маршруты (или пути), добавляя различные проверки перед тем, как пользователь получит доступ к ним. Двумя важными типами Guards в Angular являются `CanActivate` и `CanLoad`. Давайте разберём их отдельно.

### CanActivate

`CanActivate` проверяет, можно ли активировать маршрут. Представьте, что у вас есть страница с секретной информацией, и только авторизованные пользователи могут её видеть. Вот где приходит на помощь `CanActivate`.

#### Создание Guard-a

Вот простой пример создания `CanActivate` Guard:

```typescript
// Создаём CanActivate Guard с помощью Angular CLI
// Запустите в терминале: ng generate guard auth

import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor(private router: Router) {}

  canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    
    const isLoggedIn = false; // Это условие вы будете брать из сервиса аутентификации.

    if (isLoggedIn) {
      return true; // Позволяем перейти по маршруту
    } else {
      this.router.navigate(['/login']); // Перенаправляем на страницу входа
      return false; // Блокируем маршрут
    }
  }
  
}
```

**Объяснение:**

- `canActivate` — это метод, который мы должны реализовать. Он возвращает `true`, если доступ к маршруту можно предоставить, и `false` — если нельзя.
- Если пользователь не авторизован, мы перенаправляем его на страницу входа. Это делает метод `this.router.navigate(['/login']);`.

#### Использование CanActivate в маршрутах

Теперь, когда мы создали Guard, добавим его к маршруту:

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { SecretComponent } from './secret/secret.component';
import { AuthGuard } from './auth.guard';

const routes: Routes = [
  { path: 'secret', component: SecretComponent, canActivate: [AuthGuard] },
  // другие маршруты
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

Теперь, если вы попытаетесь перейти по маршруту `/secret`, будет выполнена проверка: запустится наш `AuthGuard`.

### CanLoad

`CanLoad` Guard используется для предотвращения загрузки модуля или части приложения, если проверки не пройдены. Это полезно, когда вы хотите экономить ресурсы и загружать тяжёлые модули только в том случае, если это необходимо.

#### Создание CanLoad Guard

```typescript
// Создаём CanLoad Guard при помощи Angular CLI
// Запустите в терминале: ng generate guard load

import { Injectable } from '@angular/core';
import { CanLoad, Route, UrlSegment, Router } from '@angular/router';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class LoadGuard implements CanLoad {

  constructor(private router: Router) {}

  canLoad(
    route: Route,
    segments: UrlSegment[]): Observable<boolean> | Promise<boolean> | boolean {
      
    const hasPermission = false; // Это условие вы будете брать из сервиса авторизации.

    if (hasPermission) {
      return true; // Разрешаем загрузку модуля
    } else {
      this.router.navigate(['/not-authorized']); // Перенаправляем на страницу ошибки
      return false; // Блокируем загрузку модуля
    }
  }
  
}
```

**Объяснение:**

- `canLoad` — это метод, который принимает информацию о маршруте и сегментах URL. Он определяет, стоит ли загружать модуль.
- Мы проверяем условие `hasPermission` и принимаем решение загружать модуль или нет.

#### Использование CanLoad в маршрутах

Настроим маршруты для использования `CanLoad` Guard:

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { LoadGuard } from './load.guard';

const routes: Routes = [
  { 
    path: 'admin', 
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule), 
    canLoad: [LoadGuard] 
  },
  // другие маршруты
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

При попытке перейти по пути `/admin`, сначала будет выполнена проверка с помощью `LoadGuard`, и только в случае успешной проверки модуль будет загружен.

### Заключение

Guards в Angular — это мощный инструмент, позволяющий вам контролировать доступ к различным частям вашего приложения. `CanActivate` помогает активировать маршрут только для разрешённых пользователей, а `CanLoad` позволяет экономить ресурсы, загружая модули только в случае необходимости. Используя эти Guards, можно создать максимально безопасное и удобное приложение.

На следующем занятии мы продолжим изучать другие возможности Angular, которые сделают ваше приложение ещё более динамичным и интерактивным.

---

# Оптимизация производительности: Практическое применение ChangeDetectionStrategy.OnPush для уменьшения количества проверок изменений.

# Неделя 2: Углубление в Angular

## Оптимизация производительности: Практическое применение ChangeDetectionStrategy.OnPush для уменьшения количества проверок изменений

### Введение

Любое приложение, особенно сложное, нуждается в оптимизации. Angular включает в себя мощную систему проверки изменений, которая следит за обновлением данных и обновляет интерфейс, если данные изменились. Однако, работа этой системы может влиять на производительность, особенно если компонентов много или они очень сложные. На этой неделе мы рассмотрим, как с помощью настройки стратегии обнаружения изменений `ChangeDetectionStrategy.OnPush` можно снизить нагрузку на систему и увеличить производительность приложения.

### Что такое Change Detection в Angular?

Angular автоматически проверяет изменения в данных вашего приложения и обновляет DOM (Document Object Model) в ответ на эти изменения. Этот процесс называется Change Detection (проверка изменений). По умолчанию Angular использует стратегию "проверяй всё", что может привести к ненужным проверкам, если данных и изменений много.

### Знакомимся с OnPush

Стратегия `OnPush` позволяет Angular быть более избирательным в том, когда нужно обновлять компонент. Вместо того чтобы проверять компонент каждый раз, когда в приложении происходит какое-то событие, `OnPush` говорит Angular обновлять компонент только в определённых случаях:

1. Когда изменяются входные (Input) данные компонента.
2. Когда внутри компонента произошло событие (клик пользователя, таймер и т.д.).
3. Когда вызывается асинхронный процесс, например HTTP-запрос.

### Практический пример

Давайте рассмотрим, как можно реализовать `ChangeDetectionStrategy.OnPush` на простом примере.

#### Создание базового компонента

Сначала создадим компонент, который отображает список элементов:

```typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-item-list',
  template: `
    <ul>
      <li *ngFor="let item of items">{{ item }}</li>
    </ul>
  `,
  styles: []
})
export class ItemListComponent {
  @Input() items: string[] = [];
}
```

Этот компонент просто отображает список строковых элементов.

#### Настройка OnPush

Теперь применим `ChangeDetectionStrategy.OnPush` к этому компоненту:

```typescript
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';

@Component({
  selector: 'app-item-list',
  template: `
    <ul>
      <li *ngFor="let item of items">{{ item }}</li>
    </ul>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush,
  styles: []
})
export class ItemListComponent {
  @Input() items: string[] = [];
}
```

С этого момента Angular будет автоматически проверять изменения в этом компоненте только в случае изменения входных данных `items`.

#### Изменение данных

Пример того, как изменения данных теперь влияют на перерисовку:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <app-item-list [items]="items"></app-item-list>
    <button (click)="addItem()">Add Item</button>
  `,
  styles: []
})
export class AppComponent {
  items = ['Apple', 'Banana', 'Orange'];

  addItem() {
    this.items.push('New Item');
    // Здесь данные изменены, однако OnPush не обнаружит изменений из-за того,
    // что изменён ссылочный тип данных (массив), а не его отдельная ссылка.
  }
}
```

Вот критический момент — `addItem()` добавляет элемент в массив, и хотя данные фактически изменились, Angular, используя `OnPush`, не видит этого, потому что ссылка на массив осталась прежней.

#### Решение проблемы

Для того чтобы `OnPush` уловил изменения, необходимо изменить саму ссылку на массив. Это можно сделать так:

```typescript
addItem() {
  this.items = [...this.items, 'New Item'];
  // Теперь Angular уловит изменение, так как ссылка на массив изменилась
}
```

Используя `...this.items`, мы создаём новый массив, тем самым обновляя ссылку объекта. Теперь Angular заметит изменения, и компонент будет обновлён.

### Заключение

Используя `ChangeDetectionStrategy.OnPush`, можно значительно повысить производительность приложения, снижая количество ненужных проверок изменений. Важно помнить при этом о том, как изменяются данные в приложении, и адаптировать код для работы с `OnPush`.

Продолжайте экспериментировать с этой стратегией и отслеживать, как ведёт себя ваш компонент при различных изменениях. Это не только улучшит ваши навыки, но и поможет глубже понять, как работает Angular под капотом.

---

# Мини-проект: Создание многостраничного приложения с анимациями, lazy loading и guard-ами.

## Неделя 2: Углубление в Angular

### Мини-проект: Создание многостраничного приложения с анимациями, lazy loading и guard-ами

На второй неделе нашего курса мы сосредоточимся на создании полноценного многостраничного приложения, используя Angular. Мы рассмотрим, как можно использовать анимации для улучшения пользовательского интерфейса, как настроить lazy loading (ленивую загрузку) для повышения производительности и как защитить маршруты с помощью guard-ов. Давайте начнём!

#### 1. Структура проекта

Создадим небольшое приложение с несколькими страницами: домашнюю, страницу о компании и страницу профиля пользователя. Страница профиля будет защищена guard-ом, чтобы её могли посещать только авторизованные пользователи.

### Анимации

Начнем с анимаций. Они помогают сделать ваше приложение более интерактивным и привлекательным для пользователей. Представьте, как страницы плавно появляются на экране, а кнопки откликаются на ваши действия легкими подрагиваниями.

**Пример: Простая анимация появления**

```typescript
// animations.ts
import { trigger, transition, style, animate } from '@angular/animations';

export const fadeInAnimation = trigger('fadeIn', [
  transition(':enter', [
    style({ opacity: 0 }),
    animate('500ms', style({ opacity: 1 }))
  ]),
  transition(':leave', [
    animate('500ms', style({ opacity: 0 }))
  ])
]);
```

```html
<!-- app.component.html -->
<div [@fadeIn]>
  <router-outlet></router-outlet>
</div>
```

Здесь мы создали простую анимацию, которая управляет видимостью элементов при их появлении и исчезновении.

### Lazy Loading

Теперь давайте разберем lazy loading. Эта техника позволяет загружать части приложения только тогда, когда они действительно нужны, тем самым ускоряя начальную загрузку приложения.

**Пример: Настройка lazy loading для модуля**

1. Создайте модуль для каждой страницы (например, `ProfileModule` для страницы профиля).

```typescript
// profile.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProfileComponent } from './profile.component';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: '', component: ProfileComponent }
];

@NgModule({
  declarations: [ProfileComponent],
  imports: [CommonModule, RouterModule.forChild(routes)]
})
export class ProfileModule {}
```

2. Настройте маршрутизацию, чтобы использовать lazy loading.

```typescript
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  { path: '', loadChildren: () => import('./home/home.module').then(m => m.HomeModule) },
  { path: 'about', loadChildren: () => import('./about/about.module').then(m => m.AboutModule) },
  { path: 'profile', loadChildren: () => import('./profile/profile.module').then(m => m.ProfileModule) } // Lazy loading
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}
```

### Guard-ы

Теперь поговорим о guard-ах, которые помогают контролировать доступ к разным частям приложения. Например, только авторизованные пользователи смогут посещать страницу профиля.

**Пример: Создание guard-а для защиты маршрута**

1. Создайте guard с помощью Angular CLI.

```bash
ng generate guard auth
```

2. Определите логику в guard-е.

```typescript
// auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor(private router: Router) {}

  canActivate(): boolean {
    const isAuthenticated = false; // Здесь должна быть реальная проверка, например через сервис аутентификации
    if (!isAuthenticated) {
      this.router.navigate(['/']);
      return false;
    }
    return true;
  }
}
```

3. Примените guard к маршруту.

```typescript
// app-routing.module.ts
{ path: 'profile', loadChildren: () => import('./profile/profile.module').then(m => m.ProfileModule), canActivate: [AuthGuard] }
```

Теперь наш проект защищает доступ к странице профиля, и она будет загружена только после авторизации.

### Результат

На этой неделе мы сконцентрировались на создании многостраничного приложения в Angular с использованием анимаций для улучшения пользовательского интерфейса, lazy loading для оптимизации загрузки страниц и guard-ов для защиты данных. Это мощные инструменты, которые обязательно пригодятся вам в реальных проектах и при собеседованиях.

Поздравляем с выполнением мини-проекта! Теперь у вас есть базовые навыки в создании более сложных и функциональных приложений на Angular.

---

# Челленджи: «Создайте анимацию переходов между страницами», «Реализуйте lazy loading модуля».

# Неделя 2: Углубление в Angular

### Челленджи: «Создайте анимацию переходов между страницами», «Реализуйте lazy loading модуля»

Добро пожаловать на вторую неделю нашего курса по Angular! На этот раз мы сосредоточимся на двух интересных задачах: создании анимаций для переходов между страницами и реализации ленивой загрузки модулей. Эти способности не только придадут вашему приложению современный вид, но и улучшат производительность, что обязательно впечатлит ваших будущих работодателей.

## Челлендж 1: Создание анимации переходов между страницами

Анимации могут оживить ваше приложение и сделать его более привлекательным для пользователя. В этом упражнении мы создадим простую анимацию, использующую Angular Animations.

### Шаги создания анимации:

1. **Установка Angular Animations:**

   Сначала убедимся, что Angular Animations установлен в вашем проекте. Обычно он уже установлен по умолчанию, но на всякий случай проверьте:

   ```bash
   ng add @angular/animations
   ```

2. **Импорт необходимых модулей:**

   В вашем основном модуле (обычно называется `app.module.ts`) добавьте `BrowserAnimationsModule`:

   ```typescript
   import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

   @NgModule({
     declarations: [/* ваши компоненты */],
     imports: [
       BrowserModule,
       BrowserAnimationsModule, // Добавьте сюда
       RouterModule.forRoot(routes),
     ],
     bootstrap: [AppComponent]
   })
   export class AppModule {}
   ```

3. **Создание анимации в компоненте:**

   Теперь создадим анимацию перехода в одном из ваших компонентов. Например, в компоненте `app.component.ts`:

   ```typescript
   import {
     trigger,
     transition,
     style,
     animate,
     query,
     group
   } from '@angular/animations';

   @Component({
     selector: 'app-root',
     templateUrl: './app.component.html',
     styleUrls: ['./app.component.css'],
     animations: [
       trigger('routeAnimation', [
         transition('* <=> *', [
           query(':enter, :leave', style({ position: 'absolute', width: '100%' }), { optional: true }),
           group([
             query(':enter', [style({ opacity: 0 }), animate('0.5s ease-out', style({ opacity: 1 }))], { optional: true }),
             query(':leave', [style({ opacity: 1 }), animate('0.5s ease-out', style({ opacity: 0 }))], { optional: true })
           ])
         ])
       ])
     ]
   })
   export class AppComponent {}
   ```

   Здесь мы использовали `trigger`, `transition`, `style`, `animate`, `query`, и `group` для создания базовой анимации. 

4. **Применение анимации:**

   Теперь применим наш `routeAnimation` триггер внутри шаблона компонента:

   ```html
   <div [@routeAnimation]="getRouteAnimationState(outlet)">
     <router-outlet #outlet="outlet"></router-outlet>
   </div>
   ```

   Методу `getRouteAnimationState` можно задать возвращение нужного состояния, например, с использованием данных из маршрутизации.

## Челлендж 2: Реализация lazy loading модуля

Ленивая загрузка (lazy loading) помогает уменьшить время загрузки вашего приложения, загружая только необходимые на этот момент модули.

### Шаги для реализации ленивой загрузки:

1. **Создание нового модуля:**

   Давайте сначала создадим новый модуль, который мы будем загружать лениво:

   ```bash
   ng generate module feature
   ```

2. **Создание компонента внутри этого модуля:**

   Создадим компонент, который будет частью этого модуля:

   ```bash
   ng generate component feature/FeatureComponent
   ```

3. **Настройка маршрутов для ленивой загрузки:**

   В файле `app-routing.module.ts` настроим маршруты так, чтобы наш модуль загружался лениво:

   ```typescript
   const routes: Routes = [
     { path: '', redirectTo: '/home', pathMatch: 'full' },
     { path: 'home', component: HomeComponent },
     { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) }
   ];
   ```

   Обратите внимание на `loadChildren`, который указывает, что при обращении к маршруту `'feature'` будет загружен `FeatureModule`.

4. **Настройка маршрутов в модуле ленивой загрузки:**

   В файле `feature-routing.module.ts` определим пути для модуля:

   ```typescript
   const routes: Routes = [
     { path: '', component: FeatureComponent }
   ];

   @NgModule({
     imports: [RouterModule.forChild(routes)],
     exports: [RouterModule]
   })
   export class FeatureRoutingModule {}
   ```

5. **Импортирование модуля:**

   Убедитесь, что в `FeatureModule` импортирован `FeatureRoutingModule`:

   ```typescript
   @NgModule({
     declarations: [FeatureComponent],
     imports: [
       CommonModule,
       FeatureRoutingModule
     ]
   })
   export class FeatureModule {}
   ```

Теперь ваш модуль будет загружаться только при обращении к его маршруту, что делает приложение более легким на старте.

Поздравляю! Вы успешно создали анимацию для переходов между страницами и реализовали ленивую загрузку модуля в вашем приложении на Angular. Оба эти навыка не только улучшат производительность и пользовательский интерфейс ваших приложений, но и произведут впечатление на будущих сотрудников.

Продолжайте экспериментировать и углублять свои знания в Angular! На следующей неделе мы затронем еще более сложные концепции.

---

# Глубокое понимание директив: Работа с ViewContainerRef и TemplateRef.

# Неделя 2: Углубление в Angular

## Глубокое понимание директив: Работа с ViewContainerRef и TemplateRef

Продолжая наше путешествие по Angular, на второй неделе мы сосредоточимся на таком важнейшем аспекте, как директивы. Директивы в Angular позволяют нам менять поведение и внешний вид элементов в DOM. Сегодня мы подробнее разберем, как использовать две мощные возможности Angular — `ViewContainerRef` и `TemplateRef` — для создания динамических интерфейсов.

### Что такое TemplateRef?

Давайте начнем с `TemplateRef`. Представьте себе HTML-шаблон (кусочек DOM), как чертеж дома. Так вот, `TemplateRef` — это ссылка на такой чертеж, который еще не построен, но который вы сможете использовать, чтобы построить дом (в нашем случае — элемент или компонент) в нужный момент и в нужном месте.

```html
<ng-template #myTemplate>
  <p>Эта строка текста появится, когда мы её вставим через код!</p>
</ng-template>
```

В приведенном выше примере у нас есть `ng-template`. То, что находится внутри `<ng-template>`, не появится в DOM, пока мы сами не скажем Angular это сделать. Директива `#myTemplate` дает этому шаблону имя, чтобы мы могли на него ссылаться.

### Что такое ViewContainerRef?

Теперь разберемся с `ViewContainerRef`. Если `TemplateRef` — это чертеж, `ViewContainerRef` — это стройплощадка, готовая принять новый дом. Он отвечает за управление содержимым DOM: добавление, удаление и перестановку динамически созданных компонентов.

### Использование TemplateRef и ViewContainerRef на практике

Давайте посмотрим, как эти две концепции работают вместе с помощью простого примера.

#### Пример

Допустим, у нас есть компонент, который по нажатию кнопки добавляет абзац текста на страницу.

##### HTML (component.html)

```html
<button (click)="addParagraph()">Добавить абзац</button>

<ng-template #dynamicParagraph>
  <p>Это динамически добавленный абзац!</p>
</ng-template>

<div #container></div>
```

При помощи `#dynamicParagraph` мы создаем шаблон для нашего текста и обозначаем его идентификатором. Мы также добавляем `#container` на `<div>`, чтобы указать в какой элемент мы будем вставлять наш шаблон.

##### TypeScript (component.ts)

```typescript
import { Component, ViewChild, TemplateRef, ViewContainerRef } from '@angular/core';

@Component({
  selector: 'app-my-component',
  templateUrl: './component.html',
})
export class MyComponent {
  @ViewChild('dynamicParagraph', { read: TemplateRef }) myTemplate!: TemplateRef<any>;
  @ViewChild('container', { read: ViewContainerRef }) viewContainer!: ViewContainerRef;

  addParagraph() {
    this.viewContainer.createEmbeddedView(this.myTemplate);
  }
}
```

##### Пояснение

1. **Импортируем нужные классы**: Мы импортируем `ViewChild`, `TemplateRef` и `ViewContainerRef` из `@angular/core`. Это позволит нам получить доступ к нашему шаблону и контейнеру.

2. **Использование декоратора `@ViewChild`**: С помощью этого декоратора мы получаем доступ к элементам в шаблоне компонента. Обратите внимание, как мы используем `read: TemplateRef` и `read: ViewContainerRef`, чтобы указать, какого типа объект мы хотим извлечь.

3. **Метод `addParagraph`**: Это действие добавит наш динамический абзац в контейнер с помощью метода `createEmbeddedView()`. Каждый вызов этой функции создаст новый абзац без перезаписи предыдущего.

### Почему это круто?

Этот механизм делает приложение гибким и динамичным. Например, представьте себе онлайн-конструктор страниц. Используя рассказы, подобные этой, пользователь сможет клонировать элементы, изменять порядок их отображения или даже удалять по мере необходимости — и все это без перезагрузки всей страницы!

Продолжим углубляться в директивы на следующих занятиях, ведь именно они привносят в Angular всю ту магию, которая делает его таким популярным и уважаемым инструментом среди разработчиков.

---

# Создание сложных директив: Использование Embedded View для создания сложных структур.

# Неделя 2: Углубление в Angular

## Создание сложных директив: Использование Embedded View для создания сложных структур

Добро пожаловать на вторую неделю нашего курса по Angular! На этой неделе мы сфокусируемся на более сложных аспектах Angular, и начнем с темы директив. В нашем случае речь пойдет о создании сложных директив, использующих встроенные представления, чтобы создавать и управлять сложными структурами шаблона.

### Директивы: Повторение основ

Перед тем как нырнуть в тему Embedded View, вспомним, что директивы в Angular — это классы, которые появляются при помощи декоратора `@Directive`. Они помогают изменять или добавлять поведение HTML-элементов в шаблоне. Есть два типа директив, которые мы уже частично затрагивали:
1. **Атрибутные директивы**, которые изменяют поведение или внешний вид существующих элементов. Пример: изменение цвета текста.
2. **Структурные директивы**, которые изменяют структуру DOM, добавляя или удаляя элементы. Пример: `*ngIf`, `*ngFor`.

Сегодня мы сосредоточимся на создании более сложных механизмов с использованием структурных директив.

### Embedded View: Введение

Embedded View — это способ работы с представлениями, которые нужно динамически вставлять или удалять из DOM. Когда вы используете структурные директивы, такие как `*ngIf`, Angular создает или удаляет Embedded Views, в зависимости от условий.

### Простой пример встроенного представления

Для простоты давайте начнем с создания структурной директивы, которая будет отображать элемент на основе некоторого условия. Это поможет нам понять, как Embedded Views работают под капотом.

Предположим, у нас есть структура, где мы хотим показывать приветственное сообщение только если пользователь вошел в систему.

```typescript
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appIfLogged]'
})
export class IfLoggedDirective {
  private hasView = false;

  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) {}

  @Input() set appIfLogged(condition: boolean) {
    if (condition && !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (!condition && this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}
```

#### Разбор кода

- **TemplateRef**: Ссылается на шаблон (это наш контент внутри `<ng-template>`), который мы можем многократно использовать и рендерить.
- **ViewContainerRef**: Обеспечивает доступ к контейнеру, который может содержать одно или несколько представлений. Мы можем добавлять или удалять представления используя такие методы как `createEmbeddedView` и `clear`.
- **@Input() appIfLogged**: Это директива с настраиваемым входом, которая регулирует условие показа.

#### Пример использования в шаблоне:

```html
<ng-template [appIfLogged]="isLoggedIn">
  <p>Добро пожаловать, пользователь!</p>
</ng-template>
```

### Усложняем сценарий: Директива повторения с условиями сортировки

Теперь создадим директиву, которая позволяет повторять элементы списка с учетом условий сортировки. Мы будем использовать ваше новое знание о Embedded View.

```typescript
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appSortedRepeat]'
})
export class SortedRepeatDirective {
  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) {}

  @Input() set appSortedRepeat(data: any[]) {
    this.viewContainer.clear();

    const sortedData = data.sort((a, b) => a - b);
    
    sortedData.forEach(item => {
      this.viewContainer.createEmbeddedView(this.templateRef, {
        $implicit: item
      });
    });
  }
}
```

#### Разбор кода

- **appSortedRepeat(data: any[])**: Эта директива принимает массив данных, которые будут отсортированы и затем отображены.
- **this.viewContainer.createEmbeddedView**: Каждый элемент добавляется в DOM как часть созданного Embedded View. Параметр `{$implicit: item}` позволяет нам передать текущий элемент неявным образом в контекст шаблона.

#### Пример использования в шаблоне:

```html
<ng-template let-item [appSortedRepeat]="numbersArray">
  <div>
    {{ item }}
  </div>
</ng-template>
```

### Заключение

Embedded View предоставляет мощный и гибкий способ управления сложными элементами на странице. Создание и управление набором динамических представлений может облегчить работу с данными, будь то обработка списков, условное отображение контента или более сложная логика представления.

Практикуйтесь в создании собственных директив, экспериментируя с различными сценариями и условиями. На следующем занятии мы рассмотрим другие возможности Angular, которые помогут вам стать настоящим мастером этого популярного фреймворка!

---

# Асинхронная валидация: Интеграция асинхронных валидаторов в реактивные формы.

# Неделя 2: Углубление в Angular
## Асинхронная валидация: Интеграция асинхронных валидаторов в реактивные формы

Добро пожаловать на вторую неделю нашего путешествия по Angular! На этой неделе мы углубимся в возможности асинхронной валидации в реактивных формах. Представьте, что у вас есть поле ввода в форме, и вы хотите проверить, уникален ли введенный пользователем логин, обращаясь к серверу. Асинхронные валидаторы — ваш лучший друг в таких сценариях.

### Что такое асинхронная валидация?

Асинхронная валидация позволяет выполнять проверки полей формы, которые требуют задержки или взаимодействия с внешними ресурсами, такими как API или базы данных. Это важно, когда ваша валидация включает задания, которые не могут быть мгновенно завершены — например, проверять существование пользователя в базе.

### Введение в реактивные формы

Перед тем как внедрять асинхронные валидаторы, кратко вспомним, как работают реактивные формы. Представьте реактивные формы как "живой" организацию данных, где каждое изменение отслеживается в реальном времени. Это похоже на то, как если бы у вас была тетрадь, которая автоматически исправляет ошибки, когда вы пишете.

### Реализация асинхронного валидатора

Давайте создадим асинхронный валидатор для проверки уникальности имени пользователя. Мы будем использовать Angular сервисы для имитации проверки на сервере.

#### Шаг 1: Создание сервиса

Предположим, у нас есть сервис `UserService`, который проверяет наличие логина:

```typescript
import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { delay } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private existingUsernames = ['admin', 'user', 'guest'];

  checkUsernameNotTaken(username: string): Observable<boolean> {
    const isTaken = this.existingUsernames.includes(username);
    // Симулируем задержку проверки как будто это запрос на сервер
    return of(!isTaken).pipe(delay(1000));
  }
}
```

Здесь мы используем `Observable` из библиотеки RxJS для эмитации асинхронного поведения. Метод `checkUsernameNotTaken` возвращает `false`, если имя пользователя существует.

#### Шаг 2: Создание асинхронного валидатора

Теперь создадим сам валидатор:

```typescript
import { AbstractControl, ValidationErrors } from '@angular/forms';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { UserService } from './user.service';

export class CustomValidators {
  static usernameAsyncValidator(userService: UserService) {
    return (control: AbstractControl): Observable<ValidationErrors | null> => {
      return userService.checkUsernameNotTaken(control.value).pipe(
        map(isNotTaken => (isNotTaken ? null : { usernameTaken: true }))
      );
    };
  }
}
```

Наш валидатор вызывает метод сервиса и преобразует его результат в формат, который понимает Angular — если имя занято, возвращаем объект ошибки `{ usernameTaken: true }`.

#### Шаг 3: Интеграция валидатора в форму

Создадим компонент формы:

```typescript
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { UserService } from './user.service';
import { CustomValidators } from './custom-validators';

@Component({
  selector: 'app-registration-form',
  template: `
    <form [formGroup]="form">
      <label for="username">Username</label>
      <input id="username" formControlName="username" />
      <div *ngIf="form.get('username').hasError('usernameTaken')">
        This username is already taken.
      </div>

      <button [disabled]="form.invalid">Register</button>
    </form>
  `
})
export class RegistrationFormComponent {
  form: FormGroup;

  constructor(private fb: FormBuilder, private userService: UserService) {
    this.form = this.fb.group({
      username: [
        '',
        [Validators.required],
        [CustomValidators.usernameAsyncValidator(this.userService)]
      ]
    });
  }
}
```

Здесь мы создали форму с одним полем для имени пользователя. Мы задали два валидатора: один синхронный `Validators.required` — проверяет, что поле не пустое, и один асинхронный для проверки уникальности имени пользователя.

### Разбираем пример

- **Сервис**: `UserService` имитирует удаленный сервер, который проверяет уникальность имени.
- **Асинхронный валидатор**: `CustomValidators.usernameAsyncValidator` использует `UserService` для проверки и возвращает результат в формате Angular ошибок.
- **Форма**: В компоненте `RegistrationFormComponent`, поле `username` имеет как синхронный, так и асинхронный валидатор. Уведомление об ошибке отображается, когда имя пользователя уже занято.

### Заключение

Асинхронные валидаторы добавляют значительность и гибкость вашим формам, позволяя выполнять сложные проверки с высоким уровнем интерактивности для пользователя. Постарайтесь использовать их в ситуациях, когда необходимо взаимодействие с сервером или выполнение длительных задач. Основываясь на этом, вы можете реализовать валидацию разных сценариев, предоставляя пользователям лучший опыт взаимодействия с вашей формой. Продолжайте экспериментировать и учиться, и увидимся в следующих темах!

---

# Динамические формы: Добавление и удаление элементов формы в реальном времени.

# Неделя 2: Углубление в Angular

## Динамические формы: Добавление и удаление элементов формы в реальном времени

На прошлой неделе мы познакомились с основами Angular и создания форм. Сегодня мы пойдем дальше и поговорим о том, как динамически управлять элементами формы. Это будет полезно, когда вам нужно создать форму, элементы которой могут добавляться или удаляться по запросу пользователя. Imagine you're building a form where a user can add any number of their children's names and ages - the number of fields isn't fixed and can be adjusted.

### Зачем нужны динамические формы?

Динамические формы позволяют вам адаптировать интерфейс вашей программы к нуждам пользователя. Представьте себе форму заявки на участие в каком-то мероприятии, где пользователь может добавлять информацию о своих попутчиках. Количество полей в такой форме неизвестно заранее и может меняться.

### С чего начать?

Чтобы реализовать динамические формы, нам нужно использовать `FormArray`. Это специальный объект в Angular, который позволяет вам управлять коллекцией однотипных элементов формы. Давайте разберем это на примере.

### Создаем нашу форму

Начнем с создания формы, которая будет содержать поля для ввода имени ребенка и возраста.

```typescript
import { Component } from '@angular/core';
import { FormGroup, FormBuilder, FormArray, Validators } from '@angular/forms';

@Component({
  selector: 'app-dynamic-form',
  templateUrl: './dynamic-form.component.html',
  styleUrls: ['./dynamic-form.component.css']
})
export class DynamicFormComponent {
  parentForm: FormGroup;

  constructor(private fb: FormBuilder) {
    this.parentForm = this.fb.group({
      children: this.fb.array([])  // Это FormArray, который хранит наши динамические формы
    });
  }

  get children() {
    return this.parentForm.get('children') as FormArray;
  }

  addChild() {
    const childForm = this.fb.group({
      name: ['', Validators.required],
      age: ['', Validators.required]
    });

    this.children.push(childForm);
  }

  removeChild(index: number) {
    this.children.removeAt(index);
  }

  submit() {
    console.log(this.parentForm.value);
  }
}
```

### Разберем пример

- **FormGroup**: Экземпляр нашей основной формы, содержащей массив детей (`children`).

- **FormArray**: Это массив, в котором хранятся все формы, представляющие каждого ребенка. Каждая такая форма имеет два поля: `name` и `age`.

- **FormBuilder**: Удобный инструмент для построения сложных форм. Здесь мы используем его для создания `FormGroup` и `FormArray`.

- **Методы**:
  - `addChild()`: Создает новую форму ребенка и добавляет ее в `FormArray`.
  - `removeChild(index: number)`: Удаляет форму ребенка по указанному индексу.
  - `submit()`: Пока просто выводит значения формы в консоль.

### Создаем HTML шаблон

Теперь добавим интерфейс для нашего компонента. В нем нужно будет отобразить кнопку добавления нового ребенка и сами инпуты, которые пользователь будет заполнять.

```html
<div [formGroup]="parentForm">
  <div formArrayName="children">
    <div *ngFor="let child of children.controls; let i = index" [formGroupName]="i">
      <input formControlName="name" placeholder="Name" />
      <input formControlName="age" placeholder="Age" />
      <button (click)="removeChild(i)">Remove</button>
    </div>
  </div>
  <button (click)="addChild()">Add Child</button>
  <button (click)="submit()">Submit</button>
</div>
```

### Объяснение HTML

- **formArrayName** и **formGroupName**: Используются для указания связи между шаблоном и данными формы.

- **ngFor**: Директива Angular, которая создает шаблон для каждого ребенка в массиве `children`.

- **formControlName**: Имя каждого отдельного поля в одном из `FormGroup`.

### Подводим итоги

Теперь у нас есть форма, к которой можно легко добавлять и из которой можно удалять элементы без полной перезагрузки данных. Мы используем мощь `FormArray`, чтобы управлять коллекцией однотипных форм в Angular. 

Поэкспериментируйте с созданием собственного компонента, добавлением другой логики валидации и разделением форм по частям. Это также отличная подготовка к собеседованиям, так как формы — одна из частых тем вопросов на них.

Не забывайте сохранять и пробовать новый код: лучшая теория все равно не заменит практику.

---

# FormArray

## Неделя 2: Углубление в Angular

### FormArray

На этой неделе мы продолжаем расширять наше понимание структур данных в Angular, и сегодня поговорим о таком полезном инструменте, как `FormArray`. Представьте, что вам нужно работать с динамическим количеством форм, например, список контактов или задачи на день. `FormArray` — это такая "умная коллекция" из форм-контролов, которая позволяет вам управлять списком форм-элементов. Это мощный инструмент, который упрощает создание динамических форм.

#### Зачем нужен FormArray?

Иногда, когда вы создаёте форму, вы не можете заранее знать, сколько полей нужно пользователю, так как их количество может меняться. Например, представьте, что создаёте форму регистрации участников мероприятия, где каждый участник может добавить несколько телефонов для связи. С `FormArray` мы можем динамически добавлять и удалять эти поля.

#### Создание простого FormArray

Первое, что нам нужно сделать, это установить Angular Reactive Forms, если вы этого ещё не сделали:

```bash
ng add @angular/forms
```

Теперь мы можем перейти к созданию нашего `FormArray`.

```typescript
import { Component } from '@angular/core';
import { FormArray, FormBuilder, FormGroup, Validators } from '@angular/forms';

@Component({
  selector: 'app-phone-numbers',
  templateUrl: './phone-numbers.component.html'
})
export class PhoneNumbersComponent {
  phoneForm: FormGroup;

  constructor(private fb: FormBuilder) {
    this.phoneForm = this.fb.group({
      phones: this.fb.array([
        this.fb.control('', Validators.required)
      ])
    });
  }

  get phones() {
    return this.phoneForm.get('phones') as FormArray;
  }

  addPhone() {
    this.phones.push(this.fb.control('', Validators.required));
  }

  removePhone(index: number) {
    this.phones.removeAt(index);
  }

  onSubmit() {
    console.log(this.phoneForm.value);
  }
}
```

Давайте разберём код, чтобы понять, как всё работает:

- **FormBuilder:** Используется для упрощения создания форм. Мы используем его для создания `FormGroup` и `FormArray`.
- **FormArray:** Представляет собой массив `FormControl`, с которым мы можем работать как с обычным массивом.
- **addPhone():** Метод добавляет новое поле ввода для номера телефона в `FormArray`.
- **removePhone(index: number):** Метод для удаления определённого поля из `FormArray` по индексу.
- **onSubmit():** Обработка данных формы — в данном случае просто вывод в консоль.

#### HTML-шаблон

Теперь, когда мы создали базовую форму, давайте сделаем её функциональной с помощью HTML.

```html
<form [formGroup]="phoneForm" (ngSubmit)="onSubmit()">
  <div formArrayName="phones">
    <div *ngFor="let phone of phones.controls; let i=index">
      <input [formControlName]="i" placeholder="Введите номер телефона" />
      <button type="button" (click)="removePhone(i)">Удалить</button>
    </div>
  </div>
  <button type="button" (click)="addPhone()">Добавить телефон</button>
  <button type="submit">Отправить</button>
</form>
```

#### Разберём HTML:

- **formArrayName="phones":** Определяет, что все элементы внутри будут использовать `FormArray`.
- ***ngFor:** Перебирает все контролы в массиве и предоставляет доступ к каждому через `i`.
- **[formControlName]="i":** Связываем каждый input элемент с соответствующим контролом в `FormArray`.
  
### Подробнее о валидации

Каждый `FormControl` внутри `FormArray` может иметь свои собственные валидаторы. Например, для телефонных номеров вы могли бы добавить валидацию на соответствие определённому шаблону.

```typescript
this.phoneForm = this.fb.group({
  phones: this.fb.array([
    this.fb.control('', [Validators.required, Validators.pattern(/^\d+$/)])
  ])
});
```

### Итог

С `FormArray` вы можете создавать более интерактивные и гибкие формы. Это удобно, когда вы работаете с данными, структурированными в виде списков, которые могут изменяться на лету. Практика — ключ к успеху, поэтому создайте несколько форм с `FormArray` и попробуйте поработать с их элементами, добавляя и удаляя поля. Это значительно улучшит ваши навыки работы с формами в Angular.

---

# Основы Angular animations: Создание базовых анимаций с использованием trigger, state, transition.

# Неделя 2: Углубление в Angular

## Основы Angular animations: Создание базовых анимаций с использованием `trigger`, `state`, `transition`

Создание приятных глазу анимаций стало важной частью разработки современных веб-приложений. Они помогают менять состояния элементов интерфейса так, чтобы это было плавно и незаметно для пользователя. Сегодня мы узнаем, как в Angular можно создать базовые анимации, используя такие инструменты, как `trigger`, `state`, и `transition`.

### Зачем нужны анимации в веб-приложениях?

Анимации помогают пользователям ориентироваться в вашем приложении. Они делают интерфейс более живым и отзывчивым. Например, когда вы добавляете элемент в список, анимация может подчеркнуть это событие, плавно изменив размер добавленного элемента. Без анимаций интерфейс может казаться "жестким", "плоским" и менее удобным.

### Основные элементы анимации в Angular

- **trigger** — это "триггер" для анимации. Он связывает анимации с элементом HTML.
- **state** — определяет конкретное состояние элемента. Например, элемент может быть в состоянии "видимый" или "скрытый".
- **transition** — задаёт, как элементы переходят из одного состояния в другое. Например, анимация от "видимого" к "скрытому" состоянию может происходить с ожиданием или изменением прозрачности.

### Практическое использование 

Давайте начнем с базового примера. Мы создадим элемент, который будет плавно появляться и исчезать.

#### Шаг 1: Добавление Angular animations

Убедитесь, что вы добавили поддержку анимаций в ваше Angular-приложение. Обычно это делается во время создания нового проекта, но если вы этого не сделали, добавьте анимации с помощью Angular CLI:

```bash
ng add @angular/animations
```

#### Шаг 2: Создание компонента

Создадим новый компонент и назовем его `fade-toggle`.
```bash
ng generate component fade-toggle
```

Теперь откройте файл `fade-toggle.component.ts` и импортируйте методы и классы для анимаций.

```typescript
import { Component } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations';

@Component({
  selector: 'app-fade-toggle',
  templateUrl: './fade-toggle.component.html',
  styleUrls: ['./fade-toggle.component.css'],
  animations: [
    trigger('fade', [
      state('visible', style({
        opacity: 1,
      })),
      state('hidden', style({
        opacity: 0,
      })),
      transition('visible <=> hidden', [
        animate('0.5s ease-in-out')
      ]),
    ])
  ]
})
export class FadeToggleComponent {
  fadeState = 'visible';

  toggle() {
    this.fadeState = this.fadeState === 'visible' ? 'hidden' : 'visible';
  }
}
```

В этом коде мы создаём анимацию с именем `fade`, используя `trigger`. У нас есть два состояния: `visible`, где элемент полностью виден (opacity: 1), и `hidden`, где элемент невидим (opacity: 0). Переход между состояниями `visible` и `hidden` происходит за полсекунды (`0.5s`) с эффектом `ease-in-out`.

#### Шаг 3: Шаблон и функциональность

Откройте `fade-toggle.component.html` и добавьте следующий код:

```html
<div [@fade]="fadeState" class="fade-box">
  Hello, Angular Animations!
</div>
<button (click)="toggle()">Toggle Fade</button>
```

Здесь мы связали наш `div` с триггером `fade` и управляли его состоянием через переменную `fadeState`.

#### Шаг 4: Стилизация

Теперь откройте файл `fade-toggle.component.css` и добавьте стили для нашего `div`.

```css
.fade-box {
  width: 200px;
  height: 100px;
  background-color: lightcoral;
  text-align: center;
  line-height: 100px;
  margin: 10px auto;
  color: white;
  font-weight: bold;
}
```

### Структура анимации и работа с параметрами

Обратите внимание, что в аниматоре Angular мы можем использовать параметры для анимаций, чтобы сделать их более гибкими. Например, в `animate()` можно указать время выполнения как параметр:

```typescript
animate('{{duration}}', { params: { duration: '1s' } })
```

### Реальные примеры использования

Анимации часто используются для таких эффектов, как:

- Плавное открытие и закрытие элементов (например, аккордеон или боковая панель).
- Анимации при добавлении или удалении элементов из DOM.
- Обратная связь пользователя на выполнение каких-либо действий (например, кнопка, которая слегка изменяет цвет или размер при нажатии).

### Практическое задание

Для закрепления материала попробуйте:

1. Изменить длительность анимации в нашем примере на 1 секунду.
2. Создать новый анимированный элемент, который изменяет размер при появлении и исчезновении.
3. Добавить к нашему примеру ещё одно состояние, например, чтобы элемент становился полупрозрачным в новом состоянии.

### Вывод

Используя анимации, вы можете значительно повысить качество взаимодействия пользователей с вашим приложением. Анимации помогают сделать интерфейс более динамичным и интуитивно понятным. На этом уроке нам удалось познакомиться с основами Angular анимаций, попробуйте внедрить их в свои проекты!

---

# Сложные анимации: Анимация элементов при добавлении/удалении из DOM.

### Неделя 2: Углубление в Angular

#### Сложные анимации: Анимация элементов при добавлении/удалении из DOM

Добро пожаловать в новую неделю нашего увлекательного путешествия по Angular! На этом этапе мы погрузимся в особенности анимаций, и научимся оживлять наши веб-приложения, добавляя плавные переходы при добавлении или удалении элементов из DOM.

Представьте, что у вас есть список дел, и вы хотите, чтобы при удалении элемента он постепенно исчезал, вместо того чтобы просто мгновенно пропадать. Это возможно благодаря Angular-анимациям.

### Подготовка

Прежде чем начать, убедитесь, что вы импортировали модуль для работы с анимациями. Обычно это делается в файле `app.module.ts`:

```typescript
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

@NgModule({
  declarations: [
    // ваши компоненты
  ],
  imports: [
    BrowserAnimationsModule, // добавляем модуль анимаций
    // другие модули
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### Создаем анимации для элементов

Когда речь идет о добавлении или удалении элементов, такие анимации чаще всего определяются в самом компоненте, где располагается ваша логика. Давайте рассмотрим пример.

#### Пример добавления анимации

Допустим, у нас есть компонент, который отображает список задач. Мы хотим, чтобы задачи появлялись с плавным увеличением, а исчезали с постепенным уменьшением.

```typescript
import { Component } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations';

@Component({
  selector: 'app-task-list',
  template: `
    <ul>
      <li *ngFor="let task of tasks" [@taskAnimation] (click)="removeTask(task)">
        {{ task }}
      </li>
    </ul>
    <button (click)="addTask()">Добавить задачу</button>
  `,
  styles: [`
    ul {
      list-style-type: none;
      padding: 0;
    }
    li {
      padding: 8px;
      margin: 4px 0;
      background-color: #f1f1f1;
      cursor: pointer;
    }
  `],
  animations: [
    trigger('taskAnimation', [
      transition(':enter', [
        style({ transform: 'scale(0.8)', opacity: 0 }),
        animate('300ms ease-out', style({ transform: 'scale(1)', opacity: 1 }))
      ]),
      transition(':leave', [
        animate('300ms ease-in', style({ transform: 'scale(0.8)', opacity: 0 }))
      ])
    ])
  ]
})
export class TaskListComponent {
  tasks = ['Задача 1', 'Задача 2', 'Задача 3'];

  addTask() {
    this.tasks.push(`Новая задача ${this.tasks.length + 1}`);
  }

  removeTask(task: string) {
    this.tasks = this.tasks.filter(t => t !== task);
  }
}
```

##### Объяснение

1. **Анимационные триггеры**: Мы создаем триггер `taskAnimation` и указываем, какие анимации будут применяться к элементам при их входе и выходе из DOM.

2. **:enter и :leave**: Эти специальные состояния используются для определения, как должны анимироваться элементы при их добавлении или удалении.

   - **:enter** — когда элемент добавляется в DOM, мы задаем начальное состояние с уменьшенным масштабом и нулевой прозрачностью. Затем с помощью `animate` перемещаем его в нормальный размер и полную видимость.
   
   - **:leave** — когда элемент удаляется из DOM, мы уменьшаем его масштаб и делаем прозрачным в течение 300 миллисекунд.

3. **Компонент**: У нас есть простой список задач. В шаблоне мы используем директиву `*ngFor`, чтобы отобразить список, и привязываем к элементу список анимацию с помощью `[@taskAnimation]`.

4. **Кнопки добавления и удаления задач**: Кнопка `добавить задачу` добавляет новый элемент в массив задач, а клик по задаче удаляет её.

### Практические советы

- **Экспериментируйте с временем анимации (например, `300ms`, `500ms`) и функциями временной шкалы (например, `ease-in`, `ease-out`, `linear`)**, чтобы добиться наилучшего визуального эффекта.
  
- **Обрабатывайте состояние приложения с учётом анимаций**, особенно если ваши анимации сложные, чтобы избежать проблем с производительностью.

- **Проверяйте анимации на разных устройствах**, чтобы убедиться, что они выглядят одинаково хорошо как на настольных компьютерах, так и на мобильных устройствах.

Теперь вы знаете, как оживить ваши списки в Angular с помощью анимаций. Попробуйте добавить анимации в свои проекты и наблюдайте, как ваши интерфейсы становятся более интерактивными и плавными!

---

# Advanced RxJS operators: switchMap, exhaustMap, mergeMap, concatMap – разбор разницы между операторами.

# Неделя 2: Углубление в Angular

## Advanced RxJS Operators: switchMap, exhaustMap, mergeMap, concatMap – Разбор Разницы между Операторами

Добро пожаловать в нашу увлекательную вторую неделю изучения Angular! На этой неделе мы сосредоточимся на более сложных концепциях, которые дадут вам глубокое понимание, позволяя вам создавать более мощные и отзывчивые приложения.

Сегодня мы рассмотрим различные операторы RxJS: `switchMap`, `exhaustMap`, `mergeMap` и `concatMap`. Эти инструменты позволяют управлять потоками данных и преобразовывать их в Angular-приложениях. Понимание отличий между этими операторами крайне важно для эффективного построения реактивных программ, чтобы ваши приложения чувствовали себя быстрыми и отзывчивыми.

### Почему RxJS Операторы Важны?

В Angular, многие аспекты работы связаны с асинхронными событиями (например, HTTP запросы или пользовательские взаимодействия). RxJS предлагает операторы, позволяющие работать с этими потоками данных элегантно и просто.

Когда вы работаете с потоками, часто возникает необходимость преобразовать один поток в другой. Это где операторы, такие как `switchMap`, `exhaustMap`, `mergeMap` и `concatMap`, вступают в игру. Давайте разберем каждый из них.

### 1. switchMap

**Пример**

Рассмотрим пример с функцией поиска, где пользователь вводит текст, и мы выполняем HTTP-запрос после каждой изменения:

```typescript
import { fromEvent, of } from 'rxjs';
import { debounceTime, map, switchMap } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';

const input = document.getElementById('search-input');

fromEvent(input, 'input').pipe(
  debounceTime(300), // Ждем 300 мс после последнего события
  map(event => (event.target as HTMLInputElement).value),
  switchMap(searchTerm =>
    ajax.getJSON(`https://api.example.com/search?q=${searchTerm}`)
  )
).subscribe(response => {
  console.log(response);
});
```

**Объяснение**

- **`switchMap`** работает так: при поступлении нового значения он автоматически отменяет предыдущий запрос и начинает новый. Это полезно, если вы хотите дать пользователю возможность прерывать старые запросы.

### 2. mergeMap

**Пример**

Посмотрим на пример загрузки нескольких файлов, где все загрузки могут происходить параллельно:

```typescript
import { from } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

const uploads = ['file1.jpg', 'file2.jpg', 'file3.jpg'];

from(uploads).pipe(
  mergeMap(fileName =>
    ajax.post(`https://api.example.com/upload`, { fileName })
  )
).subscribe(response => {
  console.log(response);
});
```

**Объяснение**

- **`mergeMap`** обеспечивает выполнение нескольких потоков параллельно, не дожидаясь завершения предыдущих. Это идеально подходит для сценариев, где порядок выполнения не имеет значения, и вы хотите высокой производительности.

### 3. concatMap

**Пример**

Теперь рассмотрим обработку нескольких задач последовательно. Например, загрузка изображений по очереди:

```typescript
import { from } from 'rxjs';
import { concatMap } from 'rxjs/operators';

const tasks = ['task1', 'task2', 'task3'];

from(tasks).pipe(
  concatMap(task =>
    ajax.getJSON(`https://api.example.com/process?task=${task}`)
  )
).subscribe(response => {
  console.log(response);
});
```

**Объяснение**

- **`concatMap`** обработает каждый элемент входного потока по одному, дожидаясь завершения перед переходом к следующему. Это важно в ситуациях, когда порядок выполнения важен.

### 4. exhaustMap

**Пример**

Представьте форму, где вы хотите предотвратить многократное нажатие кнопки (например, отправка данных формы) до завершения предыдущего:

```typescript
import { fromEvent } from 'rxjs';
import { exhaustMap } from 'rxjs/operators';

const button = document.getElementById('submit-button');

fromEvent(button, 'click').pipe(
  exhaustMap(() =>
    ajax.post('https://api.example.com/submit', { data: 'form data' })
  )
).subscribe(response => {
  console.log(response);
});
```

**Объяснение**

- **`exhaustMap`** сводит к минимуму повторные выполнения: как только запускается выполнение потока, все последующие входящие значения игнорируются до завершения текущего.

### Сравнительная Таблица

| Оператор   | Поведение                                                      | Применение                                                               |
|------------|----------------------------------------------------------------|--------------------------------------------------------------------------|
| switchMap  | Переключается и отменяет предыдущий поток при новом значении.  | Поиск, где важны последние результаты поискового запроса.                |
| mergeMap   | Обрабатывает множество потоков параллельно.                    | Загрузка медиафайлов параллельно.                                        |
| concatMap  | Обрабатывает потоки последовательно, дожидаясь окончания.      | Запросы, где важна последовательность (например, обработка платежей).    |
| exhaustMap | Игнорирует новые значения, пока работает текущий поток.        | Предотвращение многократного срабатывания событий, таких как нажатие кнопки. |

Освоение этих операторов поможет вам уверенно работать с реактивным программированием. Попробуйте поэкспериментировать с каждым оператором на практике, чтобы лучше понять их поведение в различных сценариях.

На этом мы завершаем сегодняшний урок. Убедитесь, что вы практикуетесь и экспериментируете с примерами кода, чтобы закрепить материал. В следующий раз мы продолжим изучать другие ключевые аспекты Angular, которые помогут вам стать мастером в этом мощном фреймворке.

---

# Комбинирование потоков: Практическое использование forkJoin, combineLatest, merge, zip, race.

# Неделя 2: Углубление в Angular

## Комбинирование потоков: Практическое использование forkJoin, combineLatest, merge, zip, race

Наша вторая неделя обучения в Angular посвящена важной теме — потокам данных и их комбинированию. В современных веб-приложениях важно уметь работать с множественными источниками данных одновременно. Сегодня мы рассмотрим несколько полезных операторов RxJS, которые помогут комбинировать потоки данных в Angular: `forkJoin`, `combineLatest`, `merge`, `zip`, и `race`.

### Понимание потоков

Представьте, что потоки данных — это магические трубы, по которым текут данные. Иногда из нескольких таких труб нам нужно сделать одну большую реку, объединяя их данные. В других случаях – возможно, наоборот, объединить потоки так, чтобы данные из них начинали течь одновременно, или определить победителя среди потоков. RxJS дает нам инструменты для этого.

### forkJoin

Начнем с `forkJoin`. Он похож на команду из фильма, в которых разные супергерои борются с противником – каждый действует самостоятельно, но в итоге они объединяют свои усилия, чтобы одержать победу.

#### Пример кода:

```typescript
import { forkJoin, of } from 'rxjs';
import { delay } from 'rxjs/operators';

// Представьте, что это три независимых запроса
const stream1 = of('Данные из первого потока').pipe(delay(2000)); // 2 секунды задержки
const stream2 = of('Данные из второго потока').pipe(delay(4000)); // 4 секунды задержки
const stream3 = of('Данные из третьего потока').pipe(delay(3000)); // 3 секунды задержки

forkJoin([stream1, stream2, stream3]).subscribe(([result1, result2, result3]) => {
  console.log('Результаты всех потоков получили:', result1, result2, result3);
});
```

#### Объяснение:

- `forkJoin` ждёт завершения всех переданных потоков и только потом возвращает массив из результатов. Он идеально подходит для случаев, когда все данные должны быть собраны, прежде чем выполнить хотя бы одно действие.

### combineLatest

Теперь представим `combineLatest` как кулинарную мастерскую: нам нужны все ингредиенты (данные), чтобы создать вкусное блюдо, но начинать можно сразу, как только поступит первый из последних обновлённых продуктов.

#### Пример кода:

```typescript
import { combineLatest, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const tempStream = of('Температура: 20°C').pipe(delay(1000));
const humidityStream = of('Влажность: 50%').pipe(delay(2000));

combineLatest([tempStream, humidityStream]).subscribe(([temp, humidity]) => {
  console.log(`Последние данные - ${temp}, ${humidity}`);
});
```

#### Объяснение:

- `combineLatest` комбинирует потоки, выдавая последние полученные значения. Если обновляется один из потоков, вы получаете обновлённые данные обоих потоков. Это похоже на дежурное обновление статуса температуры и влажности.

### merge

Теперь представьте `merge` как людей, входящих в один зал с разных входов. Они приходят хаотично, и мы хотим, чтобы они просто все оказались в одном месте.

#### Пример кода:

```typescript
import { merge, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const streamA = of('A1').pipe(delay(1000));
const streamB = of('B1').pipe(delay(500));
const streamC = of('C1').pipe(delay(1500));

merge(streamA, streamB, streamC).subscribe(result => {
  console.log(`Получено: ${result}`);
});
```

#### Объяснение:

- `merge` комбинирует потоки, и вы получаете данные с любого входящего потока по мере его поступления. Независимо от порядка завершения, все данные зайдут через одну дверь и вы увидите их в том порядке, как они прибывают.

### zip

`zip` похож на партнерский танец, где каждая пара ожидает первого движения партнера, чтобы ветвиться дальше вместе.

#### Пример кода:

```typescript
import { zip, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const streamX = of('X').pipe(delay(1000));
const streamY = of('Y').pipe(delay(1500));
const streamZ = of('Z').pipe(delay(2000));

zip(streamX, streamY, streamZ).subscribe(([x, y, z]) => {
  console.log(`Каждое значение связано: ${x}, ${y}, ${z}`);
});
```

#### Объяснение:

- `zip` объединяет потоки по парам, ожидая, когда каждый из них готов. Результат получится, когда все потоки обеспечат по одному значению. Это может пригодиться для синхронизации одновременных данных.

### race

`race` похож на соревнование, в котором выигрывает самый быстрый – поток, завершивший первым свои данные, чтобы перейти на следующий этап.

#### Пример кода:

```typescript
import { race, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const streamAlpha = of('Alpha!').pipe(delay(2000));
const streamBeta = of('Beta!').pipe(delay(1000));

race(streamAlpha, streamBeta).subscribe(winner => {
  console.log(`Победителем стал: ${winner}`);
});
```

#### Объяснение:

- `race` выбирает и публикует результат первого завершившегося потока. Сразу при финише одного из потоков, последующие данные других потоков отбрасываются.

### Практика и примеры в реальном приложении

Теперь, когда вы познакомились с основными инструментами, давайте применим их в контексте реального приложения. Представьте себе, что мы создаем информационную панель, которая должна отображать данные о погоде, состоянии здоровья (например, пульс) и новостях.

#### Реальный пример:

```typescript
import { forkJoin, of, combineLatest, merge, zip, race } from 'rxjs';
import { delay } from 'rxjs/operators';

const weatherApiCall = of('Погода: солнечно, 25°C').pipe(delay(1500));
const healthApiCall = of('Пульс: 72 bpm').pipe(delay(2000));
const newsApiCall = of('Новости: Новое обновление Angular!').pipe(delay(2500));

// Обработаем все данные до вывода
forkJoin([weatherApiCall, healthApiCall, newsApiCall]).subscribe(([weather, health, news]) => {
  console.log(`Все данные готовы: \n${weather}\n${health}\n${news}`);
});

// Обновляем информацию на табло
combineLatest([weatherApiCall, healthApiCall]).subscribe(([weather, health]) => {
  console.log(`Текущая информация: \n${weather}\n${health}`);
});

// Новости могут приходить в разное время
merge(healthApiCall, newsApiCall).subscribe(data => {
  console.log(`Обновление: ${data}`);
});

// Должны получить все данные одновременно
zip(weatherApiCall, healthApiCall, newsApiCall).subscribe(([weather, health, news]) => {
  console.log(`Синхронизированные данные: \n${weather}\n${health}\n${news}`);
});

// Начнем обработку с первого изменившегося источника
race(weatherApiCall, healthApiCall, newsApiCall).subscribe(first => {
  console.log(`Первый ответ: ${first}`);
});
```

Используйте подобные примеры и эксперименты с кодом для лучшего запоминания. Ощути всю магию RxJS в работе, комбинируя данные в реальном времени для вашего Angular-приложения!

---

# Практическая работа с RxJS: Построение простых асинхронных потоков.

## Неделя 3: Резюме и практика  
### Практическая работа с RxJS: Построение простых асинхронных потоков

На этой неделе мы погрузимся в RxJS — библиотеку, которая поможет вам управлять асинхронными потоками данных в Angular. Если сейчас это звучит сложно, не беспокойтесь, мы разберем концепции на простых и понятных примерах.

### Что такое RxJS?

Представьте, что данные — это вода, текущая по трубам. RxJS помогает нам управлять этой водой: перенаправлять её, фильтровать и трансформировать, чтобы получить нужный результат. В дождливый день капли дождя, стеклянные окна и водосточные трубы создают асинхронные потоки событий. Также и в веб-приложениях: нажатия кнопок, ввод текста и загрузка данных — всё это события, с которыми нам нужно работать. RxJS делает эту работу более организованной.

### Основные понятия RxJS

1. **Observable (Наблюдаемый):** это поток данных — цепочка событий, на которые мы можем подписаться и обрабатывать.
  
2. **Observer (Наблюдатель):** это тот, кто следит за Observable и реагирует на каждое событие.

3. **Operators (Операторы):** с их помощью мы можем преобразовывать данные внутри Observable. Представьте, что это фильтры и трубы на водопроводе, которые меняют поток воды.

4. **Subscription (Подписка):** когда наблюдатель подписывается на Observable, он начинает получать данные.

### Создание своего первого Observable

Давайте начнем с простого примера. Создадим Observable, который будет передавать числа:

```javascript
import { Observable } from 'rxjs';

// Создаем Observable, который говорит "Привет!"
const numberObservable = new Observable(observer => {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  observer.complete(); // Завершаем поток
});

// Подписываемся на наш Observable
numberObservable.subscribe({
  next: value => console.log(`Получено число: ${value}`),
  complete: () => console.log('Поток завершен')
});
```

#### Пояснение:

- **Observable:** Мы создаем новый поток данных, который передает числа 1, 2 и 3.
- **Observer:** Это набор функций, которые определяют, что делать с каждым новым значением (`next`) и что делать, когда поток завершится (`complete`).
- **Подписка:** Мы подписываемся на обновления от `numberObservable`, чтобы обработать приходящие значения.

### Применение операторов

RxJS предоставляет множество операторов для работы с потоками данных. Рассмотрим использование `map`, который используется для трансформации данных.

```javascript
import { map } from 'rxjs/operators';

// Преобразуем данные в нашем Observable
const transformedObservable = numberObservable.pipe(
  map(value => value * 10) // Умножаем каждое число на 10
);

transformedObservable.subscribe({
  next: value => console.log(`Преобразованное число: ${value}`),
  complete: () => console.log('Поток завершен')
});
```

#### Пояснение:

- **pipe:** Мы используем метод `pipe`, чтобы применить к Observable операторы.
- **map:** Этот оператор принимает каждое значение и возвращает новое, умноженное на 10.

### Практическое применение: запросы к серверу

С помощью RxJS мы можем легко обрабатывать асинхронные запросы данных, например, по API. Используем Angular HttpClient и RxJS вместе.

```typescript
import { HttpClient } from '@angular/common/http';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-data-fetcher',
  template: `<div *ngFor="let user of users">{{ user.name }}</div>`
})
export class DataFetcherComponent implements OnInit {
  users: any[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    this.http.get<any[]>('https://jsonplaceholder.typicode.com/users')
      .subscribe(data => {
        this.users = data;
      });
  }
}
```

#### Пояснение:

- **HttpClient:** Angular предоставляет сервис для выполнения HTTP-запросов.
- **get:** метод для отправки GET-запроса, который возвращает Observable поток данных.
- **subscribe:** мы подписываемся на поток, чтобы обновить компонент, когда данные придут.

Теперь, когда вы знакомы с основами и практическим применением RxJS, попробуйте использовать эти концепции в своем коде. Создайте свой собственный Observable, примите данные и преобразуйте их с помощью операторов. Практикуйтесь как можно больше! В следующей теме мы обсудим, как использовать RxJS в более сложных сценариях, чтобы подготовиться к реальным проектам.

---

# Итоговое упражнение: Создание полноценного SPA с формами, анимациями, роутингом и использованием RxJS.

# Неделя 3: Резюме и практика

## Итоговое упражнение: Создание полноценного SPA с формами, анимациями, роутингом и использованием RxJS

На этой неделе мы соберём всё, что изучили до сих пор, и создадим полноценное одностраничное приложение (SPA), используя Angular. Мы будем работать с формами, анимациями, роутингом и реактивным программированием с помощью библиотеки RxJS. Давайте начнём!

### План

1. **Создание структуры приложения**
2. **Работа с формами**
3. **Реализация анимаций**
4. **Настройка маршрутизации (роутинга)**
5. **Использование RxJS для управления состоянием**

### Шаг 1: Создание структуры приложения

Начнём с создания простого Angular-приложения.

```bash
ng new MyApp
cd MyApp
ng generate component home
ng generate component about
ng generate component contact
```

У нас есть три компонента: `home`, `about` и `contact`. Они будут представлять разные страницы нашего SPA.

### Шаг 2: Работа с формами

Мы добавим форму для связи в компоненте `contact`.

**contact.component.html**

```html
<form (ngSubmit)="onSubmit()" #contactForm="ngForm">
  <div>
    <label for="name">Имя:</label>
    <input type="text" id="name" required [(ngModel)]="model.name" name="name" #name="ngModel">
    <div *ngIf="name.invalid && name.touched" class="error">
      Имя обязательно.
    </div>
  </div>

  <div>
    <label for="email">Email:</label>
    <input type="email" id="email" required [(ngModel)]="model.email" name="email" #email="ngModel">
    <div *ngIf="email.invalid && email.touched" class="error">
      Введите корректный email.
    </div>
  </div>

  <button type="submit" [disabled]="contactForm.invalid">Отправить</button>
</form>
```

Здесь у нас простая форма с двумя полями: `name` и `email`. Мы используем директиву `ngModel` для двусторонней привязки данных.

**contact.component.ts**

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-contact',
  templateUrl: './contact.component.html',
  styleUrls: ['./contact.component.css']
})
export class ContactComponent {
  model = {
    name: '',
    email: ''
  };

  onSubmit() {
    console.log('Форма отправлена:', this.model);
    alert('Thank you for your message!');
  }
}
```

Мы определили начальную модель данных и метод `onSubmit`, который выводит данные формы в консоль.

### Шаг 3: Реализация анимаций

Добавим простую анимацию при переходе между компонентами.

**app.component.html**

```html
<nav>
  <a routerLink="/">Home</a>
  <a routerLink="/about">About</a>
  <a routerLink="/contact">Contact</a>
</nav>
<router-outlet></router-outlet>
```

**app.component.ts**

```typescript
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { fader } from './route-animations';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  animations: [fader]
})
export class AppComponent {
  prepareRoute(outlet: RouterOutlet) {
    return outlet && outlet.activatedRouteData && outlet.activatedRouteData['animation'];
  }
}
```

**route-animations.ts**

```typescript
import { trigger, transition, style, query, animateChild, group, animate } from '@angular/animations';

export const fader =
  trigger('routeAnimations', [
    transition('* <=> *', [
      query(':enter, :leave', [
        style({
          position: 'absolute',
          width: '100%',
          opacity: 0,
          transform: 'scale(0.95)'
        })
      ], { optional: true }),
      query(':enter', [
        animate('600ms ease', style({ opacity: 1, transform: 'scale(1)' }))
      ], { optional: true })
    ])
  ]);
```

Анимация — это интересный способ сделать переходы между страницами плавными и более "живыми".

### Шаг 4: Настройка маршрутизации (роутинга)

Настроим маршрутизацию для навигации между компонентами.

**app-routing.module.ts**

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';
import { ContactComponent } from './contact/contact.component';

const routes: Routes = [
  { path: '', component: HomeComponent, data: { animation: 'HomePage' } },
  { path: 'about', component: AboutComponent, data: { animation: 'AboutPage' } },
  { path: 'contact', component: ContactComponent, data: { animation: 'ContactPage' } }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

Мы добавили маршруты для каждого из наших компонентов.

### Шаг 5: Использование RxJS для управления состоянием

Давайте создадим простую службу для управления состоянием нашего приложения с помощью RxJS.

**data.service.ts**

```typescript
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private messageSource = new BehaviorSubject<string>('Добро пожаловать в приложение!');
  currentMessage = this.messageSource.asObservable();

  changeMessage(message: string) {
    this.messageSource.next(message);
  }
}
```

**home.component.ts**

```typescript
import { Component, OnInit } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {
  message: string;

  constructor(private data: DataService) {}

  ngOnInit() {
    this.data.currentMessage.subscribe(message => this.message = message);
  }

  newMessage() {
    this.data.changeMessage("Новое сообщение из Главного компонента");
  }
}
```

**home.component.html**

```html
<h1>{{ message }}</h1>
<button (click)="newMessage()">Изменить сообщение</button>
```

Мы создали сервис `DataService` для управления обменом данных между компонентами с помощью паттерна Publish/Subscribe, который реализуется при помощи `BehaviorSubject` из RxJS.

### Заключение

Мы прошли весь путь от создания структуры приложения до его полной функциональности, включающей формы, анимации, роутинг и использование RxJS. Надеюсь, вы наслаждались созданием этого приложения и приобрели ценные знания, которые помогут вам на собеседовании и в реальных проектах!

---

# Angular CLI: Практическая работа с Angular CLI, создание нового проекта, генерация компонентов, модулей.

# Неделя 4: Подготовка к проектам

## Angular CLI: Практическая работа с Angular CLI, создание нового проекта, генерация компонентов, модулей

Приветствую на четвёртой неделе нашего курса! На этот раз мы погрузимся в мир инструментов и утилит, которые существенно упростят вашу работу с Angular. Нашим главным другом здесь станет Angular CLI (Command Line Interface). Это как волшебная палочка для разработчиков Angular, помогающая выполнять многие задачи легко и быстро.

### Зачем нужен Angular CLI?

Представьте, что вы собираетесь построить дом. Конечно, можно сделать всё вручную, но намного проще это сделать, если у вас есть инструменты и чертежи. Angular CLI - это и есть ваш набор инструментов для построения мощных Angular приложений. Он помогает:

- Быстро создавать проекты.
- Генерировать компоненты, модули и другие части приложения мгновенно.
- Упрощать настройку и развертывание приложения.

### Установка Angular CLI

Перед тем, как начать использовать Angular CLI, его нужно установить. Предположим, у вас уже установлен Node.js и npm (Node Package Manager). Тогда в вашем терминале достаточно выполнить команду:

```bash
npm install -g @angular/cli
```

Флаг `-g` означает, что мы устанавливаем Angular CLI глобально, чтобы он был доступен из любого места на вашем компьютере.

### Создание нового проекта Angular

Теперь, когда Angular CLI установлен, мы можем создать новый проект Angular. В терминале выполните следующую команду:

```bash
ng new my-angular-app
```

- `ng` — это сокращение от Angular.
- `new` — команда для создания нового проекта.
- `my-angular-app` — это имя вашего нового проекта. Вы можете выбрать любое подходящее название.

После запуска этой команды Angular CLI задаст вам несколько вопросов, таких как: хотите ли вы установить маршрутизацию и какой тип стилей (CSS, SCSS и т.д.) вы предпочитаете.

### Запуск проекта

После создания проекта вы можете запустить его на локальном сервере. Для этого перейдите в папку проекта и выполните команду:

```bash
cd my-angular-app
ng serve
```

Перейдя по адресу `http://localhost:4200`, вы увидите стартовую страницу вашего нового приложения Angular. Это значит, что всё работает правильно!

### Генерация компонентов

Теперь, когда мы создали проект, давайте научимся добавлять в него новые компоненты. Компоненты - это строительные блоки нашего приложения. Для генерации нового компонента используйте команду:

```bash
ng generate component my-new-component
```

Эта команда создаст новый компонент со всеми необходимыми файлами и обновит ваш модуль. Это сэкономит много времени, ведь делать всё это вручную — весьма утомительное занятие!

### Объяснение кода

Когда Angular CLI генерирует компонент, он создаёт несколько файлов:

- `my-new-component.component.ts`: TypeScript файл, содержащий логику компонента.
- `my-new-component.component.html`: Файл с шаблоном HTML для отображения компонента.
- `my-new-component.component.css`: Файл с CSS-стилями для компонента.
- `my-new-component.component.spec.ts`: Тестовый файл для написания unit-тестов.

Основной файл, к которому вы будете чаще всего обращаться, — это `.component.ts`. Вот пример того, как он может выглядеть:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-my-new-component',
  templateUrl: './my-new-component.component.html',
  styleUrls: ['./my-new-component.component.css']
})
export class MyNewComponent {
  myProperty: string = "Привет, Angular!";
}
```

Этот код определяет новый компонент с селектором `app-my-new-component`. `templateUrl` и `styleUrls` указывают на файлы шаблона и стилей соответственно. Внутри класса `MyNewComponent` мы можем описывать логику и свойства, например, `myProperty`, которое используется в шаблоне.

### Генерация модулей

Модули помогают организовывать код и управлять зависимостями. Для создания нового модуля используйте команду:

```bash
ng generate module my-new-module
```

Это создаст файл `my-new-module.module.ts`, который будет основой для добавления новых компонентов и сервисов, связанных между собой.

### Пример создания простого модуля

Допустим, мы хотим создать «Фотогалерею»:

```bash
ng generate module photo-gallery
```

В файле `photo-gallery.module.ts` будет что-то вроде:

```typescript
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { PhotoListComponent } from './photo-list/photo-list.component';
import { PhotoDetailComponent } from './photo-detail/photo-detail.component';

@NgModule({
  declarations: [PhotoListComponent, PhotoDetailComponent],
  imports: [CommonModule],
  exports: [PhotoListComponent]
})
export class PhotoGalleryModule { }
```

Здесь `PhotoGalleryModule` объединяет несколько компонентов, связанных с фотогалереей, и экспортирует `PhotoListComponent`, чтобы он мог использоваться за пределами этого модуля.

### Заключение

Работа с Angular CLI значительно упрощает процесс разработки. Теперь вы знаете, как создавать проекты, компоненты и модули — важные основы любого Angular приложения. В следующих темах мы продолжим углублять наши знания, разбирая сервисы, маршрутизацию и другие ключевые концепции Angular.

---

# Структура проекта: Использование Angular Style Guide для организации структуры приложения.

# Неделя 4: Подготовка к проектам

## Структура проекта: Использование Angular Style Guide для организации структуры приложения

Вот мы и добрались до этапа, когда можно взглянуть на приложение целиком и попробовать его спроектировать так, чтобы оно было понятным, удобным и легко расширяемым. Одним из лучших способов сделать это является следование Angular Style Guide.

### Что такое Angular Style Guide?

Angular Style Guide - это набор рекомендаций и лучших практик для разработки приложений на Angular. Они помогают поддерживать чистоту и порядок в коде, что особенно актуально, когда над проектом работают несколько человек или проект становится очень большим.

### Почему важна структура проекта?

Структура проекта — это как фундамент дома. Если она хорошо спроектирована, дальнейшее развитие приложения, добавление новых функций и исправление ошибок будет намного проще и быстрее. Хорошая структура помогает:

1. Легко находить нужные файлы.
2. Быстро понимать, как работают различные части приложения.
3. Минимизировать потенциальные конфликты между разработчиками.

### Основные правила структуры проекта

#### 1. Разделяй и властвуй: структура папок и файлов

Angular Style Guide рекомендует разделять проект на логически связанные части. Например, у нас могут быть следующие каталоги:

- **app**: содержит основной код приложения.
- **assets**: для изображений, шрифтов и других статических файлов.
- **environments**: для разных конфигураций окружения (например, для разработки и продакшена).

Внутри папки **app** мы можем выделить такие логические единицы:

- **core**: для сервисов и утилит, которые используются по всему приложению.
- **features**: подкаталоги для каждой функциональной части приложения.
- **shared**: для компонентов и директив, которые переиспользуются в нескольких местах.
- **styles**: глобальные стили.

Вот пример того, как может выглядеть структура каталога:

```
src/
  app/
    core/
      services/
      interceptors/
    features/
      feature-one/
        components/
        services/
        feature-one.module.ts
      feature-two/
        components/
        services/
        feature-two.module.ts
    shared/
      components/
      directives/
    app.module.ts
    app.component.ts
  assets/
  environments/
```

#### 2. Компонуем по функциям, а не по типам файлов

В отличие от некоторых других подходов, Angular Style Guide рекомендует «фичевую» (feature-based) структуру, а не групповую (по типам файлов). Это значит, что компоненты, сервисы и модели для одной и той же функциональности должны располагаться рядом.

### Практический пример: модуль и компоненты

Давайте реализуем простую функциональность в нашей структуре. Например, мы хотим создать модуль для управления списком задач (ToDo).

**1. Создайте модуль:**

Создайте папку `todo` в каталоге `features`, а в ней файл `todo.module.ts`:

```typescript
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TodoComponent } from './components/todo.component';

@NgModule({
  declarations: [TodoComponent],
  imports: [
    CommonModule
  ],
  exports: [TodoComponent]
})
export class TodoModule { }
```

Здесь мы импортируем необходимые модули, объявляем `TodoComponent` и экспортируем его, чтобы он мог использоваться в других частях приложения.

**2. Создайте компонент:**

В той же папке `todo/components` создайте файл `todo.component.ts`:

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-todo',
  template: `
    <h2>ToDo List</h2>
    <ul>
      <li *ngFor="let item of todoItems">{{ item }}</li>
    </ul>
  `
})
export class TodoComponent {
  todoItems: string[] = ['Task 1', 'Task 2', 'Task 3'];
}
```

Здесь мы создаем простой компонент, который отображает список задач. Шаблон компонента содержит список `todoItems`, который отображается с помощью директивы `*ngFor`.

**3. Интегрируем в приложение:**

Перейдите в `app.module.ts` и добавьте наш новый модуль:

```typescript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { AppComponent } from './app.component';
import { TodoModule } from './features/todo/todo.module';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    TodoModule  // Импортируем наш модуль
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

Теперь мы можем использовать компонент `app-todo` где угодно в нашем `AppComponent`.

**4. Используйте компонент в приложении:**

В `app.component.html` добавьте:

```html
<app-todo></app-todo>
```

Это вставит наш компонент todo-приложения в общую структуру.

**Примечание:** Распределяя проект таким образом, мы следуем фичевой структуре, что делает приложение более модульным и легким для понимания.

### Заключение

Правильная структура проекта помогает сосредоточиться на решении задач, а не на борьбе с хаосом в коде. Следуя Angular Style Guide и используя фичевую структуру, мы обеспечиваем читаемость и масштабируемость нашего кода, что критично для успеха проекта. Мы увидели, как создавать модули и компоненты, на практике применяя эти рекомендации. В будущих сессиях мы будем углубляться в другие аспекты проектирования и оптимизации Angular-приложений.

---

# Работа с environments: Управление конфигурациями для разработки и продакшн окружений.

# Неделя 4: Подготовка к проектам

## Работа с environments: Управление конфигурациями для разработки и продакшн окружений.

Когда вы начинаете работать над реальными проектами, которые будут использоваться в продакшене (то есть в реальной работе, доступные пользователям), возникает необходимость понять и научиться управлять различными конфигурациями для разных окружений. В Angular есть встроенная система, которая помогает легко справляться с этой задачей, и в этом топике мы подробно рассмотрим, как использовать её возможности.

### Что такое Environments?

В контексте Angular, **environments** (окружения) — это различные настроечные параметры, которые применяются к приложению в зависимости от того, где оно запускается. Обычно существуют по крайней мере два основных типа окружений:

- **Development (dev)**: Окружение для разработки. Здесь код тестируется и корректируется разработчиками.
- **Production (prod)**: Окружение для конечных пользователей. Здесь код должен работать стабильно и без ошибок.

Эти окружения могут иметь разные настройки, например, URL API, уровни логирования, включение отладочных инструментов и так далее.

### Как Angular управляет environments?

Angular предоставляет специальный механизм для переключения между разными конфигурациями окружений. Давайте рассмотрим, как это работает на практике.

#### Шаг 1: Настройка конфигураций окружений

После создания нового Angular проекта у вас уже будет базовая структура для работы с environments. Внутри папки `src/environments` вы найдете два файла:

- `environment.ts` — файл конфигурации для разработки.
- `environment.prod.ts` — файл конфигурации для продакшн-окружения.

**environment.ts:**
```typescript
export const environment = {
  production: false,
  apiUrl: 'http://localhost:3000/api'
};
```

**environment.prod.ts:**
```typescript
export const environment = {
  production: true,
  apiUrl: 'https://api.production.com'
};
```

Здесь мы видим, что каждый файл экспортирует объект с настройками. Например, в файле `environment.prod.ts` значение `production` равно `true`, и настраивается адрес API на `https://api.production.com`, в то время как в `environment.ts` указаны параметры для того, где происходит локальная разработка.

#### Шаг 2: Использование environments в коде

Теперь, как можно использовать эти окружения в вашем коде? Давайте рассмотрим простую службу, которая использует настройки из файлов environments.

**api.service.ts:**
```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../environments/environment';

@Injectable({
  providedIn: 'root'
})
export class ApiService {

  private apiUrl = environment.apiUrl;

  constructor(private http: HttpClient) {}

  getData() {
    return this.http.get(`${this.apiUrl}/data`);
  }
}
```

Здесь в файле `api.service.ts` мы импортируем `environment` и используем `apiUrl`, чтобы строить запросы к API. Это делает код гибким, так как в зависимости от окружения, будет подставляться нужный адрес.

#### Шаг 3: Сборка проекта с нужными конфигурациями

Когда вы запускаете проект в режиме разработки или собираете его для продакшн, Angular автоматически подставляет нужный файл конфигурации.

- Для разработки достаточно запустить `ng serve`, и файл `environment.ts` будет использован.
- Для продакшн сборки вы можете использовать команду `ng build --prod`. Она использует конфигурации из `environment.prod.ts`.

### Практическое упражнение

Чтобы убедиться, что вы понимаете, как работают environments в Angular, проделайте следующее:

1. Добавьте в `environment.ts` и `environment.prod.ts` новые параметры, например, `appVersion`. Для `development` задайте его как '1.0-dev', а для `prod` — '1.0'.
2. Создайте простой компонент, который будет отображать текущую версию приложения.
3. Используйте environments, чтобы получать и отображать это значение в компоненте.

**app.component.ts:**
```typescript
import { Component } from '@angular/core';
import { environment } from '../environments/environment';

@Component({
  selector: 'app-root',
  template: `<h1>Current App Version: {{ appVersion }}</h1>`
})
export class AppComponent {
  appVersion = environment.appVersion;
}
```

Теперь, когда вы запустите проект в режиме разработки, вы увидите 'Current App Version: 1.0-dev', а собрав для продакшн, получите 'Current App Version: 1.0'.

### Заключение

Управление конфигурациями для различных окружений является одной из ключевых практик в разработке программного обеспечения. Angular предлагает простой и эффективный способ справляться с этой задачей, позволяя вам изолировать и настраивать параметры для разработки и продакшн окружений, что способствует более гибкому и безопасному процессу разработки.

---

# Типизация: Создание интерфейсов и кастомных типов.

# Неделя 4: Подготовка к проектам

## Типизация: Создание интерфейсов и кастомных типов

Добро пожаловать на четвёртую неделю нашего курса! На предыдущих занятиях мы довольно плотно поработали с основами Angular. Теперь пришло время изучить, как мы можем эффективно управлять данными и защищать наш код от ошибок, используя мощь TypeScript в Angular-проектах. Сегодня мы поговорим про создание интерфейсов и кастомных типов.

### Почему нам важна типизация в Angular?

Типизация облегчает жизнь разработчикам. Представьте, что вы создаёте приложение, и вдруг забываете, какие данные должны быть у вас в объекте пользователя. Без типизации есть риск, что допущенная ошибка вызовет проблемы, которые станут заметны только тогда, когда приложение уже начнёт работать. С TypeScript у нас есть возможность предупредить ошибки благодаря строгой типизации. Это делает проект более стабильным и лёгким для понимания другими разработчиками.

### Интерфейсы в TypeScript

Интерфейсы в TypeScript помогают описывать структуры объектов. Давайте представим, что у нас есть объект, описывающий пользователя. Мы хотим, чтобы каждый пользователь имел имя, возраст и адрес электронного ящика.

#### Пример интерфейса пользователя:

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}
```

Вот как мы можем использовать этот интерфейс:

```typescript
const user: User = {
  name: 'Иван Иванов',
  age: 25,
  email: 'ivan.ivanov@example.com'
};
```

В этом примере, если мы попытаемся добавить в объект `user` свойство, которого нет в интерфейсе `User`, TypeScript выдаст ошибку. Это замечательный способ сохранить данные в порядке и избежать ошибок, связанных с неправильными типами.

### Кастомные типы

Порой вам может понадобиться нечто более гибкое, чем интерфейс, или просто другой способ описания типов. В таких ситуациях на помощь приходят алиасы типов (или кастомные типы). Они позволяют задавать альтернативные имена для типов и даже объединять их.

#### Пример кастомного типа:

Создадим тип для представления статуса задачи (например, в приложении для управления задачами):

```typescript
type TaskStatus = 'Not Started' | 'In Progress' | 'Completed';
```

Теперь мы можем использовать этот тип при описании задачи:

```typescript
interface Task {
  title: string;
  description: string;
  status: TaskStatus;
}

const task: Task = {
  title: 'Изучить интерфейсы и типы в TypeScript',
  description: 'Разобраться, как использовать интерфейсы и кастомные типы в Angular проектах.',
  status: 'In Progress'
};
```

Здесь `status` может быть только одним из трёх значений: 'Not Started', 'In Progress' или 'Completed'.

### Использование интерфейсов и типов в Angular-компонентах

Когда вы создаёте или работаете с Angular-компонентами, интерфейсы и типы играют важную роль в определении входных данных (inputs) и результатов (outputs). Например, представим компонент, который отображает информацию о пользователе.

#### Пример использования интерфейса в компоненте:

```typescript
import { Component, Input } from '@angular/core';

interface User {
  name: string;
  age: number;
  email: string;
}

@Component({
  selector: 'app-user-detail',
  template: `
    <h1>{{ user.name }}</h1>
    <p>Age: {{ user.age }}</p>
    <p>Email: {{ user.email }}</p>
  `
})
export class UserDetailComponent {
  @Input() user!: User;
}
```

Компонент `UserDetailComponent` ожидает входные данные, которые соответствуют интерфейсу `User`. Это упрощает процесс передачи данных в ваш компонент и защищает от ошибок в структуре данных.

### Подводим итоги

- **Интерфейсы** позволяют точно описать форму объекта и предохраняют от ошибок, связанных с некорректной структурой данных.
- **Кастомные типы** дают свободу в создании собственных типов для работы с ограниченными наборами значений или комбинировании простых и сложных структур.
- В **Angular** интерфейсы и типы особенно важны для описания входных данных компонентов, а также для упрощения и защиты внутренней логики вашего приложения.

Постарайтесь применить знания о типах и интерфейсах в своих текущих проектах. Убедитесь, что вы понимаете, как они работают, и не стесняйтесь экспериментировать. В следующем уроке мы продолжим углубляться в практические аспекты разработки приложений на Angular.

---

# Generics: Использование generics для создания более гибких компонентов и сервисов.

# Неделя 4: Подготовка к проектам

## Generics: Использование generics для создания более гибких компонентов и сервисов

Понимание generics может стать универсальным ключом, открывающим двери к созданию более универсальных и адаптивных компонентов и сервисов. Generics помогают писать код, который может работать с различными типами данных, не прибегая к дублированию. Давайте разберемся, как это работает и почему это важно для создания гибких приложений.

### Что такое Generics?

Представьте себе строительный набор, где у вас есть деталь, которая может принимать любую форму — квадрат, круг, треугольник. В программировании, generics — это такая деталь, абстракция, позволяющая классу, функции, или интерфейсу работать с любыми типами, сохраняя при этом типовую безопасность.

### Почему это важно?

Generics позволяют создавать универсальные компоненты и сервисы. Пример: вам нужно хранить список данных, но вы не хотите писать отдельный класс для списка чисел, строки, объектов и так далее. Generics позволяют создать единую структуру для всех подобных задач.

### Пример использования Generics в Angular

Давайте посмотрим на простой пример, где мы используем generics для создания универсального сервиса.

#### Создание универсального сервиса

Представьте, что у нас есть приложение для работы с различными видами сущностей: пользователи, продукты и т.д. Нам нужно создать сервис для управления ими.

```typescript
// define a generic service
export class DataService<T> {

  private data: T[] = [];

  constructor() {}

  addItem(item: T): void {
    this.data.push(item);
    console.log(`Item added:`, item);
  }

  getAllItems(): T[] {
    return this.data;
  }
}
```

##### Объяснение:

- `DataService<T>` — это класс с использованием generics. `T` — это обозначение типа, который будет использоваться в этом классе.
- Метод `addItem(item: T): void` добавляет элемент в массив `data`, и `T` гарантирует, что тип `item` совпадает с типом массива.
- Метод `getAllItems(): T[]` возвращает весь массив элементов типа `T`.

Теперь, когда у нас есть универсальный сервис `DataService`, мы можем использовать его с любым типом данных.

#### Использование нашего универсального сервиса

```typescript
// define interfaces
interface User {
  id: number;
  name: string;
}

interface Product {
  id: number;
  title: string;
  price: number;
}

// create instances of generic DataService
const userDataService = new DataService<User>();
userDataService.addItem({ id: 1, name: 'Alice' });
console.log(userDataService.getAllItems());

const productDataService = new DataService<Product>();
productDataService.addItem({ id: 101, title: 'Laptop', price: 999 });
console.log(productDataService.getAllItems());
```

##### Объяснение:

- Мы создали два интерфейса: `User` и `Product`, чтобы определять, какими будут наши данные.
- `userDataService` — это экземпляр `DataService`, который работает с типом `User`.
- `productDataService` — это экземпляр `DataService`, который работает с типом `Product`.
- Оба сервиса используют одно и то же базовое определение `DataService`, но при этом работают с различными типами данных, что и является основной силой generics.

### Использование generics в компонентах

Generics можно так же использовать и в компонентах Angular. Рассмотрим пример:

```typescript
import { Component, Input } from '@angular/core';

// Создаем интерфейс для элемента списка
interface ListItem {
  id: number;
  name: string;
}

// Компонент списка
@Component({
  selector: 'app-generic-list',
  template: `
    <ul>
      <li *ngFor="let item of items">
        {{ item.id }} - {{ item.name }}
      </li>
    </ul>
  `
})
export class GenericListComponent<T extends ListItem> {
  @Input() items: T[] = [];
}
```

##### Объяснение:

- `T extends ListItem` указывает, что тип `T` должен содержать все свойства интерфейса `ListItem`.
- Компонент `GenericListComponent` может быть использован для отображения списка любых данных, которые соответствуют интерфейсу `ListItem`.

#### Использование компонента

```html
<app-generic-list [items]="userList"></app-generic-list>
<app-generic-list [items]="productList"></app-generic-list>
```

##### Объяснение:

- В шаблоне используется `GenericListComponent` для отображения списков `userList` и `productList`.
- Это возможно благодаря тому, что оба списка содержат объекты, которые соответствуют нашему интерфейсу `ListItem`.

### Итог

Generics позволяют писать код, который адаптируется под конкретную ситуацию без потери общей типовой безопасности. Это особенно полезно в больших проектах, где нужно избегать дублирования и поддерживать единообразие в использовании структур данных и методов. Используя generics в ваших компонентах и сервисах Angular, вы закладываете основу для гибких и мощных приложений.

Попробуйте сами создать сервис или компонент с использованием generics и посмотрите, как это может упростить ваш код и сделать его более гибким и адаптивным.

---

# Декораторы TypeScript: Разбор декораторов в контексте Angular.

# Неделя 4: Подготовка к проектам

## Декораторы TypeScript: Разбор декораторов в контексте Angular

Привет! Мы продолжаем наше увлекательное погружение в мир Angular, и на этой неделе поговорим о декораторах. Если ты только начал знакомиться с Angular, возможно, ты уже заметил, что он активно использует такую штуку под названием "декораторы". Давай разберемся, что это такое и как они работают!

### Что такое декораторы?

Декораторы — это такая особая штуковина, которую можно представить как обёртку для класса или его части, позволяющую добавить или изменить его поведение. В Angular используется сразу несколько декораторов для создания компонентов, директив, сервисов и многого другого. Представь себе декораторы как стикеры, которые ты клеишь на фрукты в магазине, чтобы знать, что это за фрукт — яблоко, банан или что-то еще.

### Основные декораторы в Angular

1. **@Component**
2. **@Directive**
3. **@Injectable**
4. **@NgModule**

Сегодня мы рассмотрим каждый из них и поймём, как их использовать.

### @Component

Начнем с основного "строительного блока" в Angular — компонента. Компоненты — это кусочки интерфейса нашего приложения. Декоратор `@Component` помогает Angular понять, как именно выглядит и ведет себя этот кусочек.

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-hello-world',
  template: `<h1>Hello, World!</h1>`,
  styles: [`h1 { font-family: Lato; }`]
})
export class HelloWorldComponent {
  // Здесь может быть ваша логика
}
```

**Разбор кода:**

- `selector`: это имя HTML-тега, который ты будешь использовать, чтобы отображать этот компонент. 
- `template`: HTML-код, описывающий, как будет выглядеть компонент. Мы вставляем прямо HTML, но обычно хранить большие шаблоны лучше в отдельных файлах.
- `styles`: содержат информацию об оформлении, которая применяется только к данному компоненту.

### @Directive

Директивы — это еще один вид структурного блока, но в какой-то мере более "слабый", чем компонент. Они могут изменять поведение существующих элементов в вашем шаблоне.

```typescript
import { Directive, ElementRef, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(el: ElementRef, renderer: Renderer2) {
    renderer.setStyle(el.nativeElement, 'backgroundColor', 'yellow');
  }
}
```

**Разбор кода:**

- `el: ElementRef`: это ссылка на элемент, к которому применяется директива.
- `renderer: Renderer2`: это безопасный способ изменять стиль элемента (или его свойства).
- В данном примере мы изменяем цвет фона всех элементов, где используется `appHighlight`. Просто добавь это в HTML-код: `<div appHighlight>Highlighted!</div>`.

### @Injectable

Сервисы — это классы, которые предоставляют данные или логику вашему приложению и их удобно делать доступными для инъекций зависимости с помощью декоратора `@Injectable`.

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class DataService {
  getData() {
    return ['данные1', 'данные2', 'данные3'];
  }
}
```

**Разбор кода:**

- `providedIn: 'root'`: этим Angular говорит, что данный сервис должен быть создан единожды и доступен на протяжении всего жизненного цикла приложения, как singleton.
- `getData()`: метод-функция, которая возвращает данные. Этот метод может вызывать любой компонент или другой сервис, который использует `DataService`.

### @NgModule

Этот декоратор компонуется и управляет всеми элементами Angular, создавая модуль приложения.

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';
import { HelloWorldComponent } from './hello-world.component';

@NgModule({
  declarations: [
    AppComponent,
    HelloWorldComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

**Разбор кода:**

- `declarations`: здесь мы указываем компоненты и директивы, которые принадлежат этому модулю.
- `imports`: здесь находятся все модули, которые мы используем (например, браузерные стандартные).
- `providers`: указываем все сервисы, которые должны быть доступны из этого модуля.
- `bootstrap`: главный компонент приложения, с которого все начинается.

### Практическое задание

Давайте попробуем создать свой простой компонент и директиву! Создайте компонент, который отображает список задач, и директиву, которая изменяет цвет фона задачи, если она выполнена. Подумайте, как можно использовать сервис для управления списком задач в вашем компоненте.

Знай, что задание не про сложные технологии, а про использование простых компонентов, директив и сервисов. Помни, что декораторы делают код дружелюбнее и понятнее!

На этом пока всё о декораторах. На следующей неделе мы продолжим разбираться с проектами и углубимся в роутинг. Удачи с практикой!

---

# Angular Material: Углубленное использование Angular Material для построения UI.

# Неделя 4: Подготовка к проектам

## Angular Material: Углубленное использование для построения UI

Добро пожаловать на четвёртую неделю нашего приключения с Angular! На этом этапе мы будем глубже изучать, как использовать Angular Material для создания красивых и отзывчивых пользовательских интерфейсов (UI). Если раньше мы лишь слегка касались возможностей этой библиотеки, то сейчас пришло время изучить, как с её помощью можно облегчить себе жизнь при разработке приложений.

### Что такое Angular Material?

Angular Material — это библиотека компонентов, разработанная специально для Angular. Она предоставляет различные UI-компоненты, такие как кнопки, карточки, диалоги, и многое другое, которые соответствуют дизайну и стилю Material Design от Google.

### Почему Angular Material?

- **Единообразие**: Все компоненты имеют единый стиль и легко настраиваются.
- **Отзывчивость**: Компоненты адаптируются под различные размеры экранов.
- **Время**: Экономит время на разработку, так как многие элементы уже готовы к использованию.

### Начинаем с установки

Для начала работы с Angular Material нам нужно установить его в наш проект:

```bash
ng add @angular/material
```

Эта команда добавит Angular Material в ваш проект и предложит выбрать стандартную тему и настройки.

### Создание пользователей UI с Angular Material

Давайте воспользуемся Angular Material для создания красивой панели навигации и покажем, как это сделать шаг за шагом.

#### Добавим Панель Навигации

Панель навигации — важный элемент любого UI. Она помогает пользователям ориентироваться в приложении.

**Шаг 1: Импортируем MatToolbarModule и MatButtonModule**

Первым делом нам необходимо импортировать несколько модулей в наш `app.module.ts`.

```typescript
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatButtonModule } from '@angular/material/button';

@NgModule({
  imports: [
    MatToolbarModule,
    MatButtonModule,
    // другие модули
  ]
})
export class AppModule { }
```

**Шаг 2: Создаем компонент для навигации**

Создайте новый компонент для навигации.

```bash
ng generate component nav
```

**Шаг 3: Используем Angular Material в компоненте**

Теперь, в шаблоне (HTML) компонента, добавим код для панели навигации.

```html
<mat-toolbar color="primary">
  <span>Мое Приложение</span>
  <span class="spacer"></span>
  <button mat-button>Главная</button>
  <button mat-button>О нас</button>
  <button mat-button>Контакты</button>
</mat-toolbar>
```

Давайте посмотрим, что тут произошло:

- `mat-toolbar` — это компонент, который мы используем для создания верхней панели. Атрибут `color="primary"` задает основной цвет, определённый в теме.
- `span` — это простой HTML тег, который мы используем для декоративных целей, например, для размещения текста.
- `button mat-button` — это кнопки Material Design, которые автоматически стилизуются библиотекой для единообразия.

**Шаг 4: Добавим стиль для `spacer`**

Чтобы кнопки располагались справа, добавим небольшой стиль для класса `spacer`.

В файле стилей (`nav.component.css`):

```css
.spacer {
  flex: 1 1 auto;
}
```

Этот стиль позволяет `span` занимать всё доступное место, тем самым сдвигая кнопки вправо.

### Используем Angular Material: Карточки

Карточки — отличный способ организовать контент в виде небольших информационных блоков. Добавим карточки на главной странице нашего приложения.

**Шаг 1: Импортируем MatCardModule**

Сначала, как и прежде, импортируем модуль в `app.module.ts`.

```typescript
import { MatCardModule } from '@angular/material/card';

@NgModule({
  imports: [
    MatCardModule,
    // другие модули
  ]
})
export class AppModule { }
```

**Шаг 2: Используем карточки в шаблоне**

Теперь, в основном компоненте (`app.component.html`), добавим следующие карточки:

```html
<mat-card class="example-card">
  <mat-card-header>
    <div mat-card-avatar class="example-header-image"></div>
    <mat-card-title>Заголовок Карточки</mat-card-title>
    <mat-card-subtitle>Подзаголовок Карточки</mat-card-subtitle>
  </mat-card-header>
  <img mat-card-image src="example.jpg" alt="Образец изображения">
  <mat-card-content>
    <p>
      Это пример описания карточки. Здесь можно поместить различный текстовый контент или другие элементы.
    </p>
  </mat-card-content>
  <mat-card-actions>
    <button mat-button>ПОСМОТРЕТЬ</button>
    <button mat-button>ИЗУЧИТЬ</button>
  </mat-card-actions>
</mat-card>
```

Что тут важно:

- `mat-card`, `mat-card-header`, `mat-card-title`, и `mat-card-subtitle` модули помогают создать внешне привлекательную карточку.
- `mat-card-image` используется для добавления изображения в карточку.
- `mat-card-actions` позволяет размещать кнопки или действия внизу карточки.

### Практическое задание

Теперь, когда вы познакомились с азами создания UI с Angular Material, настало время применить это знание на практике.

1. Создайте страницу профиля пользователя, на которой будет отображаться картинка профиля и информация о пользователе с использованием карточек.
2. Добавьте на страницу панель навигации, которую мы создали ранее, и включите в неё пункты для дополнительных страниц вашего приложения.

Используя Angular Material, можно быстро и с минимальными усилиями создавать красивые и функциональные интерфейсы. Мы только начали изучать его возможности, поэтому продолжайте экспериментировать и исследовать!

В следующем занятии мы будем развивать наш опыт, изучая более сложные компоненты Angular Material и узнаем, как справляться с навигацией внутри приложения.

---

# Sass/SCSS: Практика с использованием SCSS для кастомизации стилей и создания тем.

# Неделя 4: Подготовка к проектам

## Sass/SCSS: Практика с использованием SCSS для кастомизации стилей и создания тем

Добро пожаловать на четвёртую неделю нашего путешествия в мир Angular! На этой неделе мы сосредоточимся на том, как использовать Sass и SCSS для создания стильных и масштабируемых приложений. Что же такое Sass и SCSS? Это расширения CSS, которые позволяют нам добавлять магию в наши стили — переменные, вложенность, миксины и многое другое, что делает наш CSS более мощным и удобным в поддержке.

### Знакомство с переменными

Давайте начнём с простого примера — использования переменных. В CSS нет возможности задавать переменные, но в SCSS это сделать очень просто. Переменные позволяют вам декларировать значения (например, цвета или размеры), которые будут использоваться по всему проекту, что значительно упрощает поддержку и изменение стилей.

**Пример:**
```scss
$primary-color: #3498db;
$secondary-color: #2ecc71;
$font-stack: 'Helvetica Neue', sans-serif;

body {
  font-family: $font-stack;
  background-color: $primary-color;
  color: white;
  
  .content {
    background-color: $secondary-color;
    padding: 20px;
  }
}
```

**Объяснение:**
В этом примере мы создали три переменные для цвета и шрифта. Затем мы использовали их в стилях для нашего тела и внутреннего контента, что упрощает изменение темы — достаточно поменять значение переменной, и стиль всего приложения изменится.

### Вложенность стилей

SCSS поддерживает вложенность, что делает ваш код более структурным и удобным для чтения. Вложенность позволяет нам лучше видеть, какие стили принадлежат каким элементам на странице.

**Пример:**
```scss
nav {
  ul {
    list-style-type: none;
    padding: 0;
    
    li {
      display: inline-block;
      margin-right: 15px;

      a {
        text-decoration: none;
        color: $primary-color;
        
        &:hover {
          color: darken($primary-color, 10%);
        }
      }
    }
  }
}
```

**Объяснение:**
Здесь мы стилизуем навигационное меню с использованием вложенности. Мы начинаем с `nav`, затем внутри него описываем стили для `ul` и `li`, и продолжая до уровней ссылок `a`. Также мы используем SCSS функцию `darken`, чтобы затемнить цвет при наведение курсора (hover).

### Использование миксинов

Миксины позволяют создавать наборы стилей, которые вы можете повторно использовать в своём коде. Это похоже на функции в программировании, которые помогают избегать дублирования кода.

**Пример:**
```scss
@mixin button-style($bg-color, $text-color) {
  background-color: $bg-color;
  color: $text-color;
  border: none;
  padding: 10px 20px;
  text-transform: uppercase;
  cursor: pointer;

  &:hover {
    background-color: lighten($bg-color, 10%);
  }
}

button.primary {
  @include button-style($primary-color, white);
}

button.secondary {
  @include button-style($secondary-color, white);
}
```

**Объяснение:**
В этом примере мы создали миксин `button-style`, который принимает два параметра: цвет фона и цвет текста. Этот миксин определяет стиль кнопок и добавляет hover-эффект. Затем миксин был использован для двух типов кнопок: `primary` и `secondary`, что значительно упрощает расширение и модификацию стилей.

### Создание тем

Теперь давайте на практике посмотрим, как можно использовать SCSS, чтобы создать переключаемые темы для вашего приложения. Представьте, что у вас есть приложение с двумя темами: светлой и тёмной. Используем SCSS переменные для реализации этой функциональности!

**Пример:**
```scss
$light-theme: (
  primary-color: #ffffff,
  secondary-color: #f0f0f0,
  text-color: #333333
);

$dark-theme: (
  primary-color: #333333,
  secondary-color: #444444,
  text-color: #ffffff
);

@mixin theme($theme-map) {
  background-color: map-get($theme-map, primary-color);
  color: map-get($theme-map, text-color);

  .header {
    background-color: map-get($theme-map, secondary-color);
  }
}

body.light-theme {
  @include theme($light-theme);
}

body.dark-theme {
  @include theme($dark-theme);
}
```

**Объяснение:**
В данном случае мы используем SCSS карты (maps) для хранения цветов каждой темы. Затем через миксин `theme`, который принимает карту в качестве аргумента, мы применяем стили. Это позволяет вам легко переключать темы через добавление соответствующего класса (`light-theme` или `dark-theme`) к элементу body.

Практика с использованием SCSS значительно улучшит ваши навыки работы со стилями, сделав код более чистым и поддерживаемым. Не забудьте попрактиковаться в создании собственных тем и стилизаций!

На следующей неделе продолжим углубляться в разработку проектов и начнём интегрировать наши знания на другом уровне!

---

# Челленджи: «Создайте уникальную тему с использованием SCSS и Angular Material».

# Неделя 4: Подготовка к проектам

## Челленджи: «Создайте уникальную тему с использованием SCSS и Angular Material»

Добро пожаловать на четвертую неделю нашего увлекательного приключения в мире Angular! На этой неделе мы сосредоточимся на том, как используя мощь Angular Material и SCSS, вы можете создать действительно уникальный внешний вид вашего приложения. Мы не просто изучаем теорию — мы окунемся в практику и создадим свою собственную тему. Эта задача поможет вам подготовиться к реальным проектам и собеседованиям, где требуется продемонстрировать навыки работы с Angular и современными инструментами стилизации.

### Шаг 1: Настройка проекта

Для начала вам потребуется убедиться, что Angular Material установлен в вашем проекте. Если этого еще не сделано, выполняйте следующие команды в терминале:

```bash
ng add @angular/material
```

Эта команда добавит все необходимые зависимости и интегрирует Angular Material в ваш проект. Она также предложит вам выбрать предустановленную тему, но мы ее позже изменим.

### Шаг 2: Настройка SCSS

Для гибкости и мощи стилизации мы будем использовать SCSS. Убедитесь, что ваш проект настроен на использование этого препроцессора, проверив файл `angular.json`. Стандартный Angular CLI поддерживает SCSS, так что вам, возможно, уже ничего не нужно будет менять. Если нет, измените следующее:

```json
"schematics": {
    "@schematics/angular:component": {
        "style": "scss"
    }
}
```

### Шаг 3: Создание своей темы

Теперь пришло время проявить креативность. Начнем с создания SCSS-файла для нашей темы. Создайте файл `custom-theme.scss` в папке `src` и напишите следующий код:

```scss
@use '@angular/material' as mat;
@use '@angular/material/theming' as theme;

// 1. Создаем свой цветовой палитры
$primary-color: theme.define-palette(theme.$indigo-palette, 500);
$accent-color: theme.define-palette(theme.$pink-palette, A200);
$warn-color: theme.define-palette(theme.$red-palette);

// 2. Создаем тему на их основе
$custom-theme: theme.define-light-theme((
  color: (
    primary: $primary-color,
    accent: $accent-color,
    warn: $warn-color,
  )
));

// 3. Включаем стили Angular Material с применением нашей темы
@include mat.core();
@include theme.all-component-themes($custom-theme);
```

**Описание:** 
- **@use:** Директива, позволяющая импортировать SCSS-модули и использовать их содержимое.
- **define-palette:** Функция для создания палитры цветов, где аргументом принимается базовый цвет и уровень интенсивности.
- **define-light-theme:** Функция для создания темы из палитр.

### Шаг 4: Применение темы к приложению

Теперь нужно интегрировать нашу новую тему в приложение. Включите `custom-theme.scss` в вашем основном файле стилей, например, `styles.scss`:

```scss
@import 'custom-theme.scss';
```

### Шаг 5: Использование Angular Material компонентов

Для проверки нашей темы добавим несколько компонентов Angular Material в ваше приложение. Что скажете, добавим кнопки и навигационный бар?

Откройте файл `app.component.html` и добавьте следующий код:

```html
<mat-toolbar color="primary">
  Уникальная тема моего приложения
</mat-toolbar>

<div style="padding: 20px;">
  <button mat-raised-button color="primary">Кнопка Главная</button>
  <button mat-raised-button color="accent">Кнопка Акцент</button>
</div>
```

**Описание:** 
- **mat-toolbar:** Компонент создает верхнюю панель с возможностью указать основной цвет.
- **mat-raised-button:** Объемная кнопка, которая может менять цветовая оформления.

### Челлендж

Теперь, когда у вас есть базовые знания и структура, пришло время немного поэкспериментировать! 
1. Попробуйте заменить используемые цвета на свои любимые.
2. Измените интенсивность цветов палитры.
3. Добавьте другие компоненты Angular Material, такие как карточки или чекбоксы, и посмотрите, как они выглядят с вашей новой темой.

Эта задача не только укрепит ваши знания Angular Material и SCSS, но и станет отличным способом для подготовки к собеседованию. Ваши будущие работодатели будут впечатлены, когда вы сможете продемонстрировать создание и настройку темы с нуля. Продолжайте эксперименты и создавайте что-то действительно уникальное!

---

# Практическая работа с оптимизацией приложения: Работа над производительностью приложения, оптимизация загрузки ресурсов, lazy loading и работа с Ivy.

# Неделя 6: Резюме и закрепление

## Практическая работа с оптимизацией приложения: Работа над производительностью приложения, оптимизация загрузки ресурсов, lazy loading и работа с Ivy

На этой неделе мы сосредоточимся на том, как сделать ваше Angular-приложение быстрым и отзывчивым. Мы разберёмся, как оптимизировать производительность, эффективно загружать ресурсы и использовать возможности Angular для улучшения времени загрузки. Давайте погрузимся в тему с большим количеством практики и примеров.

### Оптимизация производительности

1. **Использование Change Detection Strategy**:

По умолчанию Angular проверяет обновления изменений во всём дереве компонентов каждый цикл. Это может быть неэффективно. Чтобы исправить это, вы можете использовать стратегию `OnPush`.

```typescript
import { Component, ChangeDetectionStrategy } from '@angular/core';

@Component({
  selector: 'app-example',
  template: `<p>{{ data }}</p>`,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ExampleComponent {
  data = 'Hello world!';
}
```

**Объяснение**: С `ChangeDetectionStrategy.OnPush`, Angular проверяет изменения только тогда, когда входные данные изменяются, что снижает количество ненужных проверок.

2. **Использование TrackBy с ngFor**:

Когда Angular рендерит списки, он теряет много времени на повторные создания элементов DOM. Использование `trackBy` помогает Angular сохранить элементы DOM и обновлять только изменённые.

```typescript
@Component({
  selector: 'app-item-list',
  template: `
    <ul>
      <li *ngFor="let item of items; trackBy: trackById">{{ item.name }}</li>
    </ul>
  `
})
export class ItemListComponent {
  items = [{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }];

  trackById(index: number, item: any): number {
    return item.id;
  }
}
```

**Объяснение**: `trackById` помогает Angular отличить элементы, совпадение происходит по уникальному `id`. Это уменьшает количество изменений в DOM.

### Lazy Loading

Lazy loading – это метод, позволяющий загружать модули только по мере необходимости, что сокращает время первой загрузки приложения. Давайте рассмотрим, как настроить ленивую загрузку в Angular.

#### Шаги по настройке Lazy Loading:

1. **Создание модуля**:

```bash
ng generate module feature --route feature --module app.module
```

**Объяснение**: Эта команда создаёт новый модуль `feature` и настраивает его на ленивую загрузку с помощью маршрутов.

2. **Настройка маршрутов с ленивой загрузкой в `app-routing.module.ts`:**

```typescript
const routes: Routes = [
  { path: 'feature', loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule) }
];
```

**Объяснение**: Мы используем синтаксис `loadChildren`, который позволяет Angular загружать модуль `FeatureModule` только при переходе по маршруту 'feature'.

### Оптимизация загрузки ресурсов

Чтобы улучшить производительность, ограничьте загрузку ненужных ресурсов:

1. **Компрессия изображений**:

Используйте сжатые версии изображений (JPEG вместо PNG), и поддержите различные размеры изображений для разных экранов используя `srcset`.

2. **Использование шрифтов**:

Загрузка шрифтов может быть дорогой. Используйте только необходимые шрифты и форматы (WOFF2 предпочтительнее). Настройте предзагрузку важных шрифтов:

```html
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin="anonymous">
```

### Работа с Ivy

Ivy – это компилятор и движок рендеринга Angular следующего поколения. Используется по умолчанию в Angular 9 и выше.

1. **Поиск и устранение ненужного кода**:

Ivy помогает избавляться от неиспользуемого кода, что уменьшает размер конечного пакета:

- Используйте инструменты типа `source-map-explorer` для анализа и устранения мёртвого кода.

2. **Рефакторинг кода с использованием Ivy**:

Ivy отлично оптимизирует код, но вы можете помочь ему:

```typescript
@Component({
  selector: 'app-lightweight',
  template: `<p>{{ greeting }}</p>`
})
export class LightweightComponent {
  greeting = 'Hello!';
}
```

**Объяснение**: Этот компонент – простой пример, но фишка в том, что Ivy обеспечивает оптимизацию по умолчанию, уменьшая объём конечного исходного кода.

### Закрепление материала

1. **Практическое задание**:

Создайте новое Angular-приложение и настройте ленивую загрузку двух модулей. Используйте `ChangeDetectionStrategy.OnPush` и `trackBy` в компонентах со списками. Постарайтесь минимизировать размер загружаемых ресурсов и отслеживайте загружаемый бандл. Вы автоматически увидите заметное ускорение в скорости работы приложения и отклик интерфейса.

### Заключение

Оптимизация производительности Angular-приложения — это важная тема, которая включает в себя ряд стратегий, от ленивой загрузки до эффективного управления изменениями данных. Мы изучили основные техники и надеемся, что теперь вы будете чувствовать себя уверенно при оптимизации ваших собственных приложений.

---

# PrimeNG: Использование компонентов PrimeNG для построения UI.

# Неделя 5: UI-библиотеки и улучшение процесса разработки

### PrimeNG: Использование компонентов PrimeNG для построения UI

Сегодня мы погрузимся в увлекательный мир UI-библиотек, а именно — PrimeNG. Эта библиотека поможет вам с легкостью создавать привлекательные пользовательские интерфейсы. PrimeNG — это набор компонентов для Angular, уже готовых к использованию, так что вам не придется разрабатывать элементы интерфейса с нуля. Представьте себе, это как конструктор, где можно брать готовые кубики и собирать из них здание.

#### Начнем с установки

Прежде чем начать использовать PrimeNG, давайте установим библиотеку в наш Angular-проект. Для этого откройте терминал и выполните следующую команду:

```bash
npm install primeng primeicons --save
```

Здесь `primeng` — это сама библиотека компонентов, а `primeicons` — иконки, которые часто используются вместе с этими компонентами.

Не забудьте добавить стили в файл `angular.json`:

```json
"styles": [
  "src/styles.css",
  "node_modules/primeng/resources/themes/saga-blue/theme.css",
  "node_modules/primeng/resources/primeng.min.css",
  "node_modules/primeicons/primeicons.css"
],
```

#### Компоненты PrimeNG

Теперь, когда библиотека установлена, начнем с небольшого примера. Допустим, мы хотим создать кнопку и таблицу. 

##### Пример 1: Создание кнопки

Добавьте в ваш модуль импорт нужного компонента:

```typescript
import { ButtonModule } from 'primeng/button';

@NgModule({
  imports: [
    ...
    ButtonModule
  ],
  ...
})
export class AppModule { }
```

Теперь давайте добавим кнопку в наш компонент шаблона:

```html
<p-button label="Нажми меня" icon="pi pi-check" (onClick)="onClick()"></p-button>
```

Кнопка с PrimeNG это не просто стандартная кнопка, а кнопка с возможностью настройки — вы можете добавить текст, иконку и обработчик события на нажатие.

Вот функция, которая будет вызываться при клике:

```typescript
onClick() {
  alert('Вы нажали на кнопку!');
}
```

Теперь, когда вы нажмете на кнопку, вы увидите уведомление.

##### Пример 2: Создание таблицы

Компоненты PrimeNG для таблиц — это настоящая находка, когда необходимо отобразить данные. Представим, что у нас есть следующие данные:

```typescript
export class AppComponent {
  products = [
    { id: 1, name: 'Ноутбук', price: 2500 },
    { id: 2, name: 'Телефон', price: 800 },
    { id: 3, name: 'Монитор', price: 300 }
  ];
}
```

Импортируем модуль таблицы:

```typescript
import { TableModule } from 'primeng/table';

@NgModule({
  imports: [
    ...
    TableModule
  ],
  ...
})
export class AppModule { }
```

И добавим таблицу в шаблон:

```html
<p-table [value]="products">
  <ng-template pTemplate="header">
    <tr>
      <th>ID товара</th>
      <th>Название</th>
      <th>Цена</th>
    </tr>
  </ng-template>
  <ng-template pTemplate="body" let-product>
    <tr>
      <td>{{product.id}}</td>
      <td>{{product.name}}</td>
      <td>{{product.price}}</td>
    </tr>
  </ng-template>
</p-table>
```

Этот код создает таблицу с заголовками для каждого столбца и строками, отображающими данные о товарах.

#### Заключение

Теперь вы видите, как использовать PrimeNG для создания компонентов пользовательского интерфейса. Эта библиотека значительно упрощает процесс разработки и делает ваши приложения более привлекательными и функциональными без необходимости писать кучу CSS и HTML с нуля.

Не бойтесь экспериментировать с другими компонентами из библиотеки! Пробуйте добавлять диалоговые окна, вкладки, атрибуты навигации — все это и многое другое доступно в PrimeNG. В следующей части мы рассмотрим, как интегрировать другие компоненты для создания более сложных интерфейсов.

---

# Taiga UI: Сравнение UI-библиотек и их применение в реальных проектах.

# Неделя 5: UI-библиотеки и улучшение процесса разработки

## Taiga UI: Сравнение UI-библиотек и их применение в реальных проектах

В этой части курса мы поговорим об одном из важных аспектов разработки интерфейсов — выборе и использовании библиотеки компонентов. Такие библиотеки позволяют создавать полноценные приложения быстрее и проще за счёт уже готовых, стилизованных UI-элементов. Сегодня мы рассмотрим одну из популярных библиотек — Taiga UI — и сравним её с другими, а также научимся внедрять её в наши Angular-приложения.

### Почему выбирать библиотеку компонентов важно?

Библиотеки компонентов помогают разработчикам не изобретать велосипед с нуля, а использовать уже готовые, протестированные элементы интерфейса. Это не только экономит время, но и помогает поддерживать единый стиль в приложении. Важно выбрать библиотеку, которая отвечает требованиям проекта и команде будет комфортно с ней работать.

### Taiga UI: Основные преимущества

Taiga UI — это современная библиотека Angular-компонентов, которая отличается лаконичным стилем и гибкостью. Вот некоторые её преимущества:

- **Настраиваемость:** Taiga UI позволяет легко подстраивать компоненты под нужды проекта.
- **Стилизованность:** Компоненты изначально выглядят современно и привлекательно.
- **Широкий набор компонентов:** От кнопок и полей ввода до сложных таблиц и модальных окон.

### Сравнение с другими популярными библиотеками

На рынке существует множество библиотек, таких как Angular Material, NG-ZORRO и PrimeNG. Давайте кратко их сравним:

- **Angular Material:** Отлично интегрируется с Angular, предоставляет компоненты в стиле Material Design. Однако, для полного соответствия стилю может потребоваться дополнительная настройка.

- **NG-ZORRO:** Библиотека в стиле Ant Design, популярна в Китае и имеет очень богатый набор компонентов. Главный недостаток — размер бандла.

- **PrimeNG:** Очень много компонентов, но некоторые могут показаться устаревшими или избыточными.

- **Taiga UI:** Балансирует между функциональностью и лёгкостью настройки. Может быть проще для восприятия, чем более тяжеловесные аналоги.

### Внедрение Taiga UI в проект

Давайте разберём, как начать работу с Taiga UI. Мы создадим простой проект и добавим в него несколько компонентов из этой библиотеки.

#### Шаг 1: Установка Taiga UI

Для начала работы нам нужно установить Taiga UI в наш Angular проект. Это делается через npm (менеджер пакетов Node.js):

```bash
ng add @taiga-ui
```

Эта команда автоматически добавит необходимые зависимости в ваш проект и внесёт изменения в файлы стилей.

#### Шаг 2: Подключение модулей

Теперь, когда Taiga UI установлена, нам нужно подключить модули, которые мы собираемся использовать. Например, добавим кнопку и input из Taiga UI.

```typescript
// app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { TuiRootModule, TuiButtonModule, TuiInputModule } from '@taiga-ui/core';

@NgModule({
  declarations: [
    // Ваши компоненты
  ],
  imports: [
    BrowserModule,
    TuiRootModule,
    TuiButtonModule,
    TuiInputModule,
  ],
  providers: [],
  bootstrap: [/* Ваш главный компонент */]
})
export class AppModule { }
```

#### Шаг 3: Использование компонентов

Давайте добавим кнопку и поле ввода в наш HTML. Использование компонентов Taiga UI интуитивно понятно и похоже на другие Angular-библиотеки.

```html
<!-- app.component.html -->

<tui-root>
  <div class="example-container">
    <button tuiButton type="button">Нажми меня</button>
    <input tuiInput placeholder="Введите текст"/>
  </div>
</tui-root>
```

#### Шаг 4: Стиль и настройка

Компоненты Taiga UI уже стильно оформлены, но, конечно, можно и нужно подстраивать их под свои нужды. Например, изменим цвет кнопки через стили:

```scss
/* styles.scss */

.example-container {
  padding: 16px;
}

button[tuiButton] {
  background-color: #6200EE;
  color: #FFFFFF;
}
```

### Практическое задание

Теперь, когда вы знаете, как добавить и настроить компоненты из Taiga UI, попробуйте самостоятельно:

1. Добавьте поддержку модальных окон в ваше приложение.
2. Настройте компонент «таблица» для отображения списка данных.
3. Оптимизируйте внешний вид формы, используя компоненты Taiga UI.

Использование UI-библиотек может значительно ускорить процесс разработки и улучшить внешний вид приложения. Экспериментируйте, настраивайте элементы и делайте своё приложение ещё лучше.

---

# Storybook: Установка и настройка Storybook, создание документации для UI-компонентов.

# Неделя 5: UI-библиотеки и улучшение процесса разработки

## Storybook: Установка и настройка Storybook, создание документации для UI-компонентов

Приветствую на пятой неделе нашего курса! На этой неделе мы изучим, как упростить и улучшить процесс разработки с использованием инструментов для создания UI. Сегодня мы познакомимся с Storybook — мощным инструментом, который поможет вам документировать и тестировать ваши UI-компоненты.

### Что такое Storybook?

Storybook — это открытая среда разработки для UI-компонентов. Она позволяет вам разрабатывать компоненты изолированно друг от друга. Если вы создаете сложное приложение, где много компонентов, это может быть невероятно полезно. Представьте себе Storybook как интерфейс, где вы можете сосредоточиться на одном элементе интерфейса, сохранив его в отдельных историях.

### Установка Storybook

Для начала давайте установим Storybook в ваше Angular-приложение. Создадим новый Angular проект, если у вас его нет:

```sh
ng new my-angular-app
cd my-angular-app
```

Теперь установим Storybook. Storybook имеет специальный инструмент, который поможет настроить его для Angular:

```sh
npx sb init --type angular
```

Эта команда добавит необходимые зависимости и установит Storybook для вашего проекта.

### Запуск Storybook

После установки вы готовы к работе. Запустим Storybook с помощью команды:

```sh
npm run storybook
```

Откроется локальный сервер, доступный по адресу `http://localhost:6006`, где вы увидите интерфейс Storybook.

### Создание истории (stories)

В Storybook для каждого компонента создается отдельная история. Это позволяет изолированно демонстрировать различные состояния компонента.

Давайте создадим простой компонент кнопки и напишем для него историю.

1. Создадим компонент кнопки:

```sh
ng generate component Button
```

2. В `button.component.ts` напишем простой код для нашей кнопки:
   
```typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-button',
  template: `<button [ngStyle]="{'background-color': color}">{{label}}</button>`,
  styles: [`button { font-size: 16px; padding: 10px; }`]
})
export class ButtonComponent {
  @Input() label = 'Click me';
  @Input() color = 'blue';
}
```

3. Теперь создадим stories для компонента. В файле `src/stories/Button.stories.ts` напишем следующее:

```typescript
import { Meta, Story } from '@storybook/angular/types-6-0';

// Импортируем ваш компонент
import { ButtonComponent } from '../app/button/button.component';

export default {
  title: 'Example/Button',
  component: ButtonComponent,
  argTypes: {
    label: { control: 'text' },
    color: { control: 'color' },
  },
} as Meta;

const Template: Story<ButtonComponent> = (args: ButtonComponent) => ({
  component: ButtonComponent,
  props: args,
});

export const Primary = Template.bind({});
Primary.args = {
  label: 'Primary Button',
  color: 'blue',
};

export const Secondary = Template.bind({});
Secondary.args = {
  label: 'Secondary Button',
  color: 'gray',
};
```

### Что здесь происходит?

1. **Meta и Story:** Мы сначала импортируем `Meta` и `Story` — они нужны для типизации.
2. **export default:** Это создание конфигурации для вашего компонента. В `title` указывается путь и имя, под которыми он будет отображаться. `argTypes` позволяет контролировать входные параметры компонента.
3. **Template:** Это функция, создающая экземпляр компонента на основе предоставленных аргументов.
4. **Аргументы:** `Primary.args` и `Secondary.args` — это состояния нашего компонента, которые отображаются как отдельные истории в Storybook.

### Итог

Теперь у нас есть функциональный и видимый компонент в Storybook! Это надежный инструмент для предварительного просмотра и тестирования UI-компонентов. С такими возможностями у вас есть свобода экспериментировать с компонентами изолированно, не беспокоясь о влиянии на общее приложение.

Теперь, когда у вас есть основной опыт работы со Storybook, вы можете масштабировать его на более сложные компоненты, добавлять больше историй и активно использовать изменяемые параметры для контроля над отображением. Это значительно упростит разработку интерьерных компонентов и их интеграцию в проект.

Переходим дальше!

---

# ViewEngine и Ivy: Отличия между JIT и AOT компиляцией, оптимизация производительности с Ivy.

# Неделя 5: UI-библиотеки и улучшение процесса разработки

## ViewEngine и Ivy: Отличия между JIT и AOT компиляцией, оптимизация производительности с Ivy

На этой неделе мы окунемся в тайны Angular и узнаем, как он превращает ваш код в красивое, высокопроизводительное веб-приложение. Давайте поговорим о двух способах "перевода" вашего Angular кода на язык, понятный браузеру: Just-in-time (JIT) и Ahead-of-time (AOT) компиляция. Мы также обсудим, как новая платформа компиляции и рендеринга Ivy добавляет магии в этот процесс.

### Что такое JIT и AOT?

Прежде чем разбираться в Ivy, необходимо понять, чем JIT отличается от AOT.

- **JIT-компиляция (Just-In-Time)**: означает "прямо в момент". Это компиляция, которая происходит в вашем браузере во время загрузки приложения. Когда вы запускаете Angular приложение в режиме разработки, вы используете JIT. Ваш код компилируется непосредственно в браузере, что замедляет первоначальную загрузку страницы, но упрощает отладку и разработку.

- **AOT-компиляция (Ahead-Of-Time)**: противоположность JIT. Ваш код компилируется на этапе сборки, до того как он попадает в браузер. Это позволяет сократить время загрузки вашего приложения, так как браузеру уже не нужно ничего компилировать. Полученный в результате код меньше и быстрее загружается, что отлично подходит для продакшена.

### Пример для JIT

Предположим, у нас есть компонент:

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `<h1>{{ title }}</h1>`,
})
export class AppComponent {
  title = 'Добро пожаловать в JIT!';
}
```

Этот код компилируется JIT в браузере. Такой подход удобен на этапе разработки, когда вы хотите быстро внести изменения и тут же увидеть их результат.

### Пример для AOT

Тот же компонент, однако с использованием AOT, компилируется заранее:

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `<h1>{{ title }}</h1>`,
})
export class AppComponent {
  title = 'Добро пожаловать в AOT!';
}
```

Angular выполнит компиляцию этого компонента до того, как ваше приложение будет доставлено в браузер. В результате мы получаем оптимизированное и компактное приложение, быстрее загружаемое пользователем.

### Знакомимся с Ivy

Ivy — это следующая итерация платформы Angular для компиляции и рендеринга. Она делает компиляцию быстрее и эффективнее, а также улучшает скорости выполнения. С Ivy у нас есть более оптимизированный AOT-компилятор, который делает билд вашего приложения быстрее и проще.

#### Почему Ivy?

- **Меньше конечный размер пакета**: Ivy генерирует меньше JavaScript-кода, что ускоряет загрузку.
  
- **Улучшенная обратная совместимость**: обновление существующих приложений до Ivy не требует кардинальных изменений кода.

- **Оптимизированные процессы**: Код, генерируемый Ivy, проще и понятнее, что облегчает отладку и понимание работы приложения.

- **Соответствие компонентам**: Ivy поддерживает функцию "замены компонентов", что позволяет экономить ресурсы при пересборке приложения.

### Пример использования Ivy оптимизаций

Допустим, у вас есть сложный компонент, где используется множество построений данных:

```typescript
// large-component.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-large-component',
  template: `
    <div *ngFor="let item of items">
      <h2>{{ item.name }}</h2>
      <p>{{ item.description }}</p>
    </div>
  `,
})
export class LargeComponent {
  @Input() items: { name: string; description: string }[] = [];
}
```

С версией Angular, использующей Ivy, рендеринг этого компонента будет более оптимальным и быстрым, так как Ivy эффективно обрабатывает повторяющиеся элементы (например, ngFor).

### Оптимизация производительности с Ivy

1. **Модульность**: Используйте ленивую загрузку модулей, чтобы подтянуть только те ресурсы, которые нужны пользователю в данный момент, Ivy поможет в этом, предоставляя более эффективное управление.

2. **Эффективное использование директив и пайпов**: Make use of Angular’s powerful directives and pipes that Ivy has optimized further for fast execution.

3. **TrackBy и ключи**: Для структурных директив, таких как ngFor, используйте свойство trackBy, чтобы сократить количество рендеров.

4. **DetechChanges стратегия**: Используйте OnPush детектор изменений для компонентов, чтобы избежать лишних проверок и улучшить производительность вашего приложения.

### Заключение

Понимание того, как работает компиляция в Angular, и знание, как возможно улучшить производительность вашего приложения с помощью Ivy, является важной частью создания эффективных и быстрых веб-приложений. Используя преимущества AOT и внедряя передовые методы разработки с Ivy, вы сможете подготовиться к требованиям как современных приложений, так и интервью.

Теперь у вас есть представление о JIT и AOT компиляции, а также о том, как Ivy помогает ускорить рендеринг и оптимизировать производительность Angular приложений. Мы продолжаем идти по пути к становлению настоящими мастерами Angular!

---

# Проект: Создание дизайн-системы с Storybook.

# Неделя 5: UI-библиотеки и улучшение процесса разработки

## Проект: Создание дизайн-системы с Storybook

На этой неделе мы сфокусируемся на создании устойчивого и масштабируемого интерфейсного решения с использованием Storybook. Идея заключается в том, чтобы создать собственную дизайн-систему, которая поможет поддерживать визуальную и функциональную целостность вашего приложения.

### Зачем вам нужна дизайн-система?

Дизайн-система - это набор повторно используемых компонентов и стандартов, которые помогают упростить процесс разработки и обеспечить согласованность интерфейса. Используя такую систему, команды могут быстрее создавать новые функции, сокращать количество ошибок и поддерживать единый стиль.

### Знакомство с Storybook

Storybook - это инструмент для разработки, тестирования и документирования компонентов UI в изоляции. Он помогает визуализировать компоненты, делая их доступными для проверки и тестирования. Представьте это как инструмент, который позволяет вам "играть" с вашими компонентами UI.

### Установка и настройка Storybook

Начнем с установки Storybook в вашем Angular проекте. Для этого вам нужно открыть терминал и ввести следующую команду из корневой папки вашего проекта:

```bash
npx sb init
```

Эта команда автоматически установит все зависимости и настроит Storybook для работы с вашим проектом. После выполнения команды у вас появится новая папка `.storybook` и будет создан базовый пример компонента.

### Создание простого компонента кнопки

Давайте начнем с создания простого компонента кнопки, который мы потом добавим в Storybook. Создайте компонент следующим образом:

```bash
ng generate component Button
```

После создания у вас будет три файла, относящихся к компоненту: 

- `button.component.ts` - логика компонента
- `button.component.html` - шаблон компонента
- `button.component.css` - стили компонента

В `button.component.ts` вы можете определить базовую логику и входные параметры:

```typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-button',
  templateUrl: './button.component.html',
  styleUrls: ['./button.component.css']
})
export class ButtonComponent {
  @Input() label: string = 'Click me';
  @Input() primary: boolean = false;

  get classes() {
    return this.primary ? 'btn-primary' : 'btn-secondary';
  }
}
```

В `button.component.html` мы можем определить простую структуру кнопки:

```html
<button [ngClass]="classes">{{ label }}</button>
```

А в `button.component.css` добавим стили для наших кнопок:

```css
.btn-primary {
  background-color: blue;
  color: white;
}

.btn-secondary {
  background-color: gray;
  color: white;
}
```

### Добавление компонента кнопки в Storybook

Теперь, когда у нас есть компонент, давайте добавим его в Storybook. Для этого создайте файл с историей, например, `button.stories.ts`, в той же директории, что и ваш компонент:

```typescript
import { moduleMetadata, Meta, Story } from '@storybook/angular';
import { ButtonComponent } from './button.component';

// Define the metadata for the component stories
export default {
  title: 'Example/Button',
  component: ButtonComponent,
  decorators: [
    moduleMetadata({
      declarations: [ButtonComponent], // Add your component here
    }),
  ],
} as Meta;

// Create a template for your stories
const Template: Story<ButtonComponent> = (args: ButtonComponent) => ({
  props: args,
});

// Define stories with different states for the component
export const Primary = Template.bind({});
Primary.args = {
  primary: true,
  label: 'Primary Button',
};

export const Secondary = Template.bind({});
Secondary.args = {
  primary: false,
  label: 'Secondary Button',
};
```

### Запуск Storybook

После того как вы создали историю для компонента, запустите Storybook командой:

```bash
npm run storybook
```

Это откроет локальный сервер с интерфейсом Storybook в вашем браузере, где вы сможете увидеть визуализацию вашего компонента кнопки.

### Прочее улучшение

Storybook поддерживает множество добавочных возможностей, которые вы можете изучить. Например, вы можете:

- Добавить документацию для компонентов.
- Использовать аддоны для тестирования доступности.
- Интегрировать автоматическое тестирование визуальных изменений.

### Заключение

Создание дизайн-системы с использованием Storybook стало значительно проще и обеспечивает более гибкий и эффективный процесс разработки. Научившись изолировать компоненты и документировать их, вы получите универсальный инструмент для более быстрого и слаженного процесса работы с интерфейсом.

На следующей неделе мы продолжим углубляться в практику Angular, изучая более сложные аспекты и внутренние механизмы работы фреймворка. Приступаем к реализации и совершенствованию нашего проекта!

---

# Задача - создать приложжение на JIT и подключить его в AOT приложение

## Неделя 5: UI-библиотеки и улучшение процесса разработки

### Задача - создать приложение на JIT и подключить его в AOT приложение

Добро пожаловать на пятую неделю нашего курса! На этой неделе мы погрузимся в практическую задачу, заключающуюся в создании небольшого Angular-приложения с использованием Just-In-Time компиляции (JIT) и его интеграции в более крупное приложение, скомпилированное Ahead-Of-Time (AOT). Это поможет нам лучше понять различия между JIT и AOT, а также научиться их комбинировать в одном проекте. 

#### Введение в JIT и AOT

Angular поддерживает два типа компиляции:

- **Just-In-Time (JIT)** компиляция происходит в браузере во время загрузки приложения. Это удобно для разработки, так как позволяет быстро вносить изменения и видеть результаты без лишних шагов.
  
- **Ahead-Of-Time (AOT)** компиляция происходит на этапе сборки, до развертывания. Она улучшает производительность приложения, сокращает время загрузки и выявляет ошибки еще до запуска.

### Шаг 1: Создание JIT-приложения

Начнем с создания простого приложения, которое будет скомпилировано с помощью JIT. 

1. **Использование Angular CLI**

   Убедитесь, что Angular CLI установлен, или установите его с помощью команды:

   ```bash
   npm install -g @angular/cli
   ```

2. **Создание нового Angular-приложения**

   Создадим новое приложение:

   ```bash
   ng new jit-app --defaults
   ```

   После создания приложения откройте его в вашем любимом редакторе кода.

3. **Разработка приложения**

   Мы создадим простое приложение, которое отображает сообщение "Привет, мир!"

   Откроем файл `src/app/app.component.ts` и изменим компонент следующим образом:

   ```typescript
   import { Component } from '@angular/core';

   @Component({
     selector: 'app-root',
     template: `
       <h1>{{ title }}</h1>
     `,
     styles: []
   })
   export class AppComponent {
     title = 'Привет, мир!';
   }
   ```

4. **Запуск приложения в режиме JIT**

   Запускаем приложение:

   ```bash
   ng serve
   ```

   Перейдите в браузере по адресу `http://localhost:4200` и убедитесь, что ваше сообщение "Привет, мир!" отображается.

### Шаг 2: Интеграция JIT-приложения в AOT-приложение

Теперь давайте создадим основное приложение с AOT и интегрируем в него наше JIT-приложение.

1. **Создание основного AOT-приложения**

   Создаем еще одно Angular-приложение:

   ```bash
   ng new aot-app --defaults
   ```

2. **Конфигурация AOT-компиляции**

   AOT включено по умолчанию в производственном режиме сборки. Давайте убедимся, что компиляция работает корректно, добавив небольшие изменения.

   Откроем `angular.json` нашего `aot-app` проекта и убедимся, что в разделе конфигурации `production` есть `aot: true`.

3. **Интеграция JIT в AOT**

   Конечно, полноценное включение JIT-приложения требует его преобразования в вид, подходящий для AOT, или других решений, но для демонстрации концепции мы упростим задачу. Одним из путей интеграции может быть использование JIT-приложения как сторонней динамической библиотеки, которая загружается и использует JIT в браузере.

   **Пример для понимания:**

   В настоящем реальном проекте подобная интеграция может потребовать использования динамического импорта модулей или службы загрузки скриптов для выполнения JIT-кода в AOT-приложении.

### Заключение

В этом топике мы рассмотрели, как создавать приложения на JIT и AOT, чем они отличаются и как возможно приближаться к идеи их комбинирования в часто встречающихся сценариях. Это становится особенно важным в крупномасштабных приложениях, где производительность, простота и гибкость постоянно сталкиваются.

Продолжаем погружение в мир Angular! Впереди еще много интересных задач и новых техник!

---

# Как правильно рассказать о своих навыках: Практика структурирования своих знаний для собеседования.

# Неделя 7: Собеседования и подготовка к ним

## Как правильно рассказать о своих навыках: Практика структурирования своих знаний для собеседования

Итак, вы уже прошли долгий путь в изучении Angular и готовы выйти на сцену собеседования. Собеседование — это ваш шанс показать не только, что вы знаете, но и как вы можете адаптировать свои знания к решению реальных задач. Давайте разберем, как правильно структурировать свои ответы и что важно продемонстрировать на собеседовании.

### Подготовка структуры ответов

Перед тем как мы углубимся в практические примеры, важно понять, что собеседование — это не только проверка ваших знаний, но и того, как вы мыслите. Поэтому структура ответа имеет огромное значение.

1. **Сначала концепция, потом пример**: Начинайте ответ с краткого объяснения концепции и переходите к примерам из вашего опыта или учебных проектов.
   
2. **STAR-метод**: Используйте метод STAR (Ситуация, Задача, Действия, Результат) для описания своих проектов и примеров.

3. **Четкость и лаконичность**: Ваши ответы должны быть ясными и по существу.

## Пример: Как объяснить использование компонентов в Angular

### Концепция

Компоненты — это основа Angular. Они позволяют нам разделять приложения на небольшие, управляемые части, обеспечивая раздельное развитие и повторное использование кода.

### Пример

Допустим, вас просят рассказать про компоненты, можно привести пример проектирования простого списка задач.

```typescript
// task.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-task',
  template: `
    <div>
      <h3>{{ title }}</h3>
      <p>{{ description }}</p>
    </div>
  `
})
export class TaskComponent {
  title = 'Новая задача';
  description = 'Описание задачи';
}
```

### Пример объяснения

#### Ситуация (Situation)

В одном из моих проектов нам необходимо было создать простое приложение "Список задач". Основная цель — дать пользователю возможность видеть заголовок и описание каждой задачи.

#### Задача (Task)

Задачей было сделать приложение легким для масштабирования и обслуживания, а также обеспечить возможность повторного использования компонента для разных задач.

#### Действия (Actions)

Я начал с определения базового компонента `TaskComponent`, который отображает заголовок и описание для задачи. Использовал аннотацию `@Component` для определения метаданных компонента, таких как селектор и HTML-шаблон. Каждый компонент имеет свой класс, который определяет данные и поведение, как например свойства `title` и `description`.

#### Результат (Result)

В результате этого подхода мы смогли быстро добавлять новые задачи, просто используя тег `<app-task>` в HTML-коде. Компонентная архитектура позволила команде легко добавлять новые функции и изменять существующие.

### Упражнение

Представьте, что вы работаете над более сложным проектом, например, интернет-магазином. Попробуйте оформить ответ о применении компонентов, используя аналогичный подход.

1. **Опишите задачу, которую вы решаете.**
2. **Покажите, как вы разделили интерфейс на компоненты, например, для отображения продукта, корзины покупок и т.п.**
3. **Объясните, как использование компонентов облегчило разработку.**

### Размышляем над возможными вопросами

На собеседовании могут спросить, как вы решали проблемы или оптимизировали производительность. Например, вот как можно ответить на вопрос о производительности:

#### Вопрос: Как вы оптимизируете производительность в Angular-приложении?

### Пример ответа

#### Концепция

В Angular есть несколько стратегий для оптимизации производительности, таких как использование OnPush-смены обнаружения изменений и асинхронных каналов.

#### Пример

```typescript
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';

@Component({
  selector: 'app-product',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div>
      <h2>{{ product.name }}</h2>
      <p>Цена: {{ product.price | currency }}</p>
    </div>
  `
})
export class ProductComponent {
  @Input() product: { name: string; price: number };
}
```

#### Объяснение

Использование `ChangeDetectionStrategy.OnPush` позволяет Angular пропускать проверку компонента, если входные свойства не изменились, что экономит ресурсы и ускоряет приложение. В случае с компонентом продукта это значительно улучшает производительность, если у нас множество продуктов отображается на странице.

На этом этапе, помимо знания технических аспектов, важно демонстрировать уверенное владение инструментом и логическое мышление. Прежде чем идти на собеседование, рекомендуем потренироваться объяснять свои проекты, используя STAR-метод и приведенные советы. Уверенность в своих ответах и ясное понимание технологий — вот залог успеха на собеседовании.

---

# Популярные темы на собеседованиях: Разбор типичных вопросов и тем для интервью.

# Популярные темы на собеседованиях: Разбор типичных вопросов и тем для интервью

Мы с вами уже разобрали много аспеков Angular, но настоящая проверка знаний происходит не в теории, а на практике — в реальных проектах и на собеседованиях. Наша задача на этой неделе не просто понять, что от нас хотят услышать на интервью, но и научиться изящно и уверенно отвечать на сложные вопросы.

## 1. Основы архитектуры Angular

**Вопрос: Опишите, как организована архитектура приложения в Angular.**

Angular построен на компонентах. Это как кирпичики, из которых состоит ваш дом (приложение). Каждый компонент в Angular — это отдельная «комнатка» с файлом шаблона (HTML), логикой (TS), и стилями (CSS).

**Пример кода:**

```typescript
@Component({
  selector: 'app-room',
  template: `<h1>Welcome to the Room!</h1>`,
  styles: [`h1 { color: blue; }`]
})
export class RoomComponent { }
```

*Объяснение: Этот небольшой пример показывает основу компонента. Мы видим, как компонент описывается с помощью декоратора `@Component`, где мы указываем селектор компонента, его шаблон и стили.*

## 2. Жизненный цикл компонентов

**Вопрос: Какие вы знаете методы жизненного цикла Angular компонентов?**

Это набор методов, которые Angular вызывает в ходе создания и разрушения компонента. Ключевые из них:

- `ngOnInit`: вызывает после того, как Angular установил все входные свойства компонента.
- `ngOnChanges`: срабатывает при каждом изменении входных данных.
- `ngOnDestroy`: вызывает при удалении компонента.

**Пример кода:**

```typescript
export class LifecycleComponent implements OnInit, OnChanges, OnDestroy {
  ngOnInit() {
    console.log('Компонент инициализирован!');
  }

  ngOnChanges() {
    console.log('Изменены входные данные!');
  }

  ngOnDestroy() {
    console.log('Компонент будет уничтожен!');
  }
}
```

*Объяснение: Этот код демонстрирует реализацию методов жизненного цикла. Мы видим, что каждый вызов метода регистрируется в консоли. Эти методы позволяют нам выполнять код в нужный момент времени.*

## 3. Декораторы и их роль в Angular

**Вопрос: Что такое декораторы в Angular и какие их типы вы знаете?**

Декораторы — это специальные функции, которые добавляют метаданные к классам, методам и параметрам. В Angular мы активно используем их, особенно в компонентах.

**Распространенные типы:**

- `@Component`: описывает компонент.
- `@Directive`: создает новую директиву.
- `@Injectable`: делает класс доступным для внедрения зависимостей.
- `@Input` и `@Output`: для взаимодействия компонентов друг с другом.

**Пример кода:**

```typescript
@Component({
  selector: 'app-simple',
  template: `<p>Simple component!</p>`
})
export class SimpleComponent {
  @Input() data: string; // получает данные извне
  @Output() update = new EventEmitter<string>(); // отправляет событие наружу
}
```

*Объяснение: Здесь декораторы `@Input` и `@Output` позволяют компоненту принимать данные извне и отправлять событие, когда что-то происходит.*

## 4. Взаимодействие компонентов

**Вопрос: Как компоненты могут общаться друг с другом в Angular?**

Основные способы:

- **Через @Input и @Output**: для передачи данных и событий между родительским и дочерними компонентами.
- **Сервисами**: для передачи данных между компонентами, которые не находятся в отношении родитель-дочерний.

**Пример кода:**

```typescript
// родительский компонент
@Component({
  selector: 'app-parent',
  template: `<app-child [childData]="parentData" (childEvent)="onChildEvent($event)"></app-child>`,
})
export class ParentComponent {
  parentData = 'Привет, ребёнок!';
  
  onChildEvent(eventData: string) {
    console.log('Received data from child:', eventData);
  }
}

// дочерний компонент
@Component({
  selector: 'app-child',
  template: `<button (click)="sendEvent()">Send Data to Parent</button>`,
})
export class ChildComponent {
  @Input() childData: string;
  @Output() childEvent = new EventEmitter<string>();
  
  sendEvent() {
    this.childEvent.emit('Данные от ребёнка!');
  }
}
```

*Объяснение: Родительский компонент передает строку в дочерний через @Input, а дочерний компонент отправляет обратно событие через @Output. Это классический пример взаимодействия двух компонентов.*

## 5. Сервисы и Dependency Injection

**Вопрос: Как и для чего используются сервисы в Angular?**

Сервисы позволяют вынести логику, которую можно использовать в разных частях приложения. Dependency Injection (DI) делает этот процесс простым и организованным.

**Пример кода:**

```typescript
@Injectable({
  providedIn: 'root',
})
export class DataService {
  private data = [];

  addData(item: string) {
    this.data.push(item);
  }

  getData() {
    return this.data;
  }
}

// использование сервиса в компоненте
@Component({
  selector: 'app-example',
  template: `<button (click)="addItem()">Add Item</button>`
})
export class ExampleComponent {
  constructor(private dataService: DataService) {}

  addItem() {
    this.dataService.addData('Новый элемент');
    console.log(this.dataService.getData());
  }
}
```

*Объяснение: Здесь мы создаем сервис `DataService`, который управляет списком данных. Компонент `ExampleComponent` использует этот сервис для добавления и получения данных. Благодаря DI, сервис внедряется в компонент, и его методы легко доступны.*

---

Подготовиться к собеседованию — значит, не только знать ответы на теоретические вопросы, но и уметь показывать, как ваш код решает практические задачи. Практикуйтесь писать код, изучайте документацию и не стесняйтесь экспериментировать с примерами из нашего курса!

---

# Практика с типичными задачами: Разбор популярных задач на собеседованиях.

# Неделя 7: Собеседования и подготовка к ним

## Практика с типичными задачами: Разбор популярных задач на собеседованиях

Добро пожаловать в неделю, где мы сосредоточимся на вооружении вас навыками и знаниями, которые помогут вам блестяще пройти собеседования на позицию разработчика с использованием Angular. Одним из ключевых элементов подготовки к собеседованию является понимание типичных задач, которые вам могут предложить. Ниже мы познакомимся с несколькими распространёнными заданиями и рассмотрим, как их решать.

### Задача 1: Создание простого компонента

#### Описание

Собеседующий может попросить вас создать компонент, который отображает список элементов. Этот список может включать в себя, например, перечень задач или продуктов.

#### Пример кода

```typescript
// task.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-task',
  templateUrl: './task.component.html',
  styleUrls: ['./task.component.css']
})
export class TaskComponent {
  tasks = [
    { id: 1, name: 'Подготовка', completed: false },
    { id: 2, name: 'Изучение Angular', completed: false },
    { id: 3, name: 'Проект в Angular', completed: true }
  ];
}
```

```html
<!-- task.component.html -->
<ul>
  <li *ngFor="let task of tasks">
    {{ task.name }} - <span [ngClass]="{'completed': task.completed}">{{ task.completed ? 'Готово' : 'Не готово' }}</span>
  </li>
</ul>
```

```css
/* task.component.css */
.completed {
  color: green;
}
```

#### Объяснение

1. **Компонент**: Мы создали компонент `TaskComponent`, который будет отвечать за отображение наших задач.
2. **Список задач**: В компоненте мы объявили массив `tasks`, который хранит наши задачи в виде объектов.
3. **Шаблон**: В HTML-шаблоне мы используем директиву `*ngFor` для динамического перебора массива задач и создания списка `<li>` элементов.
4. **Стилизация**: С помощью Angular-атрибута `ngClass` мы динамически назначаем класс `completed` для завершённых задач, чтобы визуально выделить их.

### Задача 2: Реализация двухстороннего связывания

#### Описание

Интервьюер может попросить вас продемонстрировать понимание механизма двухстороннего связывания, например, создать простой компонент для редактирования текста.

#### Пример кода

```typescript
// editor.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-editor',
  templateUrl: './editor.component.html',
  styleUrls: ['./editor.component.css']
})
export class EditorComponent {
  text: string = 'Начальный текст';
}
```

```html
<!-- editor.component.html -->
<div>
  <h3>Текст для редактирования:</h3>
  <input [(ngModel)]="text" placeholder="Введите текст здесь">
  <p>Вы ввели: {{ text }}</p>
</div>
```

#### Объяснение

1. **Переменная**: Мы создаём переменную `text`, которая будет хранить текст.
2. **Двухстороннее связывание**: С помощью директивы `[(ngModel)]` мы реализуем двухстороннее связывание данных между полем ввода и переменной `text`.
3. **Динамическое отображение**: Текущий текст отображается под полем ввода и обновляется в реальном времени, как только пользователь вводит данные.

### Задача 3: Создание сервиса для работы с данными

#### Описание

Вам могут предложить разработать сервис для управления данными. Чаще всего это задача, связанная с работой с API через HTTP.

#### Пример кода

```typescript
// data.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private apiUrl = 'https://api.example.com/data';

  constructor(private http: HttpClient) {}

  getData(): Observable<any> {
    return this.http.get<any>(this.apiUrl);
  }
}
```

```typescript
// app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { HttpClientModule } from '@angular/common/http';
import { AppComponent } from './app.component';
import { DataService } from './data.service';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, HttpClientModule],
  providers: [DataService],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

#### Объяснение

1. **Сервис**: Мы создаём класс `DataService`, который будет работать с HTTP запросами к внешнему API.
2. **HttpClient**: Используя `HttpClient` из Angular, мы можем отправлять HTTP запросы. В данном случае мы используем метод `get`, который возвращает `Observable`.
3. **Регистрация сервиса**: Сервис зарегистрирован в `AppModule` с помощью провайдера, что делает его доступным для инъекции в любой компонент приложения.

### Заключение

Разбираясь с этими задачами, вы получаете не только понимание ключевых аспектов Angular, но и уверенность в себе, которая поможет на собеседовании. Помните, что ключом к успеху является практика и изучение документации. Продолжайте развиваться, делайте сложные вещи простыми и не забывайте, что вы учитесь для достижения вашей карьерной цели.

---

# Симуляция собеседований: Имитация реального интервью с Angular-разработчиком.

# Неделя 7: Собеседования и подготовка к ним

## Симуляция собеседований: Имитация реального интервью с Angular-разработчиком

На этом этапе курса вы уже достаточно продвинулись и готовы к погружению в атмосферу собеседования. Разберём вопросы, которые часто задают на интервью, и научимся демонстрировать свои навыки на реальных примерах.

### Вопрос 1: Объясните, что такое компонент в Angular и как его создать.

**Ответ:**

Компонент в Angular — это основная строительная единица приложения, похожая на блок конструктора. Каждый компонент отвечает за отображение определённого участка интерфейса и связан с соответствующим HTML-шаблоном и логикой на TypeScript.

#### Пример:

Создадим простой компонент "HelloWorld":

1. Создание компонента с помощью Angular CLI:

   ```bash
   ng generate component hello-world
   ```

   Это команда создаст структуру компонента со следующими файлами:

   - `hello-world.component.ts` — файл с логикой компонента.
   - `hello-world.component.html` — шаблон компонента.
   - `hello-world.component.css` — стили для компонента.
   - `hello-world.component.spec.ts` — файл для тестов (не обсуждаем в этом топике).

2. В файле `hello-world.component.ts` выглядит примерно так:

   ```typescript
   import { Component } from '@angular/core';

   @Component({
     selector: 'app-hello-world',
     templateUrl: './hello-world.component.html',
     styleUrls: ['./hello-world.component.css']
   })
   export class HelloWorldComponent {
     message: string = 'Привет, мир!';
   }
   ```

3. В файле `hello-world.component.html`:

   ```html
   <h1>{{ message }}</h1>
   ```

Этот компонент содержит простое сообщение "Привет, мир!" и отображает его в заголовке.

### Вопрос 2: Что такое директивы в Angular?

**Ответ:**

Директивы — это специальные инструкции в Angular, которые позволяют изменять DOM (Document Object Model). Их можно сравнить с суперспособностями, которые вы можете добавлять к обычным HTML-элементам.

#### Пример:

Создадим пользовательскую директиву, которая меняет цвет текста при наведении мыши.

1. Создание директивы с помощью Angular CLI:

   ```bash
   ng generate directive highlight
   ```

2. В файле `highlight.directive.ts`:

   ```typescript
   import { Directive, ElementRef, HostListener } from '@angular/core';

   @Directive({
     selector: '[appHighlight]'
   })
   export class HighlightDirective {
     constructor(private el: ElementRef) {}

     @HostListener('mouseenter') onMouseEnter() {
       this.highlight('yellow');
     }

     @HostListener('mouseleave') onMouseLeave() {
       this.highlight('');
     }

     private highlight(color: string) {
       this.el.nativeElement.style.backgroundColor = color;
     }
   }
   ```

3. Использование директивы в шаблоне:

   ```html
   <p appHighlight>Наведи на меня мышкой, чтобы увидеть эффект!</p>
   ```

Когда вы наведёте мышь на абзац, его фон изменится на жёлтый.

### Вопрос 3: Как работает сервис в Angular?

**Ответ:**

Сервисы в Angular используются для организации переиспользуемой бизнес-логики и работы с данными, такими как вызовы API. Их можно считать помощниками, которые выполняют задачи за кулисами, чтобы компоненты оставались чистыми и простыми.

#### Пример:

Создадим простой сервис, который возвращает список пользователей.

1. Создание сервиса с помощью Angular CLI:

   ```bash
   ng generate service user
   ```

2. В файле `user.service.ts`:

   ```typescript
   import { Injectable } from '@angular/core';

   @Injectable({
     providedIn: 'root'
   })
   export class UserService {
     private users = ['Alice', 'Bob', 'Charlie'];

     getUsers() {
       return this.users;
     }
   }
   ```

3. Использование сервиса в компоненте:

   ```typescript
   import { Component, OnInit } from '@angular/core';
   import { UserService } from './user.service';

   @Component({
     selector: 'app-user-list',
     template: `
       <h2>Список пользователей:</h2>
       <ul>
         <li *ngFor="let user of users">{{ user }}</li>
       </ul>
     `
   })
   export class UserListComponent implements OnInit {
     users: string[];

     constructor(private userService: UserService) {}

     ngOnInit() {
       this.users = this.userService.getUsers();
     }
   }
   ```

Здесь мы создали сервис `UserService`, который возвращает список пользователей, и компонент, который использует этот сервис для отображения списка.

### Заключение

Во время собеседований важно не только правильно отвечать на теоретические вопросы, но и уметь реализовывать практические задачи. Технический интервьюер может попросить вас написать код на месте, так что регулярная практика и повторение — ваш ключ к успеху. Продолжайте экспериментировать с примером кода, разбирайте ошибки и улучшайте свои навыки.

---

# Челленджи: «Ответьте на 5 популярных вопросов с собеседований по Angular».

# Неделя 7: Собеседования и подготовка к ним

## Челленджи: «Ответьте на 5 популярных вопросов с собеседований по Angular»

Поздравляю вас с прохождением первых шести недель нашего курса по Angular! Теперь вы находитесь на финишной прямой и готовитесь к собеседованию — важному шагу в вашей карьере разработчика. На этой неделе мы сосредоточимся на самых популярных вопросах, которые могут возникнуть на собеседованиях по Angular. Мы разберём их и рассмотрим, как можно уверенно ответить на каждый из них.

### Вопрос 1: Что такое компоненты в Angular?

**Ответ:**
Компоненты — это строительные блоки Angular-приложения. Каждый компонент представляет часть пользовательского интерфейса. Они объединяют логику и представление в одну конструкцию.

**Пример кода:**

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-hello-world',
  template: '<h1>Hello, World!</h1>',
  styles: ['h1 { font-family: Lato; }']
})
export class HelloWorldComponent {
  // Здесь можно добавлять логику компонента
}
```

**Объяснение:**

- `@Component` — это декоратор, который делает класс Angular-компонентом.
- `selector` — это имя, с помощью которого мы можем использовать компонент в шаблонах HTML.
- `template` — шаблон, который определяет, как компонент будет отображаться.
- `styles` — стили, применяемые к компоненту.

### Вопрос 2: Объясните, как работает двунаправленная привязка данных (data binding) в Angular.

**Ответ:**
Двунаправленная привязка данных — это механизм, который связывает данные модели с элементами пользовательского интерфейса (UI) и наоборот. Это позволяет автоматически обновлять элементы UI при изменении данных в модели и наоборот.

**Пример кода:**

```html
<input [(ngModel)]="userInput" placeholder="Type something"/>
<p>You entered: {{ userInput }}</p>
```

**Объяснение:**

- `[(ngModel)]` — синтаксис двунаправленной привязки. Это комбинация односторонней привязки (с использованием `[]`) и привязки события (с использованием `()`), создавая таким образом двунаправленную связь.
- В этом примере, когда пользователь что-то вводит в `<input>`, значение автоматически обновляется внутри переменной `userInput`, а также отображается внутри `<p>`.

### Вопрос 3: Как работают директивы в Angular? Какие бывают их типы?

**Ответ:**
Директивы — это инструкции, которые вы даёте Angular относительно того, как изменять структуру DOM или изменять его поведение.

**Пример кода:**

```html
<div *ngIf="isVisible">
  This div is conditionally visible.
</div>
<button (click)="toggleVisibility()">Toggle</button>
```

**Объяснение:**

- `*ngIf` — это структурная директива, которая изменяет структуру DOM, убирая или добавляя элемент в зависимости от логического условия.
- `(click)="toggleVisibility()"` — это пример использования директивы событий, которая отслеживает события DOM и вызывает соответствующие методы класса.

**Типы директив:**
1. **Структурные директивы**: Изменяют макет DOM, добавляя или удаляя элементы. (Например, `*ngIf`, `*ngFor`, `*ngSwitch`)
2. **Атрибутивные директивы**: Изменяют стиль или поведение существующих элементов. (Например, `ngClass`, `ngStyle`)
3. **Директивы компонентов**: На самом деле это сами компоненты, так как они также могут изменять поведение элемента, на который применены.

### Вопрос 4: Что такое сервисы в Angular и каким образом они используются?

**Ответ:**
Сервисы направлены на выполнение задач, которые не связаны с отображением. Их основная задача — предоставлять данные компонентам и выполнять логику приложения. Сервисы помогают делать код более чистым и организованным.

**Пример кода:**

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private data = ['Angular', 'React', 'Vue'];

  getData() {
    return this.data;
  }
}
```

**Объяснение:**

- `@Injectable` — декоратор, содержащий метаданные для службы. Он сообщает Angular, как эта служба будет предоставляться.
- `providedIn: 'root'` — означает, что этот сервис singleton и будет создан единожды для всего приложения.
- `getData()` — метод, который возвращает данные. Компоненты могут использовать этот метод для получения информации.

### Вопрос 5: Объясните роутинг в Angular и как его реализовать?

**Ответ:**
Роутинг позволяет создавать SPA (Single Page Application), где переходя по ссылкам, меняется лишь часть страницы, а не загружается новая.

**Пример кода:**

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';

const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

**Объяснение:**

- Создаём массив `routes` с объектами, где каждому пути (`path`) сопоставляется компонент.
- `RouterModule.forRoot(routes)` — настройки маршрутизации для основной части приложения.
- Экспортируем `AppRoutingModule`, чтобы использовать его в `AppModule`.

Теперь, когда пользователь переходит по URL '/about', Angular отображает `AboutComponent`.

Эти пять вопросов часто задают на собеседованиях, и хорошо подготовленные ответы на них помогут вам уверенно пройти это испытание. Не забывайте практиковаться, уверенность приходит с опытом. Успехов в собеседованиях!